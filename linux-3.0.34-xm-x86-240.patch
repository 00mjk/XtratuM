diff -Nur linux-3.0.34/arch/x86/configs/kontron_defconfig linux-3.0.34-xm/arch/x86/configs/kontron_defconfig
--- linux-3.0.34/arch/x86/configs/kontron_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.0.34-xm/arch/x86/configs/kontron_defconfig	2013-01-13 23:14:56.000000000 +0100
@@ -0,0 +1,2725 @@
+#
+# Automatically generated make config: don't edit
+# Linux/x86 3.0.34 Kernel Configuration
+#
+# CONFIG_64BIT is not set
+CONFIG_X86_32=y
+# CONFIG_X86_64 is not set
+CONFIG_X86=y
+CONFIG_INSTRUCTION_DECODER=y
+CONFIG_OUTPUT_FORMAT="elf32-i386"
+CONFIG_ARCH_DEFCONFIG="arch/x86/configs/i386_defconfig"
+CONFIG_GENERIC_CMOS_UPDATE=y
+CONFIG_CLOCKSOURCE_WATCHDOG=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_MMU=y
+CONFIG_ZONE_DMA=y
+# CONFIG_NEED_DMA_MAP_STATE is not set
+CONFIG_NEED_SG_DMA_LENGTH=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+# CONFIG_RWSEM_GENERIC_SPINLOCK is not set
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+# CONFIG_GENERIC_TIME_VSYSCALL is not set
+CONFIG_ARCH_HAS_CPU_RELAX=y
+CONFIG_ARCH_HAS_DEFAULT_IDLE=y
+CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
+CONFIG_HAVE_SETUP_PER_CPU_AREA=y
+CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK=y
+CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK=y
+# CONFIG_HAVE_CPUMASK_OF_CPU_MAP is not set
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+# CONFIG_ZONE_DMA32 is not set
+CONFIG_ARCH_POPULATES_NODE_MAP=y
+# CONFIG_AUDIT_ARCH is not set
+CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_X86_32_LAZY_GS=y
+CONFIG_ARCH_HWEIGHT_CFLAGS="-fcall-saved-ecx -fcall-saved-edx"
+CONFIG_KTIME_SCALAR=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_HAVE_IRQ_WORK=y
+CONFIG_IRQ_WORK=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_BZIP2=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+# CONFIG_FHANDLE is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_HAVE_SPARSE_IRQ=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_IRQ_FORCED_THREADING=y
+# CONFIG_SPARSE_IRQ is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TINY_RCU=y
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_RCU_TRACE is not set
+# CONFIG_TREE_RCU_TRACE is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_HAVE_UNSTABLE_SCHED_CLOCK=y
+# CONFIG_CGROUPS is not set
+CONFIG_NAMESPACES=y
+# CONFIG_UTS_NS is not set
+CONFIG_IPC_NS=y
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+# CONFIG_NET_NS is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_RD_XZ=y
+CONFIG_RD_LZO=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+# CONFIG_EXPERT is not set
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_PCSPKR_PLATFORM=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_PERF_COUNTERS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_PCI_QUIRKS=y
+CONFIG_SLUB_DEBUG=y
+# CONFIG_COMPAT_BRK is not set
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+# CONFIG_JUMP_LABEL is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_HAVE_IOREMAP_PROT=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_OPTPROBES=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_MIXED_BREAKPOINTS_REGS=y
+CONFIG_HAVE_USER_RETURN_NOTIFIER=y
+CONFIG_HAVE_PERF_EVENTS_NMI=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+
+#
+# GCOV-based kernel profiling
+#
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+CONFIG_BLK_DEV_BSG=y
+CONFIG_BLK_DEV_INTEGRITY=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+CONFIG_INLINE_SPIN_UNLOCK=y
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+CONFIG_INLINE_READ_UNLOCK=y
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+CONFIG_INLINE_WRITE_UNLOCK=y
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+# CONFIG_MUTEX_SPIN_ON_OWNER is not set
+# CONFIG_FREEZER is not set
+
+#
+# Processor type and features
+#
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+# CONFIG_SMP is not set
+# CONFIG_X86_EXTENDED_PLATFORM is not set
+# CONFIG_X86_32_IRIS is not set
+# CONFIG_SCHED_OMIT_FRAME_POINTER is not set
+CONFIG_PARAVIRT_GUEST=y
+# CONFIG_XEN_PRIVILEGED_GUEST is not set
+# CONFIG_KVM_CLOCK is not set
+# CONFIG_KVM_GUEST is not set
+# CONFIG_LGUEST_GUEST is not set
+CONFIG_XM_PARTITION=y
+# CONFIG_XM_BOOTCONSOLE is not set
+# CONFIG_XM_DEBUGCONSOLE is not set
+CONFIG_XM_VIRTSRV=y
+CONFIG_XM_SPARE_MANAGER=y
+CONFIG_XMIO_SERVER=y
+CONFIG_XMIO_CLIENT=y
+CONFIG_XMIO_SCAN_PERIOD=100
+# CONFIG_XMIO_SSE2_MEMCPY is not set
+CONFIG_PARAVIRT=y
+CONFIG_NO_BOOTMEM=y
+# CONFIG_MEMTEST is not set
+# CONFIG_M386 is not set
+# CONFIG_M486 is not set
+# CONFIG_M586 is not set
+# CONFIG_M586TSC is not set
+# CONFIG_M586MMX is not set
+# CONFIG_M686 is not set
+# CONFIG_MPENTIUMII is not set
+# CONFIG_MPENTIUMIII is not set
+# CONFIG_MPENTIUMM is not set
+# CONFIG_MPENTIUM4 is not set
+# CONFIG_MK6 is not set
+# CONFIG_MK7 is not set
+# CONFIG_MK8 is not set
+# CONFIG_MCRUSOE is not set
+# CONFIG_MEFFICEON is not set
+# CONFIG_MWINCHIPC6 is not set
+# CONFIG_MWINCHIP3D is not set
+# CONFIG_MELAN is not set
+# CONFIG_MGEODEGX1 is not set
+# CONFIG_MGEODE_LX is not set
+# CONFIG_MCYRIXIII is not set
+# CONFIG_MVIAC3_2 is not set
+# CONFIG_MVIAC7 is not set
+# CONFIG_MCORE2 is not set
+CONFIG_MATOM=y
+# CONFIG_X86_GENERIC is not set
+CONFIG_X86_INTERNODE_CACHE_SHIFT=6
+CONFIG_X86_CMPXCHG=y
+CONFIG_CMPXCHG_LOCAL=y
+CONFIG_X86_L1_CACHE_SHIFT=6
+CONFIG_X86_XADD=y
+CONFIG_X86_WP_WORKS_OK=y
+CONFIG_X86_INVLPG=y
+CONFIG_X86_BSWAP=y
+CONFIG_X86_POPAD_OK=y
+CONFIG_X86_USE_PPRO_CHECKSUM=y
+CONFIG_X86_TSC=y
+CONFIG_X86_CMPXCHG64=y
+CONFIG_X86_CMOV=y
+CONFIG_X86_MINIMUM_CPU_FAMILY=5
+CONFIG_X86_DEBUGCTLMSR=y
+CONFIG_CPU_SUP_INTEL=y
+CONFIG_CPU_SUP_CYRIX_32=y
+CONFIG_CPU_SUP_AMD=y
+CONFIG_CPU_SUP_CENTAUR=y
+CONFIG_CPU_SUP_TRANSMETA_32=y
+CONFIG_CPU_SUP_UMC_32=y
+# CONFIG_HPET_TIMER is not set
+CONFIG_DMI=y
+# CONFIG_IOMMU_HELPER is not set
+# CONFIG_IOMMU_API is not set
+CONFIG_NR_CPUS=1
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_X86_UP_APIC is not set
+# CONFIG_X86_MCE is not set
+CONFIG_VM86=y
+# CONFIG_TOSHIBA is not set
+# CONFIG_I8K is not set
+# CONFIG_X86_REBOOTFIXUPS is not set
+# CONFIG_MICROCODE is not set
+# CONFIG_X86_MSR is not set
+# CONFIG_X86_CPUID is not set
+CONFIG_NOHIGHMEM=y
+# CONFIG_HIGHMEM4G is not set
+# CONFIG_HIGHMEM64G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_X86_PAE is not set
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+# CONFIG_ARCH_DMA_ADDR_T_64BIT is not set
+CONFIG_NEED_NODE_MEMMAP_SIZE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ILLEGAL_POINTER_VALUE=0
+CONFIG_SELECT_MEMORY_MODEL=y
+# CONFIG_FLATMEM_MANUAL is not set
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_SPARSEMEM=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_SPARSEMEM_STATIC=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_COMPACTION is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_TRANSPARENT_HUGEPAGE is not set
+CONFIG_NEED_PER_CPU_KM=y
+# CONFIG_CLEANCACHE is not set
+# CONFIG_X86_CHECK_BIOS_CORRUPTION is not set
+CONFIG_X86_RESERVE_LOW=64
+# CONFIG_MATH_EMULATION is not set
+CONFIG_MTRR=y
+CONFIG_MTRR_SANITIZER=y
+CONFIG_MTRR_SANITIZER_ENABLE_DEFAULT=0
+CONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT=1
+CONFIG_X86_PAT=y
+CONFIG_ARCH_USES_PG_UNCACHED=y
+# CONFIG_SECCOMP is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+# CONFIG_SCHED_HRTICK is not set
+# CONFIG_KEXEC is not set
+CONFIG_PHYSICAL_START=0x1000000
+CONFIG_RELOCATABLE=y
+CONFIG_X86_NEED_RELOCS=y
+CONFIG_PHYSICAL_ALIGN=0x200000
+# CONFIG_COMPAT_VDSO is not set
+# CONFIG_CMDLINE_BOOL is not set
+
+#
+# Power management and ACPI options
+#
+# CONFIG_SUSPEND is not set
+# CONFIG_HIBERNATION is not set
+# CONFIG_PM_RUNTIME is not set
+# CONFIG_ACPI is not set
+# CONFIG_SFI is not set
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+# CONFIG_CPU_IDLE is not set
+
+#
+# Bus options (PCI etc.)
+#
+CONFIG_PCI=y
+# CONFIG_PCI_GOBIOS is not set
+# CONFIG_PCI_GOMMCONFIG is not set
+CONFIG_PCI_GODIRECT=y
+# CONFIG_PCI_GOANY is not set
+CONFIG_PCI_DIRECT=y
+CONFIG_PCI_DOMAINS=y
+# CONFIG_PCI_CNB20LE_QUIRK is not set
+# CONFIG_PCIEPORTBUS is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCI_STUB is not set
+# CONFIG_PCI_IOV is not set
+CONFIG_PCI_LABEL=y
+CONFIG_ISA_DMA_API=y
+CONFIG_ISA=y
+CONFIG_EISA=y
+# CONFIG_EISA_VLB_PRIMING is not set
+CONFIG_EISA_PCI_EISA=y
+CONFIG_EISA_VIRTUAL_ROOT=y
+CONFIG_EISA_NAMES=y
+# CONFIG_MCA is not set
+# CONFIG_SCx200 is not set
+# CONFIG_OLPC is not set
+CONFIG_AMD_NB=y
+# CONFIG_PCCARD is not set
+# CONFIG_HOTPLUG_PCI is not set
+# CONFIG_RAPIDIO is not set
+
+#
+# Executable file formats / Emulations
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+CONFIG_HAVE_ATOMIC_IOMAP=y
+CONFIG_HAVE_TEXT_POKE_SMP=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_XFRM_IPCOMP=m
+CONFIG_NET_KEY=m
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+# CONFIG_IP_FIB_TRIE_STATS is not set
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_ROUTE_CLASSID=y
+# CONFIG_IP_PNP is not set
+CONFIG_NET_IPIP=m
+# CONFIG_NET_IPGRE_DEMUX is not set
+CONFIG_IP_MROUTE=y
+# CONFIG_IP_MROUTE_MULTIPLE_TABLES is not set
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+CONFIG_INET_AH=m
+CONFIG_INET_ESP=m
+CONFIG_INET_IPCOMP=m
+CONFIG_INET_XFRM_TUNNEL=m
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_XFRM_MODE_TRANSPORT=m
+CONFIG_INET_XFRM_MODE_TUNNEL=m
+CONFIG_INET_XFRM_MODE_BEET=m
+CONFIG_INET_LRO=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+CONFIG_TCP_CONG_ADVANCED=y
+CONFIG_TCP_CONG_BIC=m
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_TCP_CONG_WESTWOOD=m
+CONFIG_TCP_CONG_HTCP=m
+CONFIG_TCP_CONG_HSTCP=m
+CONFIG_TCP_CONG_HYBLA=m
+CONFIG_TCP_CONG_VEGAS=m
+CONFIG_TCP_CONG_SCALABLE=m
+CONFIG_TCP_CONG_LP=m
+CONFIG_TCP_CONG_VENO=m
+CONFIG_TCP_CONG_YEAH=m
+CONFIG_TCP_CONG_ILLINOIS=m
+CONFIG_DEFAULT_CUBIC=y
+# CONFIG_DEFAULT_RENO is not set
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_TCP_MD5SIG=y
+# CONFIG_IPV6 is not set
+CONFIG_NETWORK_SECMARK=y
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NETFILTER_NETLINK_QUEUE=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_SECMARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
+# CONFIG_NF_CT_PROTO_DCCP is not set
+CONFIG_NF_CT_PROTO_GRE=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+CONFIG_NF_CONNTRACK_AMANDA=y
+CONFIG_NF_CONNTRACK_FTP=m
+CONFIG_NF_CONNTRACK_H323=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_BROADCAST=y
+CONFIG_NF_CONNTRACK_NETBIOS_NS=y
+# CONFIG_NF_CONNTRACK_SNMP is not set
+CONFIG_NF_CONNTRACK_PPTP=y
+CONFIG_NF_CONNTRACK_SANE=y
+CONFIG_NF_CONNTRACK_SIP=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_TPROXY=m
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=m
+CONFIG_NETFILTER_XT_CONNMARK=y
+
+#
+# Xtables targets
+#
+# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=y
+# CONFIG_NETFILTER_XT_TARGET_CT is not set
+# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
+CONFIG_NETFILTER_XT_TARGET_HL=y
+# CONFIG_NETFILTER_XT_TARGET_IDLETIMER is not set
+CONFIG_NETFILTER_XT_TARGET_MARK=m
+CONFIG_NETFILTER_XT_TARGET_NFLOG=m
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=m
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=m
+CONFIG_NETFILTER_XT_TARGET_RATEEST=m
+# CONFIG_NETFILTER_XT_TARGET_TEE is not set
+CONFIG_NETFILTER_XT_TARGET_TPROXY=m
+CONFIG_NETFILTER_XT_TARGET_TRACE=m
+CONFIG_NETFILTER_XT_TARGET_SECMARK=m
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=m
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+
+#
+# Xtables matches
+#
+# CONFIG_NETFILTER_XT_MATCH_ADDRTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=m
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+CONFIG_NETFILTER_XT_MATCH_DCCP=m
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+CONFIG_NETFILTER_XT_MATCH_DSCP=m
+CONFIG_NETFILTER_XT_MATCH_ESP=m
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_HELPER=m
+CONFIG_NETFILTER_XT_MATCH_HL=y
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=m
+# CONFIG_NETFILTER_XT_MATCH_IPVS is not set
+CONFIG_NETFILTER_XT_MATCH_LENGTH=m
+CONFIG_NETFILTER_XT_MATCH_LIMIT=m
+CONFIG_NETFILTER_XT_MATCH_MAC=m
+CONFIG_NETFILTER_XT_MATCH_MARK=m
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
+# CONFIG_NETFILTER_XT_MATCH_OSF is not set
+CONFIG_NETFILTER_XT_MATCH_OWNER=m
+CONFIG_NETFILTER_XT_MATCH_POLICY=m
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=m
+CONFIG_NETFILTER_XT_MATCH_QUOTA=m
+CONFIG_NETFILTER_XT_MATCH_RATEEST=m
+CONFIG_NETFILTER_XT_MATCH_REALM=m
+CONFIG_NETFILTER_XT_MATCH_RECENT=m
+CONFIG_NETFILTER_XT_MATCH_SCTP=m
+CONFIG_NETFILTER_XT_MATCH_SOCKET=m
+CONFIG_NETFILTER_XT_MATCH_STATE=m
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
+CONFIG_NETFILTER_XT_MATCH_STRING=m
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=m
+CONFIG_NETFILTER_XT_MATCH_TIME=m
+CONFIG_NETFILTER_XT_MATCH_U32=m
+# CONFIG_IP_SET is not set
+CONFIG_IP_VS=m
+# CONFIG_IP_VS_DEBUG is not set
+CONFIG_IP_VS_TAB_BITS=12
+
+#
+# IPVS transport protocol load balancing support
+#
+CONFIG_IP_VS_PROTO_TCP=y
+CONFIG_IP_VS_PROTO_UDP=y
+CONFIG_IP_VS_PROTO_AH_ESP=y
+CONFIG_IP_VS_PROTO_ESP=y
+CONFIG_IP_VS_PROTO_AH=y
+# CONFIG_IP_VS_PROTO_SCTP is not set
+
+#
+# IPVS scheduler
+#
+CONFIG_IP_VS_RR=m
+CONFIG_IP_VS_WRR=m
+CONFIG_IP_VS_LC=m
+CONFIG_IP_VS_WLC=m
+CONFIG_IP_VS_LBLC=m
+CONFIG_IP_VS_LBLCR=m
+CONFIG_IP_VS_DH=m
+CONFIG_IP_VS_SH=m
+CONFIG_IP_VS_SED=m
+CONFIG_IP_VS_NQ=m
+
+#
+# IPVS application helper
+#
+CONFIG_IP_VS_FTP=m
+CONFIG_IP_VS_NFCT=y
+# CONFIG_IP_VS_PE_SIP is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+CONFIG_IP_NF_QUEUE=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_IP_NF_TARGET_ULOG=y
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_NF_NAT_PROTO_GRE=y
+CONFIG_NF_NAT_PROTO_UDPLITE=y
+CONFIG_NF_NAT_PROTO_SCTP=y
+CONFIG_NF_NAT_FTP=m
+CONFIG_NF_NAT_IRC=y
+CONFIG_NF_NAT_TFTP=y
+CONFIG_NF_NAT_AMANDA=y
+CONFIG_NF_NAT_PPTP=y
+CONFIG_NF_NAT_H323=y
+CONFIG_NF_NAT_SIP=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_TARGET_CLUSTERIP=y
+CONFIG_IP_NF_TARGET_ECN=y
+CONFIG_IP_NF_TARGET_TTL=y
+CONFIG_IP_NF_RAW=y
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+# CONFIG_IP_DCCP is not set
+CONFIG_IP_SCTP=m
+# CONFIG_SCTP_DBG_MSG is not set
+# CONFIG_SCTP_DBG_OBJCNT is not set
+# CONFIG_SCTP_HMAC_NONE is not set
+# CONFIG_SCTP_HMAC_SHA1 is not set
+CONFIG_SCTP_HMAC_MD5=y
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+# CONFIG_DNS_RESOLVER is not set
+# CONFIG_BATMAN_ADV is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_AF_RXRPC=m
+# CONFIG_AF_RXRPC_DEBUG is not set
+# CONFIG_RXKAD is not set
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+# CONFIG_LIB80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_STANDALONE is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+# CONFIG_PARPORT is not set
+CONFIG_PNP=y
+CONFIG_PNP_DEBUG_MESSAGES=y
+
+#
+# Protocols
+#
+# CONFIG_ISAPNP is not set
+# CONFIG_PNPBIOS is not set
+# CONFIG_PNPACPI is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_XD is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=65536
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_VIRTIO_BLK=y
+# CONFIG_BLK_DEV_HD is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_IBM_ASM is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_INTEL_MID_PTI is not set
+# CONFIG_SGI_IOC4 is not set
+CONFIG_TIFM_CORE=y
+CONFIG_TIFM_7XX1=m
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_VMWARE_BALLOON is not set
+# CONFIG_BMP085 is not set
+# CONFIG_PCH_PHUB is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+CONFIG_CB710_CORE=y
+# CONFIG_CB710_DEBUG is not set
+CONFIG_CB710_DEBUG_ASSUMPTIONS=y
+# CONFIG_IWMC3200TOP is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_SENSORS_LIS3_I2C is not set
+CONFIG_HAVE_IDE=y
+CONFIG_IDE=y
+
+#
+# Please see Documentation/ide/ide.txt for help/info on IDE drives
+#
+CONFIG_IDE_XFER_MODE=y
+CONFIG_IDE_ATAPI=y
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_IDE_GD=y
+CONFIG_IDE_GD_ATA=y
+# CONFIG_IDE_GD_ATAPI is not set
+CONFIG_BLK_DEV_IDECD=y
+CONFIG_BLK_DEV_IDECD_VERBOSE_ERRORS=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+CONFIG_IDE_PROC_FS=y
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+CONFIG_BLK_DEV_PLATFORM=y
+# CONFIG_BLK_DEV_CMD640 is not set
+# CONFIG_BLK_DEV_IDEPNP is not set
+CONFIG_BLK_DEV_IDEDMA_SFF=y
+
+#
+# PCI IDE chipsets support
+#
+CONFIG_BLK_DEV_IDEPCI=y
+CONFIG_IDEPCI_PCIBUS_ORDER=y
+# CONFIG_BLK_DEV_OFFBOARD is not set
+CONFIG_BLK_DEV_GENERIC=y
+# CONFIG_BLK_DEV_OPTI621 is not set
+# CONFIG_BLK_DEV_RZ1000 is not set
+CONFIG_BLK_DEV_IDEDMA_PCI=y
+# CONFIG_BLK_DEV_AEC62XX is not set
+# CONFIG_BLK_DEV_ALI15X3 is not set
+# CONFIG_BLK_DEV_AMD74XX is not set
+# CONFIG_BLK_DEV_ATIIXP is not set
+# CONFIG_BLK_DEV_CMD64X is not set
+# CONFIG_BLK_DEV_TRIFLEX is not set
+# CONFIG_BLK_DEV_CS5520 is not set
+# CONFIG_BLK_DEV_CS5530 is not set
+# CONFIG_BLK_DEV_CS5535 is not set
+# CONFIG_BLK_DEV_CS5536 is not set
+# CONFIG_BLK_DEV_HPT366 is not set
+# CONFIG_BLK_DEV_JMICRON is not set
+# CONFIG_BLK_DEV_SC1200 is not set
+CONFIG_BLK_DEV_PIIX=y
+# CONFIG_BLK_DEV_IT8172 is not set
+# CONFIG_BLK_DEV_IT8213 is not set
+# CONFIG_BLK_DEV_IT821X is not set
+# CONFIG_BLK_DEV_NS87415 is not set
+# CONFIG_BLK_DEV_PDC202XX_OLD is not set
+# CONFIG_BLK_DEV_PDC202XX_NEW is not set
+# CONFIG_BLK_DEV_SVWKS is not set
+# CONFIG_BLK_DEV_SIIMAGE is not set
+# CONFIG_BLK_DEV_SIS5513 is not set
+# CONFIG_BLK_DEV_SLC90E66 is not set
+# CONFIG_BLK_DEV_TRM290 is not set
+# CONFIG_BLK_DEV_VIA82CXXX is not set
+# CONFIG_BLK_DEV_TC86C001 is not set
+
+#
+# Other IDE chipsets support
+#
+
+#
+# Note: most of these also require special kernel boot parameters
+#
+# CONFIG_BLK_DEV_4DRIVES is not set
+# CONFIG_BLK_DEV_ALI14XX is not set
+# CONFIG_BLK_DEV_DTC2278 is not set
+# CONFIG_BLK_DEV_HT6560B is not set
+# CONFIG_BLK_DEV_QD65XX is not set
+# CONFIG_BLK_DEV_UMC8672 is not set
+CONFIG_BLK_DEV_IDEDMA=y
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+CONFIG_RAID_ATTRS=m
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+CONFIG_SCSI_TGT=m
+CONFIG_SCSI_NETLINK=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_ST=m
+CONFIG_CHR_DEV_OSST=m
+CONFIG_BLK_DEV_SR=y
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_CHR_DEV_SG=y
+CONFIG_CHR_DEV_SCH=m
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+CONFIG_SCSI_SCAN_ASYNC=y
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+CONFIG_SCSI_SPI_ATTRS=y
+CONFIG_SCSI_FC_ATTRS=m
+CONFIG_SCSI_FC_TGT_ATTRS=y
+CONFIG_SCSI_ISCSI_ATTRS=m
+CONFIG_SCSI_SAS_ATTRS=m
+CONFIG_SCSI_SAS_LIBSAS=m
+# CONFIG_SCSI_SAS_ATA is not set
+CONFIG_SCSI_SAS_HOST_SMP=y
+CONFIG_SCSI_SRP_ATTRS=m
+CONFIG_SCSI_SRP_TGT_ATTRS=y
+CONFIG_SCSI_LOWLEVEL=y
+CONFIG_ISCSI_TCP=m
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_SCSI_CXGB3_ISCSI is not set
+# CONFIG_SCSI_CXGB4_ISCSI is not set
+# CONFIG_SCSI_BNX2_ISCSI is not set
+# CONFIG_SCSI_BNX2X_FCOE is not set
+# CONFIG_BE2ISCSI is not set
+CONFIG_BLK_DEV_3W_XXXX_RAID=m
+# CONFIG_SCSI_HPSA is not set
+CONFIG_SCSI_3W_9XXX=m
+# CONFIG_SCSI_3W_SAS is not set
+# CONFIG_SCSI_7000FASST is not set
+CONFIG_SCSI_ACARD=m
+# CONFIG_SCSI_AHA152X is not set
+# CONFIG_SCSI_AHA1542 is not set
+# CONFIG_SCSI_AHA1740 is not set
+CONFIG_SCSI_AACRAID=m
+CONFIG_SCSI_AIC7XXX=m
+CONFIG_AIC7XXX_CMDS_PER_DEVICE=8
+CONFIG_AIC7XXX_RESET_DELAY_MS=15000
+CONFIG_AIC7XXX_DEBUG_ENABLE=y
+CONFIG_AIC7XXX_DEBUG_MASK=0
+CONFIG_AIC7XXX_REG_PRETTY_PRINT=y
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+CONFIG_SCSI_AIC79XX=m
+CONFIG_AIC79XX_CMDS_PER_DEVICE=32
+CONFIG_AIC79XX_RESET_DELAY_MS=5000
+CONFIG_AIC79XX_DEBUG_ENABLE=y
+CONFIG_AIC79XX_DEBUG_MASK=0
+CONFIG_AIC79XX_REG_PRETTY_PRINT=y
+CONFIG_SCSI_AIC94XX=m
+# CONFIG_AIC94XX_DEBUG is not set
+CONFIG_SCSI_MVSAS=m
+CONFIG_SCSI_MVSAS_DEBUG=y
+CONFIG_SCSI_DPT_I2O=m
+CONFIG_SCSI_ADVANSYS=m
+# CONFIG_SCSI_IN2000 is not set
+CONFIG_SCSI_ARCMSR=m
+CONFIG_MEGARAID_NEWGEN=y
+CONFIG_MEGARAID_MM=m
+CONFIG_MEGARAID_MAILBOX=m
+CONFIG_MEGARAID_LEGACY=m
+CONFIG_MEGARAID_SAS=m
+# CONFIG_SCSI_MPT2SAS is not set
+CONFIG_SCSI_HPTIOP=m
+CONFIG_SCSI_BUSLOGIC=m
+# CONFIG_SCSI_FLASHPOINT is not set
+# CONFIG_VMWARE_PVSCSI is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_FCOE is not set
+# CONFIG_FCOE_FNIC is not set
+CONFIG_SCSI_DMX3191D=m
+# CONFIG_SCSI_DTC3280 is not set
+CONFIG_SCSI_EATA=m
+CONFIG_SCSI_EATA_TAGGED_QUEUE=y
+CONFIG_SCSI_EATA_LINKED_COMMANDS=y
+CONFIG_SCSI_EATA_MAX_TAGS=16
+CONFIG_SCSI_FUTURE_DOMAIN=m
+CONFIG_SCSI_GDTH=m
+# CONFIG_SCSI_ISCI is not set
+# CONFIG_SCSI_GENERIC_NCR5380 is not set
+# CONFIG_SCSI_GENERIC_NCR5380_MMIO is not set
+CONFIG_SCSI_IPS=m
+CONFIG_SCSI_INITIO=m
+CONFIG_SCSI_INIA100=m
+# CONFIG_SCSI_NCR53C406A is not set
+CONFIG_SCSI_STEX=m
+CONFIG_SCSI_SYM53C8XX_2=m
+CONFIG_SCSI_SYM53C8XX_DMA_ADDRESSING_MODE=1
+CONFIG_SCSI_SYM53C8XX_DEFAULT_TAGS=16
+CONFIG_SCSI_SYM53C8XX_MAX_TAGS=64
+CONFIG_SCSI_SYM53C8XX_MMIO=y
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_PAS16 is not set
+# CONFIG_SCSI_QLOGIC_FAS is not set
+CONFIG_SCSI_QLOGIC_1280=m
+CONFIG_SCSI_QLA_FC=m
+CONFIG_SCSI_QLA_ISCSI=m
+CONFIG_SCSI_LPFC=m
+# CONFIG_SCSI_SIM710 is not set
+# CONFIG_SCSI_SYM53C416 is not set
+CONFIG_SCSI_DC395x=m
+CONFIG_SCSI_DC390T=m
+# CONFIG_SCSI_T128 is not set
+# CONFIG_SCSI_U14_34F is not set
+# CONFIG_SCSI_ULTRASTOR is not set
+# CONFIG_SCSI_NSP32 is not set
+CONFIG_SCSI_DEBUG=m
+# CONFIG_SCSI_PMCRAID is not set
+# CONFIG_SCSI_PM8001 is not set
+CONFIG_SCSI_SRP=m
+# CONFIG_SCSI_BFA_FC is not set
+CONFIG_SCSI_DH=y
+CONFIG_SCSI_DH_RDAC=m
+CONFIG_SCSI_DH_HP_SW=m
+CONFIG_SCSI_DH_EMC=m
+CONFIG_SCSI_DH_ALUA=m
+# CONFIG_SCSI_OSD_INITIATOR is not set
+CONFIG_ATA=y
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_SATA_PMP=y
+
+#
+# Controllers with non-SFF native interface
+#
+# CONFIG_SATA_AHCI is not set
+# CONFIG_SATA_AHCI_PLATFORM is not set
+# CONFIG_SATA_INIC162X is not set
+# CONFIG_SATA_ACARD_AHCI is not set
+# CONFIG_SATA_SIL24 is not set
+CONFIG_ATA_SFF=y
+
+#
+# SFF controllers with custom DMA interface
+#
+# CONFIG_PDC_ADMA is not set
+# CONFIG_SATA_QSTOR is not set
+# CONFIG_SATA_SX4 is not set
+CONFIG_ATA_BMDMA=y
+
+#
+# SATA SFF controllers with BMDMA
+#
+# CONFIG_ATA_PIIX is not set
+# CONFIG_SATA_MV is not set
+# CONFIG_SATA_NV is not set
+# CONFIG_SATA_PROMISE is not set
+# CONFIG_SATA_SIL is not set
+# CONFIG_SATA_SIS is not set
+# CONFIG_SATA_SVW is not set
+# CONFIG_SATA_ULI is not set
+# CONFIG_SATA_VIA is not set
+# CONFIG_SATA_VITESSE is not set
+
+#
+# PATA SFF controllers with BMDMA
+#
+# CONFIG_PATA_ALI is not set
+# CONFIG_PATA_AMD is not set
+# CONFIG_PATA_ARASAN_CF is not set
+# CONFIG_PATA_ARTOP is not set
+# CONFIG_PATA_ATIIXP is not set
+# CONFIG_PATA_ATP867X is not set
+# CONFIG_PATA_CMD64X is not set
+# CONFIG_PATA_CS5520 is not set
+# CONFIG_PATA_CS5530 is not set
+# CONFIG_PATA_CS5535 is not set
+# CONFIG_PATA_CS5536 is not set
+# CONFIG_PATA_CYPRESS is not set
+# CONFIG_PATA_EFAR is not set
+# CONFIG_PATA_HPT366 is not set
+# CONFIG_PATA_HPT37X is not set
+# CONFIG_PATA_HPT3X2N is not set
+# CONFIG_PATA_HPT3X3 is not set
+# CONFIG_PATA_IT8213 is not set
+# CONFIG_PATA_IT821X is not set
+# CONFIG_PATA_JMICRON is not set
+# CONFIG_PATA_MARVELL is not set
+# CONFIG_PATA_NETCELL is not set
+# CONFIG_PATA_NINJA32 is not set
+# CONFIG_PATA_NS87415 is not set
+# CONFIG_PATA_OLDPIIX is not set
+# CONFIG_PATA_OPTIDMA is not set
+# CONFIG_PATA_PDC2027X is not set
+# CONFIG_PATA_PDC_OLD is not set
+# CONFIG_PATA_RADISYS is not set
+# CONFIG_PATA_RDC is not set
+# CONFIG_PATA_SC1200 is not set
+CONFIG_PATA_SCH=y
+# CONFIG_PATA_SERVERWORKS is not set
+# CONFIG_PATA_SIL680 is not set
+# CONFIG_PATA_SIS is not set
+# CONFIG_PATA_TOSHIBA is not set
+# CONFIG_PATA_TRIFLEX is not set
+# CONFIG_PATA_VIA is not set
+# CONFIG_PATA_WINBOND is not set
+
+#
+# PIO-only SFF controllers
+#
+# CONFIG_PATA_CMD640_PCI is not set
+# CONFIG_PATA_MPIIX is not set
+# CONFIG_PATA_NS87410 is not set
+# CONFIG_PATA_OPTI is not set
+# CONFIG_PATA_QDI is not set
+# CONFIG_PATA_RZ1000 is not set
+# CONFIG_PATA_WINBOND_VLB is not set
+
+#
+# Generic fallback / legacy drivers
+#
+CONFIG_ATA_GENERIC=y
+CONFIG_PATA_LEGACY=y
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_FUSION=y
+CONFIG_FUSION_SPI=y
+# CONFIG_FUSION_FC is not set
+# CONFIG_FUSION_SAS is not set
+CONFIG_FUSION_MAX_SGE=128
+# CONFIG_FUSION_CTL is not set
+# CONFIG_FUSION_LOGGING is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_FIREWIRE_NOSY is not set
+# CONFIG_I2O is not set
+# CONFIG_MACINTOSH_DRIVERS is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_NET_SB1000 is not set
+# CONFIG_ARCNET is not set
+CONFIG_MII=y
+# CONFIG_PHYLIB is not set
+CONFIG_NET_ETHERNET=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_LANCE is not set
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_ETHOC is not set
+# CONFIG_NET_VENDOR_RACAL is not set
+# CONFIG_DNET is not set
+# CONFIG_NET_TULIP is not set
+# CONFIG_AT1700 is not set
+# CONFIG_DEPCA is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_ISA is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+CONFIG_NET_PCI=y
+CONFIG_PCNET32=y
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_AC3200 is not set
+# CONFIG_KSZ884X_PCI is not set
+# CONFIG_APRICOT is not set
+# CONFIG_B44 is not set
+# CONFIG_FORCEDETH is not set
+# CONFIG_CS89x0 is not set
+# CONFIG_E100 is not set
+# CONFIG_LNE390 is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NE2K_PCI is not set
+# CONFIG_NE3210 is not set
+# CONFIG_ES3210 is not set
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
+# CONFIG_R6040 is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SMSC9420 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+# CONFIG_KS8851_MLL is not set
+# CONFIG_VIA_RHINE is not set
+# CONFIG_SC92031 is not set
+# CONFIG_ATL2 is not set
+CONFIG_NETDEV_1000=y
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+CONFIG_E1000E=y
+# CONFIG_IP1000 is not set
+# CONFIG_IGB is not set
+# CONFIG_IGBVF is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SKY2 is not set
+# CONFIG_VIA_VELOCITY is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
+# CONFIG_CNIC is not set
+# CONFIG_QLA3XXX is not set
+# CONFIG_ATL1 is not set
+# CONFIG_ATL1E is not set
+# CONFIG_ATL1C is not set
+# CONFIG_JME is not set
+# CONFIG_STMMAC_ETH is not set
+# CONFIG_PCH_GBE is not set
+CONFIG_NETDEV_10000=y
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_CHELSIO_T3 is not set
+# CONFIG_CHELSIO_T4 is not set
+# CONFIG_CHELSIO_T4VF is not set
+# CONFIG_ENIC is not set
+# CONFIG_IXGBE is not set
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+# CONFIG_VXGE is not set
+# CONFIG_MYRI10GE is not set
+# CONFIG_NETXEN_NIC is not set
+# CONFIG_NIU is not set
+# CONFIG_MLX4_EN is not set
+# CONFIG_MLX4_CORE is not set
+# CONFIG_TEHUTI is not set
+# CONFIG_BNX2X is not set
+# CONFIG_QLCNIC is not set
+# CONFIG_QLGE is not set
+# CONFIG_BNA is not set
+# CONFIG_SFC is not set
+# CONFIG_BE2NET is not set
+# CONFIG_TR is not set
+CONFIG_WLAN=y
+# CONFIG_AIRO is not set
+# CONFIG_ATMEL is not set
+# CONFIG_PRISM54 is not set
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_HOSTAP is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_WAN is not set
+
+#
+# CAIF transport drivers
+#
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NET_FC is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+CONFIG_VIRTIO_NET=y
+# CONFIG_VMXNET3 is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_FF_MEMLESS=y
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=800
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=480
+CONFIG_INPUT_JOYDEV=y
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_LIFEBOOK=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_PS2_ELANTECH is not set
+# CONFIG_MOUSE_PS2_SENTELIC is not set
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+CONFIG_MOUSE_SERIAL=y
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_INPORT is not set
+# CONFIG_MOUSE_LOGIBM is not set
+# CONFIG_MOUSE_PC110PAD is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_SYNAPTICS_I2C is not set
+CONFIG_INPUT_JOYSTICK=y
+# CONFIG_JOYSTICK_ANALOG is not set
+# CONFIG_JOYSTICK_A3D is not set
+# CONFIG_JOYSTICK_ADI is not set
+# CONFIG_JOYSTICK_COBRA is not set
+# CONFIG_JOYSTICK_GF2K is not set
+# CONFIG_JOYSTICK_GRIP is not set
+# CONFIG_JOYSTICK_GRIP_MP is not set
+# CONFIG_JOYSTICK_GUILLEMOT is not set
+# CONFIG_JOYSTICK_INTERACT is not set
+# CONFIG_JOYSTICK_SIDEWINDER is not set
+# CONFIG_JOYSTICK_TMDC is not set
+# CONFIG_JOYSTICK_IFORCE is not set
+# CONFIG_JOYSTICK_WARRIOR is not set
+# CONFIG_JOYSTICK_MAGELLAN is not set
+# CONFIG_JOYSTICK_SPACEORB is not set
+# CONFIG_JOYSTICK_SPACEBALL is not set
+# CONFIG_JOYSTICK_STINGER is not set
+# CONFIG_JOYSTICK_TWIDJOY is not set
+# CONFIG_JOYSTICK_ZHENHUA is not set
+# CONFIG_JOYSTICK_AS5011 is not set
+# CONFIG_JOYSTICK_JOYDUMP is not set
+# CONFIG_JOYSTICK_XPAD is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_HTCPEN is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_NOZOMI is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVKMEM=y
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+CONFIG_FIX_EARLYCON_MEM=y
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_MFD_HSU is not set
+# CONFIG_SERIAL_JSM is not set
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_PCH_UART is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+CONFIG_HVC_DRIVER=y
+CONFIG_VIRTIO_CONSOLE=y
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=m
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+CONFIG_HW_RANDOM_INTEL=m
+CONFIG_HW_RANDOM_AMD=m
+CONFIG_HW_RANDOM_GEODE=m
+CONFIG_HW_RANDOM_VIA=m
+CONFIG_HW_RANDOM_VIRTIO=m
+# CONFIG_NVRAM is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_SONYPI is not set
+# CONFIG_MWAVE is not set
+# CONFIG_PC8736x_GPIO is not set
+# CONFIG_NSC_GPIO is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_HANGCHECK_TIMER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+CONFIG_DEVPORT=y
+# CONFIG_RAMOOPS is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+# CONFIG_I2C_CHARDEV is not set
+# CONFIG_I2C_MUX is not set
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# PC SMBus host controller drivers
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_ISCH is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_INTEL_MID is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+# CONFIG_I2C_EG20T is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_ELEKTOR is not set
+# CONFIG_I2C_PCA_ISA is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_SCx200_ACB is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_SPI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+
+#
+# Enable Device Drivers -> PPS to see the PTP clock options.
+#
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+# CONFIG_GPIOLIB is not set
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_BQ20Z75 is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_ABITUGURU is not set
+# CONFIG_SENSORS_ABITUGURU3 is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_K8TEMP is not set
+# CONFIG_SENSORS_K10TEMP is not set
+# CONFIG_SENSORS_FAM15H_POWER is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_FSCHMD is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_CORETEMP is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM73 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_PMBUS is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_ADS1015 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VIA_CPUTEMP is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_SENSORS_APPLESMC is not set
+CONFIG_THERMAL=y
+# CONFIG_THERMAL_HWMON is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+CONFIG_MFD_SUPPORT=y
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_CS5535 is not set
+# CONFIG_LPC_SCH is not set
+# CONFIG_MFD_RDC321X is not set
+# CONFIG_MFD_JANZ_CMODIO is not set
+# CONFIG_MFD_VX855 is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+CONFIG_AGP=y
+# CONFIG_AGP_ALI is not set
+# CONFIG_AGP_ATI is not set
+# CONFIG_AGP_AMD is not set
+# CONFIG_AGP_AMD64 is not set
+CONFIG_AGP_INTEL=y
+# CONFIG_AGP_NVIDIA is not set
+# CONFIG_AGP_SIS is not set
+# CONFIG_AGP_SWORKS is not set
+# CONFIG_AGP_VIA is not set
+# CONFIG_AGP_EFFICEON is not set
+CONFIG_VGA_ARB=y
+CONFIG_VGA_ARB_MAX_GPUS=16
+CONFIG_DRM=y
+CONFIG_DRM_KMS_HELPER=y
+CONFIG_DRM_TTM=y
+# CONFIG_DRM_TDFX is not set
+# CONFIG_DRM_R128 is not set
+CONFIG_DRM_RADEON=y
+# CONFIG_DRM_RADEON_KMS is not set
+# CONFIG_DRM_I810 is not set
+# CONFIG_DRM_I915 is not set
+# CONFIG_DRM_MGA is not set
+# CONFIG_DRM_SIS is not set
+# CONFIG_DRM_VIA is not set
+# CONFIG_DRM_SAVAGE is not set
+# CONFIG_STUB_POULSBO is not set
+CONFIG_VGASTATE=y
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+CONFIG_FIRMWARE_EDID=y
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_WMT_GE_ROPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_FB_TILEBLITTING=y
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ARC is not set
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_IMSTT is not set
+# CONFIG_FB_VGA16 is not set
+# CONFIG_FB_VESA is not set
+# CONFIG_FB_N411 is not set
+# CONFIG_FB_HGA is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+CONFIG_FB_I810=y
+# CONFIG_FB_I810_GTF is not set
+# CONFIG_FB_LE80578 is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_VIA is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CARMINE is not set
+# CONFIG_FB_GEODE is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_VIRTIO is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+# CONFIG_VGACON_SOFT_SCROLLBACK is not set
+# CONFIG_MDA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_LOGO is not set
+CONFIG_SOUND=y
+CONFIG_SOUND_OSS_CORE=y
+CONFIG_SOUND_OSS_CORE_PRECLAIM=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_SEQUENCER=y
+# CONFIG_SND_SEQ_DUMMY is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_PCM_OSS_PLUGINS=y
+CONFIG_SND_SEQUENCER_OSS=y
+CONFIG_SND_DYNAMIC_MINORS=y
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+CONFIG_SND_VMASTER=y
+CONFIG_SND_DMA_SGBUF=y
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_ALOOP is not set
+# CONFIG_SND_VIRMIDI is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+CONFIG_SND_ISA=y
+# CONFIG_SND_ADLIB is not set
+# CONFIG_SND_AD1816A is not set
+# CONFIG_SND_AD1848 is not set
+# CONFIG_SND_ALS100 is not set
+# CONFIG_SND_AZT1605 is not set
+# CONFIG_SND_AZT2316 is not set
+# CONFIG_SND_AZT2320 is not set
+# CONFIG_SND_CMI8330 is not set
+# CONFIG_SND_CS4231 is not set
+# CONFIG_SND_CS4236 is not set
+# CONFIG_SND_ES1688 is not set
+# CONFIG_SND_ES18XX is not set
+# CONFIG_SND_SC6000 is not set
+# CONFIG_SND_GUSCLASSIC is not set
+# CONFIG_SND_GUSEXTREME is not set
+# CONFIG_SND_GUSMAX is not set
+# CONFIG_SND_INTERWAVE is not set
+# CONFIG_SND_INTERWAVE_STB is not set
+# CONFIG_SND_JAZZ16 is not set
+# CONFIG_SND_OPL3SA2 is not set
+# CONFIG_SND_OPTI92X_AD1848 is not set
+# CONFIG_SND_OPTI92X_CS4231 is not set
+# CONFIG_SND_OPTI93X is not set
+# CONFIG_SND_MIRO is not set
+# CONFIG_SND_SB8 is not set
+# CONFIG_SND_SB16 is not set
+# CONFIG_SND_SBAWE is not set
+# CONFIG_SND_SSCAPE is not set
+# CONFIG_SND_WAVEFRONT is not set
+# CONFIG_SND_MSND_PINNACLE is not set
+# CONFIG_SND_MSND_CLASSIC is not set
+CONFIG_SND_PCI=y
+# CONFIG_SND_AD1889 is not set
+# CONFIG_SND_ALS300 is not set
+# CONFIG_SND_ALS4000 is not set
+# CONFIG_SND_ALI5451 is not set
+# CONFIG_SND_ASIHPI is not set
+# CONFIG_SND_ATIIXP is not set
+# CONFIG_SND_ATIIXP_MODEM is not set
+# CONFIG_SND_AU8810 is not set
+# CONFIG_SND_AU8820 is not set
+# CONFIG_SND_AU8830 is not set
+# CONFIG_SND_AW2 is not set
+# CONFIG_SND_AZT3328 is not set
+# CONFIG_SND_BT87X is not set
+# CONFIG_SND_CA0106 is not set
+# CONFIG_SND_CMIPCI is not set
+# CONFIG_SND_OXYGEN is not set
+# CONFIG_SND_CS4281 is not set
+# CONFIG_SND_CS46XX is not set
+# CONFIG_SND_CS5530 is not set
+# CONFIG_SND_CS5535AUDIO is not set
+# CONFIG_SND_CTXFI is not set
+# CONFIG_SND_DARLA20 is not set
+# CONFIG_SND_GINA20 is not set
+# CONFIG_SND_LAYLA20 is not set
+# CONFIG_SND_DARLA24 is not set
+# CONFIG_SND_GINA24 is not set
+# CONFIG_SND_LAYLA24 is not set
+# CONFIG_SND_MONA is not set
+# CONFIG_SND_MIA is not set
+# CONFIG_SND_ECHO3G is not set
+# CONFIG_SND_INDIGO is not set
+# CONFIG_SND_INDIGOIO is not set
+# CONFIG_SND_INDIGODJ is not set
+# CONFIG_SND_INDIGOIOX is not set
+# CONFIG_SND_INDIGODJX is not set
+# CONFIG_SND_EMU10K1 is not set
+# CONFIG_SND_EMU10K1X is not set
+# CONFIG_SND_ENS1370 is not set
+# CONFIG_SND_ENS1371 is not set
+# CONFIG_SND_ES1938 is not set
+# CONFIG_SND_ES1968 is not set
+# CONFIG_SND_FM801 is not set
+CONFIG_SND_HDA_INTEL=y
+# CONFIG_SND_HDA_HWDEP is not set
+# CONFIG_SND_HDA_INPUT_BEEP is not set
+# CONFIG_SND_HDA_INPUT_JACK is not set
+# CONFIG_SND_HDA_PATCH_LOADER is not set
+CONFIG_SND_HDA_CODEC_REALTEK=y
+CONFIG_SND_HDA_CODEC_ANALOG=y
+CONFIG_SND_HDA_CODEC_SIGMATEL=y
+CONFIG_SND_HDA_CODEC_VIA=y
+CONFIG_SND_HDA_CODEC_HDMI=y
+CONFIG_SND_HDA_CODEC_CIRRUS=y
+CONFIG_SND_HDA_CODEC_CONEXANT=y
+CONFIG_SND_HDA_CODEC_CA0110=y
+CONFIG_SND_HDA_CODEC_CMEDIA=y
+CONFIG_SND_HDA_CODEC_SI3054=y
+CONFIG_SND_HDA_GENERIC=y
+# CONFIG_SND_HDA_POWER_SAVE is not set
+# CONFIG_SND_HDSP is not set
+# CONFIG_SND_HDSPM is not set
+# CONFIG_SND_ICE1712 is not set
+# CONFIG_SND_ICE1724 is not set
+# CONFIG_SND_INTEL8X0 is not set
+# CONFIG_SND_INTEL8X0M is not set
+# CONFIG_SND_KORG1212 is not set
+# CONFIG_SND_LOLA is not set
+# CONFIG_SND_LX6464ES is not set
+# CONFIG_SND_MAESTRO3 is not set
+# CONFIG_SND_MIXART is not set
+# CONFIG_SND_NM256 is not set
+# CONFIG_SND_PCXHR is not set
+# CONFIG_SND_RIPTIDE is not set
+# CONFIG_SND_RME32 is not set
+# CONFIG_SND_RME96 is not set
+# CONFIG_SND_RME9652 is not set
+# CONFIG_SND_SIS7019 is not set
+# CONFIG_SND_SONICVIBES is not set
+# CONFIG_SND_TRIDENT is not set
+# CONFIG_SND_VIA82XX is not set
+# CONFIG_SND_VIA82XX_MODEM is not set
+# CONFIG_SND_VIRTUOSO is not set
+# CONFIG_SND_VX222 is not set
+# CONFIG_SND_YMFPCI is not set
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_USX2Y is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_US122L is not set
+# CONFIG_SND_USB_6FIRE is not set
+# CONFIG_SND_SOC is not set
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=y
+# CONFIG_HID_ACRUX is not set
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+# CONFIG_HID_PRODIKEYS is not set
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DRAGONRISE=y
+# CONFIG_DRAGONRISE_FF is not set
+# CONFIG_HID_EMS_FF is not set
+CONFIG_HID_EZKEY=y
+# CONFIG_HID_KEYTOUCH is not set
+CONFIG_HID_KYE=y
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+CONFIG_HID_GYRATION=y
+CONFIG_HID_TWINHAN=y
+CONFIG_HID_KENSINGTON=y
+# CONFIG_HID_LCPOWER is not set
+CONFIG_HID_LOGITECH=y
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+# CONFIG_LOGIG940_FF is not set
+# CONFIG_LOGIWII_FF is not set
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+CONFIG_HID_ORTEK=y
+CONFIG_HID_PANTHERLORD=y
+# CONFIG_PANTHERLORD_FF is not set
+CONFIG_HID_PETALYNX=y
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_QUANTA is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_ROCCAT_ARVO is not set
+# CONFIG_HID_ROCCAT_KONE is not set
+# CONFIG_HID_ROCCAT_KONEPLUS is not set
+# CONFIG_HID_ROCCAT_KOVAPLUS is not set
+# CONFIG_HID_ROCCAT_PYRA is not set
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_HID_GREENASIA=y
+# CONFIG_GREENASIA_FF is not set
+CONFIG_HID_SMARTJOYPLUS=y
+# CONFIG_SMARTJOYPLUS_FF is not set
+CONFIG_HID_TOPSEED=y
+CONFIG_HID_THRUSTMASTER=y
+# CONFIG_THRUSTMASTER_FF is not set
+CONFIG_HID_ZEROPLUS=y
+# CONFIG_ZEROPLUS_FF is not set
+# CONFIG_HID_ZYDACRON is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+CONFIG_USB_DYNAMIC_MINORS=y
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_XHCI_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_UHCI_HCD=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_WHCI_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_UAS is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_UWB is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+# CONFIG_MMC_CLKGATE is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PCI=y
+# CONFIG_MMC_RICOH_MMC is not set
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_WBSD=y
+CONFIG_MMC_TIFM_SD=y
+CONFIG_MMC_CB710=y
+CONFIG_MMC_VIA_SDMMC=y
+CONFIG_MMC_VUB300=y
+CONFIG_MMC_USHC=y
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_NFC_DEVICES is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+# CONFIG_EDAC is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+CONFIG_RTC_DRV_CMOS=y
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_RTC_DRV_VIRTIO=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+CONFIG_STAGING=y
+# CONFIG_ET131X is not set
+# CONFIG_SLICOSS is not set
+# CONFIG_USBIP_CORE is not set
+# CONFIG_ECHO is not set
+# CONFIG_BRCMUTIL is not set
+# CONFIG_COMEDI is not set
+# CONFIG_ASUS_OLED is not set
+# CONFIG_R8187SE is not set
+# CONFIG_RTL8192U is not set
+# CONFIG_RTL8192E is not set
+# CONFIG_R8712U is not set
+# CONFIG_RTS_PSTOR is not set
+# CONFIG_TRANZPORT is not set
+# CONFIG_POHMELFS is not set
+# CONFIG_IDE_PHISON is not set
+# CONFIG_LINE6_USB is not set
+# CONFIG_DRM_VMWGFX is not set
+# CONFIG_DRM_NOUVEAU is not set
+
+#
+# I2C encoder or helper chips
+#
+# CONFIG_DRM_I2C_CH7006 is not set
+# CONFIG_DRM_I2C_SIL164 is not set
+# CONFIG_VT6655 is not set
+# CONFIG_VT6656 is not set
+# CONFIG_VME_BUS is not set
+# CONFIG_DX_SEP is not set
+# CONFIG_IIO is not set
+# CONFIG_CS5535_GPIO is not set
+# CONFIG_XVMALLOC is not set
+# CONFIG_ZRAM is not set
+# CONFIG_FB_SM7XX is not set
+# CONFIG_CRYSTALHD is not set
+# CONFIG_FB_XGI is not set
+CONFIG_MACH_NO_WESTBRIDGE=y
+# CONFIG_USB_ENESTORAGE is not set
+# CONFIG_BCM_WIMAX is not set
+# CONFIG_FT1000 is not set
+
+#
+# Speakup console speech
+#
+# CONFIG_SPEAKUP is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4 is not set
+# CONFIG_DRM_PSB is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+# CONFIG_INTEL_MEI is not set
+CONFIG_X86_PLATFORM_DEVICES=y
+# CONFIG_SENSORS_HDAPS is not set
+# CONFIG_IBM_RTL is not set
+CONFIG_CLKSRC_I8253=y
+
+#
+# Firmware Drivers
+#
+# CONFIG_EDD is not set
+CONFIG_FIRMWARE_MEMMAP=y
+# CONFIG_DELL_RBU is not set
+# CONFIG_DCDBAS is not set
+CONFIG_DMIID=y
+# CONFIG_DMI_SYSFS is not set
+# CONFIG_ISCSI_IBFT_FIND is not set
+# CONFIG_SIGMA is not set
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+CONFIG_EXT3_FS_XATTR=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_USE_FOR_EXT23=y
+CONFIG_EXT4_FS_XATTR=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD=y
+CONFIG_JBD2=y
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+# CONFIG_PROC_KCORE is not set
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+# CONFIG_NFS_FS is not set
+# CONFIG_NFSD is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_STRIP_ASM_SYMS is not set
+CONFIG_UNUSED_SYMBOLS=y
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_MEMORY_INIT=y
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+CONFIG_FRAME_POINTER=y
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+CONFIG_USER_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_FP_TEST=y
+CONFIG_HAVE_FUNCTION_TRACE_MCOUNT_TEST=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_PROVIDE_OHCI1394_DMA_INIT is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_HAVE_ARCH_KMEMCHECK=y
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
+CONFIG_X86_VERBOSE_BOOTUP=y
+CONFIG_EARLY_PRINTK=y
+# CONFIG_EARLY_PRINTK_DBGP is not set
+# CONFIG_DEBUG_SET_MODULE_RONX is not set
+CONFIG_DOUBLEFAULT=y
+# CONFIG_IOMMU_STRESS is not set
+CONFIG_HAVE_MMIOTRACE_SUPPORT=y
+CONFIG_IO_DELAY_TYPE_0X80=0
+CONFIG_IO_DELAY_TYPE_0XED=1
+CONFIG_IO_DELAY_TYPE_UDELAY=2
+CONFIG_IO_DELAY_TYPE_NONE=3
+CONFIG_IO_DELAY_0X80=y
+# CONFIG_IO_DELAY_0XED is not set
+# CONFIG_IO_DELAY_UDELAY is not set
+# CONFIG_IO_DELAY_NONE is not set
+CONFIG_DEFAULT_IO_DELAY_TYPE=0
+# CONFIG_OPTIMIZE_INLINING is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+# CONFIG_KEYS_DEBUG_PROC_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=m
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=m
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=m
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=m
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=m
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=m
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=m
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_CRC32C_INTEL is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=m
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=m
+# CONFIG_CRYPTO_AES_586 is not set
+# CONFIG_CRYPTO_AES_NI_INTEL is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=m
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SALSA20_586 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_TWOFISH_586 is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=m
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=m
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_PADLOCK is not set
+# CONFIG_CRYPTO_DEV_GEODE is not set
+# CONFIG_CRYPTO_DEV_HIFN_795X is not set
+CONFIG_HAVE_KVM=y
+CONFIG_VIRTUALIZATION=y
+# CONFIG_KVM is not set
+# CONFIG_VHOST_NET is not set
+# CONFIG_LGUEST is not set
+CONFIG_VIRTIO=y
+# CONFIG_VIRTIO_PCI is not set
+# CONFIG_VIRTIO_BALLOON is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_FIRST_BIT=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
+CONFIG_CRC_T10DIF=y
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=m
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_DECOMPRESS_LZO=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=y
+CONFIG_TEXTSEARCH_BM=m
+CONFIG_TEXTSEARCH_FSM=m
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_CHECK_SIGNATURE=y
+CONFIG_NLATTR=y
+# CONFIG_AVERAGE is not set
diff -Nur linux-3.0.34/arch/x86/configs/xtratum_defconfig linux-3.0.34-xm/arch/x86/configs/xtratum_defconfig
--- linux-3.0.34/arch/x86/configs/xtratum_defconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.0.34-xm/arch/x86/configs/xtratum_defconfig	2013-01-13 23:14:56.000000000 +0100
@@ -0,0 +1,2973 @@
+#
+# Automatically generated make config: don't edit
+# Linux/x86 3.0.17 Kernel Configuration
+#
+# CONFIG_64BIT is not set
+CONFIG_X86_32=y
+# CONFIG_X86_64 is not set
+CONFIG_X86=y
+CONFIG_INSTRUCTION_DECODER=y
+CONFIG_OUTPUT_FORMAT="elf32-i386"
+CONFIG_ARCH_DEFCONFIG="arch/x86/configs/i386_defconfig"
+CONFIG_GENERIC_CMOS_UPDATE=y
+CONFIG_CLOCKSOURCE_WATCHDOG=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_MMU=y
+CONFIG_ZONE_DMA=y
+# CONFIG_NEED_DMA_MAP_STATE is not set
+CONFIG_NEED_SG_DMA_LENGTH=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+# CONFIG_RWSEM_GENERIC_SPINLOCK is not set
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+# CONFIG_GENERIC_TIME_VSYSCALL is not set
+CONFIG_ARCH_HAS_CPU_RELAX=y
+CONFIG_ARCH_HAS_DEFAULT_IDLE=y
+CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
+CONFIG_HAVE_SETUP_PER_CPU_AREA=y
+CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK=y
+CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK=y
+# CONFIG_HAVE_CPUMASK_OF_CPU_MAP is not set
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+# CONFIG_ZONE_DMA32 is not set
+CONFIG_ARCH_POPULATES_NODE_MAP=y
+# CONFIG_AUDIT_ARCH is not set
+CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_X86_32_LAZY_GS=y
+CONFIG_ARCH_HWEIGHT_CFLAGS="-fcall-saved-ecx -fcall-saved-edx"
+CONFIG_KTIME_SCALAR=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_HAVE_IRQ_WORK=y
+CONFIG_IRQ_WORK=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_BZIP2=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+# CONFIG_FHANDLE is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_HAVE_SPARSE_IRQ=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_IRQ_FORCED_THREADING=y
+# CONFIG_SPARSE_IRQ is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TINY_RCU=y
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_RCU_TRACE is not set
+# CONFIG_TREE_RCU_TRACE is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_HAVE_UNSTABLE_SCHED_CLOCK=y
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+# CONFIG_CGROUP_FREEZER is not set
+# CONFIG_CGROUP_DEVICE is not set
+# CONFIG_CPUSETS is not set
+# CONFIG_CGROUP_CPUACCT is not set
+# CONFIG_RESOURCE_COUNTERS is not set
+# CONFIG_CGROUP_PERF is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_RT_GROUP_SCHED is not set
+# CONFIG_BLK_CGROUP is not set
+CONFIG_NAMESPACES=y
+# CONFIG_UTS_NS is not set
+CONFIG_IPC_NS=y
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+# CONFIG_NET_NS is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_RD_XZ=y
+CONFIG_RD_LZO=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+# CONFIG_EXPERT is not set
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_PCSPKR_PLATFORM=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_PERF_COUNTERS is not set
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_PCI_QUIRKS=y
+CONFIG_SLUB_DEBUG=y
+# CONFIG_COMPAT_BRK is not set
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_PROFILING is not set
+CONFIG_TRACEPOINTS=y
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+# CONFIG_JUMP_LABEL is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_HAVE_IOREMAP_PROT=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_OPTPROBES=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_MIXED_BREAKPOINTS_REGS=y
+CONFIG_HAVE_USER_RETURN_NOTIFIER=y
+CONFIG_HAVE_PERF_EVENTS_NMI=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+CONFIG_BLK_DEV_BSG=y
+CONFIG_BLK_DEV_INTEGRITY=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+CONFIG_INLINE_SPIN_UNLOCK=y
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+CONFIG_INLINE_READ_UNLOCK=y
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+CONFIG_INLINE_WRITE_UNLOCK=y
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+# CONFIG_MUTEX_SPIN_ON_OWNER is not set
+CONFIG_FREEZER=y
+
+#
+# Processor type and features
+#
+# CONFIG_NO_HZ is not set
+# CONFIG_HIGH_RES_TIMERS is not set
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+# CONFIG_SMP is not set
+# CONFIG_X86_EXTENDED_PLATFORM is not set
+# CONFIG_X86_32_IRIS is not set
+# CONFIG_SCHED_OMIT_FRAME_POINTER is not set
+CONFIG_PARAVIRT_GUEST=y
+# CONFIG_XEN_PRIVILEGED_GUEST is not set
+# CONFIG_KVM_CLOCK is not set
+# CONFIG_KVM_GUEST is not set
+# CONFIG_LGUEST_GUEST is not set
+CONFIG_XM_PARTITION=y
+#CONFIG_XM_BOOTCONSOLE is not set
+#CONFIG_XM_DEBUGCONSOLE is not set
+CONFIG_XM_VIRTSRV=y
+CONFIG_XM_SPARE_MANAGER=y
+CONFIG_XMIO_SERVER=y
+CONFIG_XMIO_CLIENT=y
+CONFIG_XMIO_SCAN_PERIOD=100
+# CONFIG_XMIO_SSE2_MEMCPY is not set
+CONFIG_PARAVIRT=y
+# CONFIG_PARAVIRT_DEBUG is not set
+CONFIG_NO_BOOTMEM=y
+# CONFIG_MEMTEST is not set
+# CONFIG_M386 is not set
+# CONFIG_M486 is not set
+# CONFIG_M586 is not set
+# CONFIG_M586TSC is not set
+# CONFIG_M586MMX is not set
+CONFIG_M686=y
+# CONFIG_MPENTIUMII is not set
+# CONFIG_MPENTIUMIII is not set
+# CONFIG_MPENTIUMM is not set
+# CONFIG_MPENTIUM4 is not set
+# CONFIG_MK6 is not set
+# CONFIG_MK7 is not set
+# CONFIG_MK8 is not set
+# CONFIG_MCRUSOE is not set
+# CONFIG_MEFFICEON is not set
+# CONFIG_MWINCHIPC6 is not set
+# CONFIG_MWINCHIP3D is not set
+# CONFIG_MELAN is not set
+# CONFIG_MGEODEGX1 is not set
+# CONFIG_MGEODE_LX is not set
+# CONFIG_MCYRIXIII is not set
+# CONFIG_MVIAC3_2 is not set
+# CONFIG_MVIAC7 is not set
+# CONFIG_MCORE2 is not set
+# CONFIG_MATOM is not set
+# CONFIG_X86_GENERIC is not set
+CONFIG_X86_INTERNODE_CACHE_SHIFT=5
+CONFIG_X86_CMPXCHG=y
+CONFIG_CMPXCHG_LOCAL=y
+CONFIG_X86_L1_CACHE_SHIFT=5
+CONFIG_X86_XADD=y
+# CONFIG_X86_PPRO_FENCE is not set
+CONFIG_X86_WP_WORKS_OK=y
+CONFIG_X86_INVLPG=y
+CONFIG_X86_BSWAP=y
+CONFIG_X86_POPAD_OK=y
+CONFIG_X86_USE_PPRO_CHECKSUM=y
+CONFIG_X86_TSC=y
+CONFIG_X86_CMPXCHG64=y
+CONFIG_X86_CMOV=y
+CONFIG_X86_MINIMUM_CPU_FAMILY=5
+CONFIG_X86_DEBUGCTLMSR=y
+CONFIG_CPU_SUP_INTEL=y
+CONFIG_CPU_SUP_CYRIX_32=y
+CONFIG_CPU_SUP_AMD=y
+CONFIG_CPU_SUP_CENTAUR=y
+CONFIG_CPU_SUP_TRANSMETA_32=y
+CONFIG_CPU_SUP_UMC_32=y
+# CONFIG_HPET_TIMER is not set
+CONFIG_DMI=y
+# CONFIG_IOMMU_HELPER is not set
+# CONFIG_IOMMU_API is not set
+CONFIG_NR_CPUS=1
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_X86_UP_APIC is not set
+# CONFIG_X86_MCE is not set
+CONFIG_VM86=y
+# CONFIG_TOSHIBA is not set
+# CONFIG_I8K is not set
+# CONFIG_X86_REBOOTFIXUPS is not set
+# CONFIG_MICROCODE is not set
+# CONFIG_X86_MSR is not set
+# CONFIG_X86_CPUID is not set
+CONFIG_NOHIGHMEM=y
+# CONFIG_HIGHMEM4G is not set
+# CONFIG_HIGHMEM64G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_X86_PAE is not set
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+# CONFIG_ARCH_DMA_ADDR_T_64BIT is not set
+CONFIG_NEED_NODE_MEMMAP_SIZE=y
+CONFIG_ARCH_FLATMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ILLEGAL_POINTER_VALUE=0
+CONFIG_SELECT_MEMORY_MODEL=y
+# CONFIG_FLATMEM_MANUAL is not set
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_SPARSEMEM=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_SPARSEMEM_STATIC=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_COMPACTION is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_TRANSPARENT_HUGEPAGE is not set
+CONFIG_NEED_PER_CPU_KM=y
+# CONFIG_CLEANCACHE is not set
+# CONFIG_X86_CHECK_BIOS_CORRUPTION is not set
+CONFIG_X86_RESERVE_LOW=64
+# CONFIG_MATH_EMULATION is not set
+CONFIG_MTRR=y
+CONFIG_MTRR_SANITIZER=y
+CONFIG_MTRR_SANITIZER_ENABLE_DEFAULT=0
+CONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT=1
+CONFIG_X86_PAT=y
+CONFIG_ARCH_USES_PG_UNCACHED=y
+# CONFIG_SECCOMP is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+# CONFIG_SCHED_HRTICK is not set
+# CONFIG_KEXEC is not set
+CONFIG_PHYSICAL_START=0x1000000
+CONFIG_RELOCATABLE=y
+CONFIG_X86_NEED_RELOCS=y
+CONFIG_PHYSICAL_ALIGN=0x200000
+# CONFIG_COMPAT_VDSO is not set
+# CONFIG_CMDLINE_BOOL is not set
+
+#
+# Power management and ACPI options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_HIBERNATION is not set
+CONFIG_PM_SLEEP=y
+# CONFIG_PM_RUNTIME is not set
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_ACPI is not set
+# CONFIG_SFI is not set
+# CONFIG_APM is not set
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+# CONFIG_CPU_IDLE is not set
+
+#
+# Bus options (PCI etc.)
+#
+CONFIG_PCI=y
+# CONFIG_PCI_GOBIOS is not set
+# CONFIG_PCI_GOMMCONFIG is not set
+CONFIG_PCI_GODIRECT=y
+# CONFIG_PCI_GOANY is not set
+CONFIG_PCI_DIRECT=y
+CONFIG_PCI_DOMAINS=y
+# CONFIG_PCI_CNB20LE_QUIRK is not set
+# CONFIG_PCIEPORTBUS is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCI_DEBUG is not set
+# CONFIG_PCI_STUB is not set
+# CONFIG_PCI_IOV is not set
+CONFIG_PCI_LABEL=y
+CONFIG_ISA_DMA_API=y
+CONFIG_ISA=y
+CONFIG_EISA=y
+# CONFIG_EISA_VLB_PRIMING is not set
+CONFIG_EISA_PCI_EISA=y
+CONFIG_EISA_VIRTUAL_ROOT=y
+CONFIG_EISA_NAMES=y
+# CONFIG_MCA is not set
+# CONFIG_SCx200 is not set
+# CONFIG_OLPC is not set
+CONFIG_AMD_NB=y
+# CONFIG_PCCARD is not set
+# CONFIG_HOTPLUG_PCI is not set
+# CONFIG_RAPIDIO is not set
+
+#
+# Executable file formats / Emulations
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+CONFIG_HAVE_ATOMIC_IOMAP=y
+CONFIG_HAVE_TEXT_POKE_SMP=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_XFRM_IPCOMP=m
+CONFIG_NET_KEY=m
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+# CONFIG_IP_FIB_TRIE_STATS is not set
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_ROUTE_CLASSID=y
+# CONFIG_IP_PNP is not set
+CONFIG_NET_IPIP=m
+# CONFIG_NET_IPGRE_DEMUX is not set
+CONFIG_IP_MROUTE=y
+# CONFIG_IP_MROUTE_MULTIPLE_TABLES is not set
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+CONFIG_INET_AH=m
+CONFIG_INET_ESP=m
+CONFIG_INET_IPCOMP=m
+CONFIG_INET_XFRM_TUNNEL=m
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_XFRM_MODE_TRANSPORT=m
+CONFIG_INET_XFRM_MODE_TUNNEL=m
+CONFIG_INET_XFRM_MODE_BEET=m
+CONFIG_INET_LRO=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+CONFIG_TCP_CONG_ADVANCED=y
+CONFIG_TCP_CONG_BIC=m
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_TCP_CONG_WESTWOOD=m
+CONFIG_TCP_CONG_HTCP=m
+CONFIG_TCP_CONG_HSTCP=m
+CONFIG_TCP_CONG_HYBLA=m
+CONFIG_TCP_CONG_VEGAS=m
+CONFIG_TCP_CONG_SCALABLE=m
+CONFIG_TCP_CONG_LP=m
+CONFIG_TCP_CONG_VENO=m
+CONFIG_TCP_CONG_YEAH=m
+CONFIG_TCP_CONG_ILLINOIS=m
+CONFIG_DEFAULT_CUBIC=y
+# CONFIG_DEFAULT_RENO is not set
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_TCP_MD5SIG=y
+# CONFIG_IPV6 is not set
+CONFIG_NETWORK_SECMARK=y
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=m
+CONFIG_NETFILTER_NETLINK_QUEUE=m
+CONFIG_NETFILTER_NETLINK_LOG=m
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_NF_CONNTRACK_SECMARK=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
+# CONFIG_NF_CT_PROTO_DCCP is not set
+CONFIG_NF_CT_PROTO_GRE=m
+CONFIG_NF_CT_PROTO_SCTP=m
+CONFIG_NF_CT_PROTO_UDPLITE=m
+CONFIG_NF_CONNTRACK_AMANDA=m
+CONFIG_NF_CONNTRACK_FTP=m
+CONFIG_NF_CONNTRACK_H323=m
+CONFIG_NF_CONNTRACK_IRC=m
+CONFIG_NF_CONNTRACK_BROADCAST=m
+CONFIG_NF_CONNTRACK_NETBIOS_NS=m
+# CONFIG_NF_CONNTRACK_SNMP is not set
+CONFIG_NF_CONNTRACK_PPTP=m
+# CONFIG_NF_CONNTRACK_SANE is not set
+CONFIG_NF_CONNTRACK_SIP=m
+CONFIG_NF_CONNTRACK_TFTP=m
+CONFIG_NF_CT_NETLINK=m
+CONFIG_NETFILTER_TPROXY=m
+CONFIG_NETFILTER_XTABLES=m
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=m
+CONFIG_NETFILTER_XT_CONNMARK=m
+
+#
+# Xtables targets
+#
+# CONFIG_NETFILTER_XT_TARGET_CHECKSUM is not set
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=m
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=m
+CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=m
+# CONFIG_NETFILTER_XT_TARGET_CT is not set
+CONFIG_NETFILTER_XT_TARGET_DSCP=m
+CONFIG_NETFILTER_XT_TARGET_HL=m
+# CONFIG_NETFILTER_XT_TARGET_IDLETIMER is not set
+CONFIG_NETFILTER_XT_TARGET_MARK=m
+CONFIG_NETFILTER_XT_TARGET_NFLOG=m
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=m
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=m
+CONFIG_NETFILTER_XT_TARGET_RATEEST=m
+# CONFIG_NETFILTER_XT_TARGET_TEE is not set
+CONFIG_NETFILTER_XT_TARGET_TPROXY=m
+CONFIG_NETFILTER_XT_TARGET_TRACE=m
+CONFIG_NETFILTER_XT_TARGET_SECMARK=m
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=m
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+
+#
+# Xtables matches
+#
+# CONFIG_NETFILTER_XT_MATCH_ADDRTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=m
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+CONFIG_NETFILTER_XT_MATCH_DCCP=m
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+CONFIG_NETFILTER_XT_MATCH_DSCP=m
+CONFIG_NETFILTER_XT_MATCH_ESP=m
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_HELPER=m
+CONFIG_NETFILTER_XT_MATCH_HL=m
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=m
+# CONFIG_NETFILTER_XT_MATCH_IPVS is not set
+CONFIG_NETFILTER_XT_MATCH_LENGTH=m
+CONFIG_NETFILTER_XT_MATCH_LIMIT=m
+CONFIG_NETFILTER_XT_MATCH_MAC=m
+CONFIG_NETFILTER_XT_MATCH_MARK=m
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
+# CONFIG_NETFILTER_XT_MATCH_OSF is not set
+CONFIG_NETFILTER_XT_MATCH_OWNER=m
+CONFIG_NETFILTER_XT_MATCH_POLICY=m
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=m
+CONFIG_NETFILTER_XT_MATCH_QUOTA=m
+CONFIG_NETFILTER_XT_MATCH_RATEEST=m
+CONFIG_NETFILTER_XT_MATCH_REALM=m
+CONFIG_NETFILTER_XT_MATCH_RECENT=m
+CONFIG_NETFILTER_XT_MATCH_SCTP=m
+CONFIG_NETFILTER_XT_MATCH_SOCKET=m
+CONFIG_NETFILTER_XT_MATCH_STATE=m
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
+CONFIG_NETFILTER_XT_MATCH_STRING=m
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=m
+CONFIG_NETFILTER_XT_MATCH_TIME=m
+CONFIG_NETFILTER_XT_MATCH_U32=m
+# CONFIG_IP_SET is not set
+CONFIG_IP_VS=m
+# CONFIG_IP_VS_DEBUG is not set
+CONFIG_IP_VS_TAB_BITS=12
+
+#
+# IPVS transport protocol load balancing support
+#
+CONFIG_IP_VS_PROTO_TCP=y
+CONFIG_IP_VS_PROTO_UDP=y
+CONFIG_IP_VS_PROTO_AH_ESP=y
+CONFIG_IP_VS_PROTO_ESP=y
+CONFIG_IP_VS_PROTO_AH=y
+# CONFIG_IP_VS_PROTO_SCTP is not set
+
+#
+# IPVS scheduler
+#
+CONFIG_IP_VS_RR=m
+CONFIG_IP_VS_WRR=m
+CONFIG_IP_VS_LC=m
+CONFIG_IP_VS_WLC=m
+CONFIG_IP_VS_LBLC=m
+CONFIG_IP_VS_LBLCR=m
+CONFIG_IP_VS_DH=m
+CONFIG_IP_VS_SH=m
+CONFIG_IP_VS_SED=m
+CONFIG_IP_VS_NQ=m
+
+#
+# IPVS application helper
+#
+CONFIG_IP_VS_FTP=m
+CONFIG_IP_VS_NFCT=y
+# CONFIG_IP_VS_PE_SIP is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=m
+CONFIG_NF_CONNTRACK_IPV4=m
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+CONFIG_IP_NF_QUEUE=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_MATCH_AH=m
+CONFIG_IP_NF_MATCH_ECN=m
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_TARGET_LOG=m
+CONFIG_IP_NF_TARGET_ULOG=m
+CONFIG_NF_NAT=m
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_NETMAP=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_NF_NAT_PROTO_GRE=m
+CONFIG_NF_NAT_PROTO_UDPLITE=m
+CONFIG_NF_NAT_PROTO_SCTP=m
+CONFIG_NF_NAT_FTP=m
+CONFIG_NF_NAT_IRC=m
+CONFIG_NF_NAT_TFTP=m
+CONFIG_NF_NAT_AMANDA=m
+CONFIG_NF_NAT_PPTP=m
+CONFIG_NF_NAT_H323=m
+CONFIG_NF_NAT_SIP=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_TARGET_CLUSTERIP=m
+CONFIG_IP_NF_TARGET_ECN=m
+CONFIG_IP_NF_TARGET_TTL=m
+CONFIG_IP_NF_RAW=m
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_IP_NF_ARP_MANGLE=m
+# CONFIG_IP_DCCP is not set
+CONFIG_IP_SCTP=m
+# CONFIG_SCTP_DBG_MSG is not set
+# CONFIG_SCTP_DBG_OBJCNT is not set
+# CONFIG_SCTP_HMAC_NONE is not set
+# CONFIG_SCTP_HMAC_SHA1 is not set
+CONFIG_SCTP_HMAC_MD5=y
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+# CONFIG_DNS_RESOLVER is not set
+# CONFIG_BATMAN_ADV is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_DROP_MONITOR is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_AF_RXRPC=m
+# CONFIG_AF_RXRPC_DEBUG is not set
+# CONFIG_RXKAD is not set
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+# CONFIG_LIB80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH=""
+# CONFIG_DEVTMPFS is not set
+# CONFIG_STANDALONE is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+# CONFIG_MTD is not set
+# CONFIG_PARPORT is not set
+# CONFIG_PNP is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_DEV_XD is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=65536
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_VIRTIO_BLK=y
+# CONFIG_BLK_DEV_HD is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_MISC_DEVICES is not set
+CONFIG_HAVE_IDE=y
+CONFIG_IDE=y
+
+#
+# Please see Documentation/ide/ide.txt for help/info on IDE drives
+#
+CONFIG_IDE_XFER_MODE=y
+CONFIG_IDE_ATAPI=y
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_IDE_GD=y
+CONFIG_IDE_GD_ATA=y
+# CONFIG_IDE_GD_ATAPI is not set
+CONFIG_BLK_DEV_IDECD=y
+CONFIG_BLK_DEV_IDECD_VERBOSE_ERRORS=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+CONFIG_IDE_PROC_FS=y
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+CONFIG_BLK_DEV_PLATFORM=y
+# CONFIG_BLK_DEV_CMD640 is not set
+CONFIG_BLK_DEV_IDEDMA_SFF=y
+
+#
+# PCI IDE chipsets support
+#
+CONFIG_BLK_DEV_IDEPCI=y
+CONFIG_IDEPCI_PCIBUS_ORDER=y
+# CONFIG_BLK_DEV_OFFBOARD is not set
+CONFIG_BLK_DEV_GENERIC=y
+# CONFIG_BLK_DEV_OPTI621 is not set
+# CONFIG_BLK_DEV_RZ1000 is not set
+CONFIG_BLK_DEV_IDEDMA_PCI=y
+# CONFIG_BLK_DEV_AEC62XX is not set
+# CONFIG_BLK_DEV_ALI15X3 is not set
+# CONFIG_BLK_DEV_AMD74XX is not set
+# CONFIG_BLK_DEV_ATIIXP is not set
+# CONFIG_BLK_DEV_CMD64X is not set
+# CONFIG_BLK_DEV_TRIFLEX is not set
+# CONFIG_BLK_DEV_CS5520 is not set
+# CONFIG_BLK_DEV_CS5530 is not set
+# CONFIG_BLK_DEV_CS5535 is not set
+# CONFIG_BLK_DEV_CS5536 is not set
+# CONFIG_BLK_DEV_HPT366 is not set
+# CONFIG_BLK_DEV_JMICRON is not set
+# CONFIG_BLK_DEV_SC1200 is not set
+CONFIG_BLK_DEV_PIIX=y
+# CONFIG_BLK_DEV_IT8172 is not set
+# CONFIG_BLK_DEV_IT8213 is not set
+# CONFIG_BLK_DEV_IT821X is not set
+# CONFIG_BLK_DEV_NS87415 is not set
+# CONFIG_BLK_DEV_PDC202XX_OLD is not set
+# CONFIG_BLK_DEV_PDC202XX_NEW is not set
+# CONFIG_BLK_DEV_SVWKS is not set
+# CONFIG_BLK_DEV_SIIMAGE is not set
+# CONFIG_BLK_DEV_SIS5513 is not set
+# CONFIG_BLK_DEV_SLC90E66 is not set
+# CONFIG_BLK_DEV_TRM290 is not set
+# CONFIG_BLK_DEV_VIA82CXXX is not set
+# CONFIG_BLK_DEV_TC86C001 is not set
+
+#
+# Other IDE chipsets support
+#
+
+#
+# Note: most of these also require special kernel boot parameters
+#
+# CONFIG_BLK_DEV_4DRIVES is not set
+# CONFIG_BLK_DEV_ALI14XX is not set
+# CONFIG_BLK_DEV_DTC2278 is not set
+# CONFIG_BLK_DEV_HT6560B is not set
+# CONFIG_BLK_DEV_QD65XX is not set
+# CONFIG_BLK_DEV_UMC8672 is not set
+CONFIG_BLK_DEV_IDEDMA=y
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+CONFIG_RAID_ATTRS=m
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+CONFIG_SCSI_TGT=m
+CONFIG_SCSI_NETLINK=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_ST=m
+CONFIG_CHR_DEV_OSST=m
+CONFIG_BLK_DEV_SR=y
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_CHR_DEV_SG=y
+CONFIG_CHR_DEV_SCH=m
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+CONFIG_SCSI_SCAN_ASYNC=y
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+CONFIG_SCSI_SPI_ATTRS=y
+CONFIG_SCSI_FC_ATTRS=m
+CONFIG_SCSI_FC_TGT_ATTRS=y
+CONFIG_SCSI_ISCSI_ATTRS=m
+CONFIG_SCSI_SAS_ATTRS=m
+CONFIG_SCSI_SAS_LIBSAS=m
+# CONFIG_SCSI_SAS_ATA is not set
+CONFIG_SCSI_SAS_HOST_SMP=y
+CONFIG_SCSI_SRP_ATTRS=m
+CONFIG_SCSI_SRP_TGT_ATTRS=y
+CONFIG_SCSI_LOWLEVEL=y
+CONFIG_ISCSI_TCP=m
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_SCSI_CXGB3_ISCSI is not set
+# CONFIG_SCSI_CXGB4_ISCSI is not set
+# CONFIG_SCSI_BNX2_ISCSI is not set
+# CONFIG_SCSI_BNX2X_FCOE is not set
+# CONFIG_BE2ISCSI is not set
+CONFIG_BLK_DEV_3W_XXXX_RAID=m
+# CONFIG_SCSI_HPSA is not set
+CONFIG_SCSI_3W_9XXX=m
+# CONFIG_SCSI_3W_SAS is not set
+# CONFIG_SCSI_7000FASST is not set
+CONFIG_SCSI_ACARD=m
+# CONFIG_SCSI_AHA152X is not set
+# CONFIG_SCSI_AHA1542 is not set
+# CONFIG_SCSI_AHA1740 is not set
+CONFIG_SCSI_AACRAID=m
+CONFIG_SCSI_AIC7XXX=m
+CONFIG_AIC7XXX_CMDS_PER_DEVICE=8
+CONFIG_AIC7XXX_RESET_DELAY_MS=15000
+CONFIG_AIC7XXX_DEBUG_ENABLE=y
+CONFIG_AIC7XXX_DEBUG_MASK=0
+CONFIG_AIC7XXX_REG_PRETTY_PRINT=y
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+CONFIG_SCSI_AIC79XX=m
+CONFIG_AIC79XX_CMDS_PER_DEVICE=32
+CONFIG_AIC79XX_RESET_DELAY_MS=5000
+CONFIG_AIC79XX_DEBUG_ENABLE=y
+CONFIG_AIC79XX_DEBUG_MASK=0
+CONFIG_AIC79XX_REG_PRETTY_PRINT=y
+CONFIG_SCSI_AIC94XX=m
+# CONFIG_AIC94XX_DEBUG is not set
+CONFIG_SCSI_MVSAS=m
+CONFIG_SCSI_MVSAS_DEBUG=y
+CONFIG_SCSI_DPT_I2O=m
+CONFIG_SCSI_ADVANSYS=m
+# CONFIG_SCSI_IN2000 is not set
+CONFIG_SCSI_ARCMSR=m
+CONFIG_MEGARAID_NEWGEN=y
+CONFIG_MEGARAID_MM=m
+CONFIG_MEGARAID_MAILBOX=m
+CONFIG_MEGARAID_LEGACY=m
+CONFIG_MEGARAID_SAS=m
+# CONFIG_SCSI_MPT2SAS is not set
+CONFIG_SCSI_HPTIOP=m
+CONFIG_SCSI_BUSLOGIC=m
+# CONFIG_SCSI_FLASHPOINT is not set
+# CONFIG_VMWARE_PVSCSI is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_FCOE is not set
+# CONFIG_FCOE_FNIC is not set
+CONFIG_SCSI_DMX3191D=m
+# CONFIG_SCSI_DTC3280 is not set
+CONFIG_SCSI_EATA=m
+CONFIG_SCSI_EATA_TAGGED_QUEUE=y
+CONFIG_SCSI_EATA_LINKED_COMMANDS=y
+CONFIG_SCSI_EATA_MAX_TAGS=16
+CONFIG_SCSI_FUTURE_DOMAIN=m
+CONFIG_SCSI_GDTH=m
+# CONFIG_SCSI_ISCI is not set
+# CONFIG_SCSI_GENERIC_NCR5380 is not set
+# CONFIG_SCSI_GENERIC_NCR5380_MMIO is not set
+CONFIG_SCSI_IPS=m
+CONFIG_SCSI_INITIO=m
+CONFIG_SCSI_INIA100=m
+# CONFIG_SCSI_NCR53C406A is not set
+CONFIG_SCSI_STEX=m
+CONFIG_SCSI_SYM53C8XX_2=m
+CONFIG_SCSI_SYM53C8XX_DMA_ADDRESSING_MODE=1
+CONFIG_SCSI_SYM53C8XX_DEFAULT_TAGS=16
+CONFIG_SCSI_SYM53C8XX_MAX_TAGS=64
+CONFIG_SCSI_SYM53C8XX_MMIO=y
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_PAS16 is not set
+# CONFIG_SCSI_QLOGIC_FAS is not set
+CONFIG_SCSI_QLOGIC_1280=m
+CONFIG_SCSI_QLA_FC=m
+CONFIG_SCSI_QLA_ISCSI=m
+CONFIG_SCSI_LPFC=m
+# CONFIG_SCSI_LPFC_DEBUG_FS is not set
+# CONFIG_SCSI_SIM710 is not set
+# CONFIG_SCSI_SYM53C416 is not set
+CONFIG_SCSI_DC395x=m
+CONFIG_SCSI_DC390T=m
+# CONFIG_SCSI_T128 is not set
+# CONFIG_SCSI_U14_34F is not set
+# CONFIG_SCSI_ULTRASTOR is not set
+# CONFIG_SCSI_NSP32 is not set
+CONFIG_SCSI_DEBUG=m
+# CONFIG_SCSI_PMCRAID is not set
+# CONFIG_SCSI_PM8001 is not set
+CONFIG_SCSI_SRP=m
+# CONFIG_SCSI_BFA_FC is not set
+CONFIG_SCSI_DH=y
+CONFIG_SCSI_DH_RDAC=m
+CONFIG_SCSI_DH_HP_SW=m
+CONFIG_SCSI_DH_EMC=m
+CONFIG_SCSI_DH_ALUA=m
+# CONFIG_SCSI_OSD_INITIATOR is not set
+CONFIG_ATA=y
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_SATA_PMP=y
+
+#
+# Controllers with non-SFF native interface
+#
+# CONFIG_SATA_AHCI is not set
+# CONFIG_SATA_AHCI_PLATFORM is not set
+# CONFIG_SATA_INIC162X is not set
+# CONFIG_SATA_ACARD_AHCI is not set
+# CONFIG_SATA_SIL24 is not set
+CONFIG_ATA_SFF=y
+
+#
+# SFF controllers with custom DMA interface
+#
+# CONFIG_PDC_ADMA is not set
+# CONFIG_SATA_QSTOR is not set
+# CONFIG_SATA_SX4 is not set
+CONFIG_ATA_BMDMA=y
+
+#
+# SATA SFF controllers with BMDMA
+#
+# CONFIG_ATA_PIIX is not set
+# CONFIG_SATA_MV is not set
+# CONFIG_SATA_NV is not set
+# CONFIG_SATA_PROMISE is not set
+# CONFIG_SATA_SIL is not set
+# CONFIG_SATA_SIS is not set
+# CONFIG_SATA_SVW is not set
+# CONFIG_SATA_ULI is not set
+# CONFIG_SATA_VIA is not set
+# CONFIG_SATA_VITESSE is not set
+
+#
+# PATA SFF controllers with BMDMA
+#
+# CONFIG_PATA_ALI is not set
+# CONFIG_PATA_AMD is not set
+# CONFIG_PATA_ARASAN_CF is not set
+# CONFIG_PATA_ARTOP is not set
+# CONFIG_PATA_ATIIXP is not set
+# CONFIG_PATA_ATP867X is not set
+# CONFIG_PATA_CMD64X is not set
+# CONFIG_PATA_CS5520 is not set
+# CONFIG_PATA_CS5530 is not set
+# CONFIG_PATA_CS5535 is not set
+# CONFIG_PATA_CS5536 is not set
+# CONFIG_PATA_CYPRESS is not set
+# CONFIG_PATA_EFAR is not set
+# CONFIG_PATA_HPT366 is not set
+# CONFIG_PATA_HPT37X is not set
+# CONFIG_PATA_HPT3X2N is not set
+# CONFIG_PATA_HPT3X3 is not set
+# CONFIG_PATA_IT8213 is not set
+# CONFIG_PATA_IT821X is not set
+# CONFIG_PATA_JMICRON is not set
+# CONFIG_PATA_MARVELL is not set
+# CONFIG_PATA_NETCELL is not set
+# CONFIG_PATA_NINJA32 is not set
+# CONFIG_PATA_NS87415 is not set
+# CONFIG_PATA_OLDPIIX is not set
+# CONFIG_PATA_OPTIDMA is not set
+# CONFIG_PATA_PDC2027X is not set
+# CONFIG_PATA_PDC_OLD is not set
+# CONFIG_PATA_RADISYS is not set
+# CONFIG_PATA_RDC is not set
+# CONFIG_PATA_SC1200 is not set
+CONFIG_PATA_SCH=y
+# CONFIG_PATA_SERVERWORKS is not set
+# CONFIG_PATA_SIL680 is not set
+# CONFIG_PATA_SIS is not set
+# CONFIG_PATA_TOSHIBA is not set
+# CONFIG_PATA_TRIFLEX is not set
+# CONFIG_PATA_VIA is not set
+# CONFIG_PATA_WINBOND is not set
+
+#
+# PIO-only SFF controllers
+#
+# CONFIG_PATA_CMD640_PCI is not set
+# CONFIG_PATA_MPIIX is not set
+# CONFIG_PATA_NS87410 is not set
+# CONFIG_PATA_OPTI is not set
+# CONFIG_PATA_QDI is not set
+# CONFIG_PATA_RZ1000 is not set
+# CONFIG_PATA_WINBOND_VLB is not set
+
+#
+# Generic fallback / legacy drivers
+#
+# CONFIG_ATA_GENERIC is not set
+# CONFIG_PATA_LEGACY is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_FUSION=y
+CONFIG_FUSION_SPI=y
+# CONFIG_FUSION_FC is not set
+# CONFIG_FUSION_SAS is not set
+CONFIG_FUSION_MAX_SGE=128
+# CONFIG_FUSION_CTL is not set
+# CONFIG_FUSION_LOGGING is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_FIREWIRE_NOSY is not set
+# CONFIG_I2O is not set
+# CONFIG_MACINTOSH_DRIVERS is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_ARCNET is not set
+CONFIG_MII=y
+# CONFIG_PHYLIB is not set
+CONFIG_NET_ETHERNET=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_LANCE is not set
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_ETHOC is not set
+# CONFIG_NET_VENDOR_RACAL is not set
+# CONFIG_DNET is not set
+# CONFIG_NET_TULIP is not set
+# CONFIG_AT1700 is not set
+# CONFIG_DEPCA is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_ISA is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+CONFIG_NET_PCI=y
+CONFIG_PCNET32=y
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_AC3200 is not set
+# CONFIG_KSZ884X_PCI is not set
+# CONFIG_APRICOT is not set
+# CONFIG_B44 is not set
+# CONFIG_FORCEDETH is not set
+# CONFIG_CS89x0 is not set
+# CONFIG_E100 is not set
+# CONFIG_LNE390 is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NE2K_PCI is not set
+# CONFIG_NE3210 is not set
+# CONFIG_ES3210 is not set
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
+# CONFIG_R6040 is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SMSC9420 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+# CONFIG_KS8851_MLL is not set
+# CONFIG_VIA_RHINE is not set
+# CONFIG_SC92031 is not set
+# CONFIG_ATL2 is not set
+CONFIG_NETDEV_1000=y
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+CONFIG_E1000E=y
+# CONFIG_IP1000 is not set
+# CONFIG_IGB is not set
+# CONFIG_IGBVF is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SKY2 is not set
+# CONFIG_VIA_VELOCITY is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
+# CONFIG_CNIC is not set
+# CONFIG_QLA3XXX is not set
+# CONFIG_ATL1 is not set
+# CONFIG_ATL1E is not set
+# CONFIG_ATL1C is not set
+# CONFIG_JME is not set
+# CONFIG_STMMAC_ETH is not set
+# CONFIG_PCH_GBE is not set
+CONFIG_NETDEV_10000=y
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_CHELSIO_T3 is not set
+# CONFIG_CHELSIO_T4 is not set
+# CONFIG_CHELSIO_T4VF is not set
+# CONFIG_ENIC is not set
+# CONFIG_IXGBE is not set
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+# CONFIG_VXGE is not set
+# CONFIG_MYRI10GE is not set
+# CONFIG_NETXEN_NIC is not set
+# CONFIG_NIU is not set
+# CONFIG_MLX4_EN is not set
+# CONFIG_MLX4_CORE is not set
+# CONFIG_TEHUTI is not set
+# CONFIG_BNX2X is not set
+# CONFIG_QLCNIC is not set
+# CONFIG_QLGE is not set
+# CONFIG_BNA is not set
+# CONFIG_SFC is not set
+# CONFIG_BE2NET is not set
+# CONFIG_TR is not set
+CONFIG_WLAN=y
+# CONFIG_AIRO is not set
+# CONFIG_ATMEL is not set
+# CONFIG_PRISM54 is not set
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_HOSTAP is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_WAN is not set
+
+#
+# CAIF transport drivers
+#
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NET_FC is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+CONFIG_VIRTIO_NET=y
+# CONFIG_VMXNET3 is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_FF_MEMLESS=y
+CONFIG_INPUT_POLLDEV=y
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=800
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=480
+CONFIG_INPUT_JOYDEV=y
+CONFIG_INPUT_EVDEV=y
+CONFIG_INPUT_EVBUG=m
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+CONFIG_KEYBOARD_LKKBD=y
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+CONFIG_KEYBOARD_NEWTON=y
+# CONFIG_KEYBOARD_OPENCORES is not set
+CONFIG_KEYBOARD_STOWAWAY=y
+CONFIG_KEYBOARD_SUNKBD=y
+CONFIG_KEYBOARD_XTKBD=y
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_LIFEBOOK=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+CONFIG_MOUSE_PS2_ELANTECH=y
+# CONFIG_MOUSE_PS2_SENTELIC is not set
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+CONFIG_MOUSE_SERIAL=y
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_INPORT is not set
+# CONFIG_MOUSE_LOGIBM is not set
+# CONFIG_MOUSE_PC110PAD is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_SYNAPTICS_I2C is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=m
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_NOZOMI is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+CONFIG_FIX_EARLYCON_MEM=y
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_MFD_HSU is not set
+CONFIG_CONSOLE_POLL=y
+# CONFIG_SERIAL_JSM is not set
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_PCH_UART is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+CONFIG_HVC_DRIVER=y
+CONFIG_VIRTIO_CONSOLE=y
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_HW_RANDOM_INTEL is not set
+# CONFIG_HW_RANDOM_AMD is not set
+# CONFIG_HW_RANDOM_GEODE is not set
+# CONFIG_HW_RANDOM_VIA is not set
+CONFIG_HW_RANDOM_VIRTIO=y
+# CONFIG_NVRAM is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_SONYPI is not set
+# CONFIG_MWAVE is not set
+# CONFIG_PC8736x_GPIO is not set
+# CONFIG_NSC_GPIO is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_HANGCHECK_TIMER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+CONFIG_DEVPORT=y
+# CONFIG_RAMOOPS is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+# CONFIG_I2C_CHARDEV is not set
+# CONFIG_I2C_MUX is not set
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# PC SMBus host controller drivers
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_ISCH is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_INTEL_MID is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+# CONFIG_I2C_EG20T is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_ELEKTOR is not set
+# CONFIG_I2C_PCA_ISA is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_SCx200_ACB is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_SPI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+
+#
+# Enable Device Drivers -> PPS to see the PTP clock options.
+#
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+# CONFIG_GPIOLIB is not set
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_BQ20Z75 is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_ABITUGURU is not set
+# CONFIG_SENSORS_ABITUGURU3 is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_K8TEMP is not set
+# CONFIG_SENSORS_K10TEMP is not set
+# CONFIG_SENSORS_FAM15H_POWER is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_FSCHMD is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_CORETEMP is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM73 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_PMBUS is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_ADS1015 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VIA_CPUTEMP is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_SENSORS_APPLESMC is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+CONFIG_MFD_SUPPORT=y
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_CS5535 is not set
+# CONFIG_LPC_SCH is not set
+# CONFIG_MFD_RDC321X is not set
+# CONFIG_MFD_JANZ_CMODIO is not set
+# CONFIG_MFD_VX855 is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_REGULATOR is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+# CONFIG_MEDIA_CONTROLLER is not set
+CONFIG_VIDEO_DEV=m
+CONFIG_VIDEO_V4L2_COMMON=m
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=m
+
+#
+# Multimedia drivers
+#
+CONFIG_RC_CORE=y
+CONFIG_LIRC=y
+CONFIG_RC_MAP=y
+CONFIG_IR_NEC_DECODER=y
+CONFIG_IR_RC5_DECODER=y
+CONFIG_IR_RC6_DECODER=y
+CONFIG_IR_JVC_DECODER=y
+CONFIG_IR_SONY_DECODER=y
+CONFIG_IR_RC5_SZ_DECODER=y
+CONFIG_IR_LIRC_CODEC=y
+# CONFIG_IR_IMON is not set
+# CONFIG_IR_MCEUSB is not set
+# CONFIG_IR_REDRAT3 is not set
+# CONFIG_IR_STREAMZAP is not set
+# CONFIG_RC_LOOPBACK is not set
+# CONFIG_MEDIA_ATTACH is not set
+CONFIG_MEDIA_TUNER=m
+# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
+CONFIG_MEDIA_TUNER_SIMPLE=m
+CONFIG_MEDIA_TUNER_TDA8290=m
+CONFIG_MEDIA_TUNER_TDA827X=m
+CONFIG_MEDIA_TUNER_TDA18271=m
+CONFIG_MEDIA_TUNER_TDA9887=m
+CONFIG_MEDIA_TUNER_TEA5761=m
+CONFIG_MEDIA_TUNER_TEA5767=m
+CONFIG_MEDIA_TUNER_MT20XX=m
+CONFIG_MEDIA_TUNER_XC2028=m
+CONFIG_MEDIA_TUNER_XC5000=m
+CONFIG_MEDIA_TUNER_MC44S803=m
+CONFIG_VIDEO_V4L2=m
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
+CONFIG_VIDEO_IR_I2C=m
+
+#
+# Audio decoders, processors and mixers
+#
+
+#
+# RDS decoders
+#
+
+#
+# Video decoders
+#
+
+#
+# Video and audio decoders
+#
+
+#
+# MPEG video encoders
+#
+
+#
+# Video encoders
+#
+
+#
+# Camera sensor devices
+#
+
+#
+# Video improvement chips
+#
+
+#
+# Miscelaneous helper chips
+#
+# CONFIG_VIDEO_VIVI is not set
+# CONFIG_VIDEO_BT848 is not set
+# CONFIG_VIDEO_PMS is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_VIDEO_ZORAN is not set
+# CONFIG_VIDEO_SAA7134 is not set
+# CONFIG_VIDEO_MXB is not set
+# CONFIG_VIDEO_HEXIUM_ORION is not set
+# CONFIG_VIDEO_HEXIUM_GEMINI is not set
+# CONFIG_VIDEO_CX88 is not set
+# CONFIG_VIDEO_IVTV is not set
+# CONFIG_VIDEO_CAFE_CCIC is not set
+# CONFIG_VIDEO_SR030PC30 is not set
+# CONFIG_VIDEO_NOON010PC30 is not set
+# CONFIG_SOC_CAMERA is not set
+CONFIG_V4L_USB_DRIVERS=y
+# CONFIG_USB_VIDEO_CLASS is not set
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_USB_GSPCA=m
+# CONFIG_USB_M5602 is not set
+# CONFIG_USB_STV06XX is not set
+# CONFIG_USB_GL860 is not set
+# CONFIG_USB_GSPCA_BENQ is not set
+# CONFIG_USB_GSPCA_CONEX is not set
+# CONFIG_USB_GSPCA_CPIA1 is not set
+# CONFIG_USB_GSPCA_ETOMS is not set
+# CONFIG_USB_GSPCA_FINEPIX is not set
+# CONFIG_USB_GSPCA_JEILINJ is not set
+# CONFIG_USB_GSPCA_KINECT is not set
+# CONFIG_USB_GSPCA_KONICA is not set
+# CONFIG_USB_GSPCA_MARS is not set
+# CONFIG_USB_GSPCA_MR97310A is not set
+# CONFIG_USB_GSPCA_NW80X is not set
+# CONFIG_USB_GSPCA_OV519 is not set
+# CONFIG_USB_GSPCA_OV534 is not set
+# CONFIG_USB_GSPCA_OV534_9 is not set
+# CONFIG_USB_GSPCA_PAC207 is not set
+# CONFIG_USB_GSPCA_PAC7302 is not set
+# CONFIG_USB_GSPCA_PAC7311 is not set
+# CONFIG_USB_GSPCA_SN9C2028 is not set
+# CONFIG_USB_GSPCA_SN9C20X is not set
+# CONFIG_USB_GSPCA_SONIXB is not set
+# CONFIG_USB_GSPCA_SONIXJ is not set
+# CONFIG_USB_GSPCA_SPCA500 is not set
+# CONFIG_USB_GSPCA_SPCA501 is not set
+# CONFIG_USB_GSPCA_SPCA505 is not set
+# CONFIG_USB_GSPCA_SPCA506 is not set
+# CONFIG_USB_GSPCA_SPCA508 is not set
+# CONFIG_USB_GSPCA_SPCA561 is not set
+# CONFIG_USB_GSPCA_SPCA1528 is not set
+# CONFIG_USB_GSPCA_SQ905 is not set
+# CONFIG_USB_GSPCA_SQ905C is not set
+# CONFIG_USB_GSPCA_SQ930X is not set
+# CONFIG_USB_GSPCA_STK014 is not set
+# CONFIG_USB_GSPCA_STV0680 is not set
+# CONFIG_USB_GSPCA_SUNPLUS is not set
+# CONFIG_USB_GSPCA_T613 is not set
+# CONFIG_USB_GSPCA_TV8532 is not set
+# CONFIG_USB_GSPCA_VC032X is not set
+# CONFIG_USB_GSPCA_VICAM is not set
+# CONFIG_USB_GSPCA_XIRLINK_CIT is not set
+# CONFIG_USB_GSPCA_ZC3XX is not set
+# CONFIG_VIDEO_PVRUSB2 is not set
+# CONFIG_VIDEO_HDPVR is not set
+# CONFIG_VIDEO_EM28XX is not set
+# CONFIG_VIDEO_CX231XX is not set
+# CONFIG_VIDEO_USBVISION is not set
+# CONFIG_USB_ET61X251 is not set
+# CONFIG_USB_SN9C102 is not set
+# CONFIG_USB_PWC is not set
+# CONFIG_USB_ZR364XX is not set
+# CONFIG_USB_STKWEBCAM is not set
+# CONFIG_USB_S2255 is not set
+# CONFIG_V4L_MEM2MEM_DRIVERS is not set
+CONFIG_RADIO_ADAPTERS=y
+# CONFIG_RADIO_CADET is not set
+# CONFIG_RADIO_RTRACK is not set
+# CONFIG_RADIO_RTRACK2 is not set
+# CONFIG_RADIO_AZTECH is not set
+# CONFIG_RADIO_GEMTEK is not set
+# CONFIG_RADIO_MAXIRADIO is not set
+# CONFIG_RADIO_MIROPCM20 is not set
+# CONFIG_RADIO_SF16FMI is not set
+# CONFIG_RADIO_SF16FMR2 is not set
+# CONFIG_RADIO_TERRATEC is not set
+# CONFIG_RADIO_TRUST is not set
+# CONFIG_RADIO_TYPHOON is not set
+# CONFIG_RADIO_ZOLTRIX is not set
+# CONFIG_I2C_SI4713 is not set
+# CONFIG_RADIO_SI4713 is not set
+# CONFIG_USB_DSBR is not set
+# CONFIG_RADIO_SI470X is not set
+# CONFIG_USB_MR800 is not set
+# CONFIG_RADIO_TEA5764 is not set
+# CONFIG_RADIO_SAA7706H is not set
+# CONFIG_RADIO_TEF6862 is not set
+# CONFIG_RADIO_WL1273 is not set
+
+#
+# Texas Instruments WL128x FM driver (ST based)
+#
+
+#
+# Graphics support
+#
+CONFIG_AGP=y
+# CONFIG_AGP_ALI is not set
+# CONFIG_AGP_ATI is not set
+# CONFIG_AGP_AMD is not set
+# CONFIG_AGP_AMD64 is not set
+# CONFIG_AGP_INTEL is not set
+# CONFIG_AGP_NVIDIA is not set
+# CONFIG_AGP_SIS is not set
+# CONFIG_AGP_SWORKS is not set
+# CONFIG_AGP_VIA is not set
+# CONFIG_AGP_EFFICEON is not set
+CONFIG_VGA_ARB=y
+CONFIG_VGA_ARB_MAX_GPUS=16
+CONFIG_DRM=y
+CONFIG_DRM_KMS_HELPER=y
+CONFIG_DRM_TTM=y
+# CONFIG_DRM_TDFX is not set
+# CONFIG_DRM_R128 is not set
+CONFIG_DRM_RADEON=y
+# CONFIG_DRM_RADEON_KMS is not set
+# CONFIG_DRM_MGA is not set
+# CONFIG_DRM_SIS is not set
+# CONFIG_DRM_VIA is not set
+# CONFIG_DRM_SAVAGE is not set
+# CONFIG_STUB_POULSBO is not set
+# CONFIG_VGASTATE is not set
+CONFIG_VIDEO_OUTPUT_CONTROL=y
+CONFIG_FB=y
+CONFIG_FIRMWARE_EDID=y
+# CONFIG_FB_DDC is not set
+CONFIG_FB_BOOT_VESA_SUPPORT=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_WMT_GE_ROPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_FB_TILEBLITTING=y
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ARC is not set
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_IMSTT is not set
+# CONFIG_FB_VGA16 is not set
+CONFIG_FB_VESA=y
+# CONFIG_FB_N411 is not set
+# CONFIG_FB_HGA is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_LE80578 is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_VIA is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CARMINE is not set
+# CONFIG_FB_GEODE is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_VIRTIO is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=m
+CONFIG_LCD_PLATFORM=m
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GENERIC=y
+CONFIG_BACKLIGHT_PROGEAR=m
+CONFIG_BACKLIGHT_SAHARA=m
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+# CONFIG_VGACON_SOFT_SCROLLBACK is not set
+# CONFIG_MDA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_LOGO is not set
+CONFIG_SOUND=m
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=m
+CONFIG_SND_TIMER=m
+CONFIG_SND_PCM=m
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+CONFIG_SND_DYNAMIC_MINORS=y
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+CONFIG_SND_VMASTER=y
+CONFIG_SND_DMA_SGBUF=y
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_ALOOP is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+CONFIG_SND_ISA=y
+# CONFIG_SND_ADLIB is not set
+# CONFIG_SND_AD1848 is not set
+# CONFIG_SND_AZT1605 is not set
+# CONFIG_SND_AZT2316 is not set
+# CONFIG_SND_CMI8330 is not set
+# CONFIG_SND_CS4231 is not set
+# CONFIG_SND_CS4236 is not set
+# CONFIG_SND_ES1688 is not set
+# CONFIG_SND_ES18XX is not set
+# CONFIG_SND_SC6000 is not set
+# CONFIG_SND_GUSCLASSIC is not set
+# CONFIG_SND_GUSEXTREME is not set
+# CONFIG_SND_GUSMAX is not set
+# CONFIG_SND_JAZZ16 is not set
+# CONFIG_SND_OPL3SA2 is not set
+# CONFIG_SND_OPTI92X_AD1848 is not set
+# CONFIG_SND_OPTI92X_CS4231 is not set
+# CONFIG_SND_OPTI93X is not set
+# CONFIG_SND_MIRO is not set
+# CONFIG_SND_SB8 is not set
+# CONFIG_SND_SB16 is not set
+# CONFIG_SND_SBAWE is not set
+# CONFIG_SND_SSCAPE is not set
+# CONFIG_SND_WAVEFRONT is not set
+# CONFIG_SND_MSND_PINNACLE is not set
+# CONFIG_SND_MSND_CLASSIC is not set
+CONFIG_SND_PCI=y
+# CONFIG_SND_AD1889 is not set
+# CONFIG_SND_ALS300 is not set
+# CONFIG_SND_ALS4000 is not set
+# CONFIG_SND_ALI5451 is not set
+# CONFIG_SND_ASIHPI is not set
+# CONFIG_SND_ATIIXP is not set
+# CONFIG_SND_ATIIXP_MODEM is not set
+# CONFIG_SND_AU8810 is not set
+# CONFIG_SND_AU8820 is not set
+# CONFIG_SND_AU8830 is not set
+# CONFIG_SND_AW2 is not set
+# CONFIG_SND_AZT3328 is not set
+# CONFIG_SND_BT87X is not set
+# CONFIG_SND_CA0106 is not set
+# CONFIG_SND_CMIPCI is not set
+# CONFIG_SND_OXYGEN is not set
+# CONFIG_SND_CS4281 is not set
+# CONFIG_SND_CS46XX is not set
+# CONFIG_SND_CS5530 is not set
+# CONFIG_SND_CS5535AUDIO is not set
+# CONFIG_SND_CTXFI is not set
+# CONFIG_SND_DARLA20 is not set
+# CONFIG_SND_GINA20 is not set
+# CONFIG_SND_LAYLA20 is not set
+# CONFIG_SND_DARLA24 is not set
+# CONFIG_SND_GINA24 is not set
+# CONFIG_SND_LAYLA24 is not set
+# CONFIG_SND_MONA is not set
+# CONFIG_SND_MIA is not set
+# CONFIG_SND_ECHO3G is not set
+# CONFIG_SND_INDIGO is not set
+# CONFIG_SND_INDIGOIO is not set
+# CONFIG_SND_INDIGODJ is not set
+# CONFIG_SND_INDIGOIOX is not set
+# CONFIG_SND_INDIGODJX is not set
+# CONFIG_SND_EMU10K1 is not set
+# CONFIG_SND_EMU10K1X is not set
+# CONFIG_SND_ENS1370 is not set
+# CONFIG_SND_ENS1371 is not set
+# CONFIG_SND_ES1938 is not set
+# CONFIG_SND_ES1968 is not set
+# CONFIG_SND_FM801 is not set
+CONFIG_SND_HDA_INTEL=m
+# CONFIG_SND_HDA_HWDEP is not set
+# CONFIG_SND_HDA_INPUT_BEEP is not set
+# CONFIG_SND_HDA_INPUT_JACK is not set
+# CONFIG_SND_HDA_PATCH_LOADER is not set
+CONFIG_SND_HDA_CODEC_REALTEK=y
+CONFIG_SND_HDA_CODEC_ANALOG=y
+CONFIG_SND_HDA_CODEC_SIGMATEL=y
+CONFIG_SND_HDA_CODEC_VIA=y
+CONFIG_SND_HDA_CODEC_HDMI=y
+CONFIG_SND_HDA_CODEC_CIRRUS=y
+CONFIG_SND_HDA_CODEC_CONEXANT=y
+CONFIG_SND_HDA_CODEC_CA0110=y
+CONFIG_SND_HDA_CODEC_CMEDIA=y
+CONFIG_SND_HDA_CODEC_SI3054=y
+CONFIG_SND_HDA_GENERIC=y
+# CONFIG_SND_HDA_POWER_SAVE is not set
+# CONFIG_SND_HDSP is not set
+# CONFIG_SND_HDSPM is not set
+# CONFIG_SND_ICE1712 is not set
+# CONFIG_SND_ICE1724 is not set
+# CONFIG_SND_INTEL8X0 is not set
+# CONFIG_SND_INTEL8X0M is not set
+# CONFIG_SND_KORG1212 is not set
+# CONFIG_SND_LOLA is not set
+# CONFIG_SND_LX6464ES is not set
+# CONFIG_SND_MAESTRO3 is not set
+# CONFIG_SND_MIXART is not set
+# CONFIG_SND_NM256 is not set
+# CONFIG_SND_PCXHR is not set
+# CONFIG_SND_RIPTIDE is not set
+# CONFIG_SND_RME32 is not set
+# CONFIG_SND_RME96 is not set
+# CONFIG_SND_RME9652 is not set
+# CONFIG_SND_SIS7019 is not set
+# CONFIG_SND_SONICVIBES is not set
+# CONFIG_SND_TRIDENT is not set
+# CONFIG_SND_VIA82XX is not set
+# CONFIG_SND_VIA82XX_MODEM is not set
+# CONFIG_SND_VIRTUOSO is not set
+# CONFIG_SND_VX222 is not set
+# CONFIG_SND_YMFPCI is not set
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_USX2Y is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_US122L is not set
+# CONFIG_SND_USB_6FIRE is not set
+# CONFIG_SND_SOC is not set
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+CONFIG_HIDRAW=y
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+CONFIG_HID_PID=y
+CONFIG_USB_HIDDEV=y
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=y
+# CONFIG_HID_ACRUX is not set
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+# CONFIG_HID_PRODIKEYS is not set
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DRAGONRISE=y
+# CONFIG_DRAGONRISE_FF is not set
+# CONFIG_HID_EMS_FF is not set
+CONFIG_HID_EZKEY=y
+# CONFIG_HID_KEYTOUCH is not set
+CONFIG_HID_KYE=y
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+CONFIG_HID_GYRATION=y
+CONFIG_HID_TWINHAN=y
+CONFIG_HID_KENSINGTON=y
+# CONFIG_HID_LCPOWER is not set
+CONFIG_HID_LOGITECH=y
+CONFIG_LOGITECH_FF=y
+CONFIG_LOGIRUMBLEPAD2_FF=y
+# CONFIG_LOGIG940_FF is not set
+# CONFIG_LOGIWII_FF is not set
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+# CONFIG_HID_MULTITOUCH is not set
+CONFIG_HID_NTRIG=y
+CONFIG_HID_ORTEK=y
+CONFIG_HID_PANTHERLORD=y
+CONFIG_PANTHERLORD_FF=y
+CONFIG_HID_PETALYNX=y
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_QUANTA is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_ROCCAT_ARVO is not set
+# CONFIG_HID_ROCCAT_KONE is not set
+# CONFIG_HID_ROCCAT_KONEPLUS is not set
+# CONFIG_HID_ROCCAT_KOVAPLUS is not set
+# CONFIG_HID_ROCCAT_PYRA is not set
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_HID_GREENASIA=y
+# CONFIG_GREENASIA_FF is not set
+CONFIG_HID_SMARTJOYPLUS=y
+# CONFIG_SMARTJOYPLUS_FF is not set
+CONFIG_HID_TOPSEED=y
+CONFIG_HID_THRUSTMASTER=y
+# CONFIG_THRUSTMASTER_FF is not set
+CONFIG_HID_ZEROPLUS=y
+# CONFIG_ZEROPLUS_FF is not set
+# CONFIG_HID_ZYDACRON is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_DEVICE_CLASS is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_MON=y
+CONFIG_USB_WUSB=m
+CONFIG_USB_WUSB_CBAF=m
+# CONFIG_USB_WUSB_CBAF_DEBUG is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_C67X00_HCD=m
+# CONFIG_USB_XHCI_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+# CONFIG_USB_OXU210HP_HCD is not set
+CONFIG_USB_ISP116X_HCD=m
+CONFIG_USB_ISP1760_HCD=m
+# CONFIG_USB_ISP1362_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_UHCI_HCD=y
+CONFIG_USB_U132_HCD=m
+CONFIG_USB_SL811_HCD=m
+# CONFIG_USB_SL811_HCD_ISO is not set
+CONFIG_USB_R8A66597_HCD=m
+CONFIG_USB_WHCI_HCD=m
+CONFIG_USB_HWA_HCD=m
+
+#
+# USB Device Class drivers
+#
+CONFIG_USB_ACM=m
+CONFIG_USB_PRINTER=m
+CONFIG_USB_WDM=m
+CONFIG_USB_TMC=m
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+CONFIG_USB_STORAGE_DATAFAB=m
+CONFIG_USB_STORAGE_FREECOM=m
+CONFIG_USB_STORAGE_ISD200=m
+CONFIG_USB_STORAGE_USBAT=m
+CONFIG_USB_STORAGE_SDDR09=m
+CONFIG_USB_STORAGE_SDDR55=m
+CONFIG_USB_STORAGE_JUMPSHOT=m
+CONFIG_USB_STORAGE_ALAUDA=m
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+CONFIG_USB_STORAGE_KARMA=m
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_UAS is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+CONFIG_USB_MDC800=m
+CONFIG_USB_MICROTEK=m
+
+#
+# USB port drivers
+#
+CONFIG_USB_SERIAL=m
+CONFIG_USB_EZUSB=y
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_AIRCABLE=m
+CONFIG_USB_SERIAL_ARK3116=m
+CONFIG_USB_SERIAL_BELKIN=m
+CONFIG_USB_SERIAL_CH341=m
+CONFIG_USB_SERIAL_WHITEHEAT=m
+CONFIG_USB_SERIAL_DIGI_ACCELEPORT=m
+# CONFIG_USB_SERIAL_CP210X is not set
+CONFIG_USB_SERIAL_CYPRESS_M8=m
+CONFIG_USB_SERIAL_EMPEG=m
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_SERIAL_FUNSOFT=m
+CONFIG_USB_SERIAL_VISOR=m
+CONFIG_USB_SERIAL_IPAQ=m
+# CONFIG_USB_SERIAL_IR is not set
+CONFIG_USB_SERIAL_EDGEPORT=m
+CONFIG_USB_SERIAL_EDGEPORT_TI=m
+CONFIG_USB_SERIAL_GARMIN=m
+CONFIG_USB_SERIAL_IPW=m
+# CONFIG_USB_SERIAL_IUU is not set
+CONFIG_USB_SERIAL_KEYSPAN_PDA=m
+CONFIG_USB_SERIAL_KEYSPAN=m
+CONFIG_USB_SERIAL_KLSI=m
+CONFIG_USB_SERIAL_KOBIL_SCT=m
+CONFIG_USB_SERIAL_MCT_U232=m
+CONFIG_USB_SERIAL_MOS7720=m
+CONFIG_USB_SERIAL_MOS7840=m
+CONFIG_USB_SERIAL_MOTOROLA=m
+CONFIG_USB_SERIAL_NAVMAN=m
+CONFIG_USB_SERIAL_PL2303=m
+CONFIG_USB_SERIAL_OTI6858=m
+# CONFIG_USB_SERIAL_QCAUX is not set
+# CONFIG_USB_SERIAL_QUALCOMM is not set
+CONFIG_USB_SERIAL_SPCP8X5=m
+CONFIG_USB_SERIAL_HP4X=m
+CONFIG_USB_SERIAL_SAFE=m
+# CONFIG_USB_SERIAL_SAFE_PADDED is not set
+# CONFIG_USB_SERIAL_SIEMENS_MPI is not set
+CONFIG_USB_SERIAL_SIERRAWIRELESS=m
+# CONFIG_USB_SERIAL_SYMBOL is not set
+CONFIG_USB_SERIAL_TI=m
+CONFIG_USB_SERIAL_CYBERJACK=m
+CONFIG_USB_SERIAL_XIRCOM=m
+CONFIG_USB_SERIAL_WWAN=m
+CONFIG_USB_SERIAL_OPTION=m
+CONFIG_USB_SERIAL_OMNINET=m
+# CONFIG_USB_SERIAL_OPTICON is not set
+# CONFIG_USB_SERIAL_VIVOPAY_SERIAL is not set
+# CONFIG_USB_SERIAL_ZIO is not set
+# CONFIG_USB_SERIAL_SSU100 is not set
+CONFIG_USB_SERIAL_DEBUG=m
+
+#
+# USB Miscellaneous drivers
+#
+CONFIG_USB_EMI62=m
+CONFIG_USB_EMI26=m
+CONFIG_USB_ADUTUX=m
+CONFIG_USB_SEVSEG=m
+CONFIG_USB_RIO500=m
+CONFIG_USB_LEGOTOWER=m
+CONFIG_USB_LCD=m
+CONFIG_USB_LED=m
+CONFIG_USB_CYPRESS_CY7C63=m
+CONFIG_USB_CYTHERM=m
+CONFIG_USB_IDMOUSE=m
+CONFIG_USB_FTDI_ELAN=m
+CONFIG_USB_APPLEDISPLAY=m
+CONFIG_USB_SISUSBVGA=m
+# CONFIG_USB_SISUSBVGA_CON is not set
+CONFIG_USB_LD=m
+CONFIG_USB_TRANCEVIBRATOR=m
+CONFIG_USB_IOWARRIOR=m
+# CONFIG_USB_TEST is not set
+CONFIG_USB_ISIGHTFW=m
+# CONFIG_USB_YUREX is not set
+CONFIG_USB_GADGET=m
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_FUSB300 is not set
+# CONFIG_USB_GADGET_R8A66597 is not set
+# CONFIG_USB_GADGET_PXA_U2O is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_CI13XXX_PCI is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_LANGWELL is not set
+# CONFIG_USB_GADGET_EG20T is not set
+CONFIG_USB_GADGET_DUMMY_HCD=y
+CONFIG_USB_DUMMY_HCD=m
+CONFIG_USB_GADGET_DUALSPEED=y
+CONFIG_USB_ZERO=m
+# CONFIG_USB_AUDIO is not set
+CONFIG_USB_ETH=m
+CONFIG_USB_ETH_RNDIS=y
+# CONFIG_USB_ETH_EEM is not set
+# CONFIG_USB_G_NCM is not set
+CONFIG_USB_GADGETFS=m
+# CONFIG_USB_FUNCTIONFS is not set
+CONFIG_USB_FILE_STORAGE=m
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+# CONFIG_USB_MASS_STORAGE is not set
+CONFIG_USB_G_SERIAL=m
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+CONFIG_USB_CDC_COMPOSITE=m
+# CONFIG_USB_G_MULTI is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_DBGP is not set
+# CONFIG_USB_G_WEBCAM is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_UWB=m
+CONFIG_UWB_HWA=m
+CONFIG_UWB_WHCI=m
+CONFIG_UWB_I1480U=m
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_NFC_DEVICES is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+# CONFIG_EDAC is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+CONFIG_RTC_DRV_CMOS=y
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_RTC_DRV_VIRTIO=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_STAGING is not set
+# CONFIG_X86_PLATFORM_DEVICES is not set
+CONFIG_CLKSRC_I8253=y
+
+#
+# Firmware Drivers
+#
+# CONFIG_EDD is not set
+CONFIG_FIRMWARE_MEMMAP=y
+# CONFIG_DELL_RBU is not set
+# CONFIG_DCDBAS is not set
+# CONFIG_DMIID is not set
+# CONFIG_DMI_SYSFS is not set
+# CONFIG_ISCSI_IBFT_FIND is not set
+# CONFIG_SIGMA is not set
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+CONFIG_EXT3_FS_XATTR=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_XATTR=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+CONFIG_BTRFS_FS=y
+CONFIG_BTRFS_FS_POSIX_ACL=y
+# CONFIG_NILFS2_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+CONFIG_PRINT_QUOTA_WARNING=y
+# CONFIG_QUOTA_DEBUG is not set
+CONFIG_QUOTA_TREE=m
+CONFIG_QFMT_V1=m
+CONFIG_QFMT_V2=m
+CONFIG_QUOTACTL=y
+CONFIG_AUTOFS4_FS=m
+CONFIG_FUSE_FS=m
+# CONFIG_CUSE is not set
+CONFIG_GENERIC_ACL=y
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=y
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=m
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=m
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+CONFIG_NTFS_FS=m
+# CONFIG_NTFS_DEBUG is not set
+# CONFIG_NTFS_RW is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_HUGETLBFS=y
+CONFIG_HUGETLB_PAGE=y
+CONFIG_CONFIGFS_FS=m
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+CONFIG_SQUASHFS=m
+# CONFIG_SQUASHFS_XATTR is not set
+# CONFIG_SQUASHFS_LZO is not set
+# CONFIG_SQUASHFS_XZ is not set
+# CONFIG_SQUASHFS_EMBEDDED is not set
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_NETWORK_FILESYSTEMS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_ACORN_PARTITION=y
+# CONFIG_ACORN_PARTITION_CUMANA is not set
+# CONFIG_ACORN_PARTITION_EESOX is not set
+CONFIG_ACORN_PARTITION_ICS=y
+# CONFIG_ACORN_PARTITION_ADFS is not set
+# CONFIG_ACORN_PARTITION_POWERTEC is not set
+CONFIG_ACORN_PARTITION_RISCIX=y
+CONFIG_OSF_PARTITION=y
+CONFIG_AMIGA_PARTITION=y
+CONFIG_ATARI_PARTITION=y
+CONFIG_MAC_PARTITION=y
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+CONFIG_LDM_PARTITION=y
+# CONFIG_LDM_DEBUG is not set
+CONFIG_SGI_PARTITION=y
+CONFIG_ULTRIX_PARTITION=y
+CONFIG_SUN_PARTITION=y
+CONFIG_KARMA_PARTITION=y
+CONFIG_EFI_PARTITION=y
+CONFIG_SYSV68_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="cp437"
+CONFIG_NLS_CODEPAGE_437=m
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_NLS_CODEPAGE_936=m
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_932=m
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_ISO8859_8=m
+CONFIG_NLS_CODEPAGE_1250=m
+CONFIG_NLS_CODEPAGE_1251=m
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=m
+CONFIG_NLS_ISO8859_2=m
+CONFIG_NLS_ISO8859_3=m
+CONFIG_NLS_ISO8859_4=m
+CONFIG_NLS_ISO8859_5=m
+CONFIG_NLS_ISO8859_6=m
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_ISO8859_9=m
+CONFIG_NLS_ISO8859_13=m
+CONFIG_NLS_ISO8859_14=m
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_KOI8_R=m
+CONFIG_NLS_KOI8_U=m
+CONFIG_NLS_UTF8=m
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_PRINTK_TIME=y
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+CONFIG_UNUSED_SYMBOLS=y
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=120
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+CONFIG_SCHED_DEBUG=y
+CONFIG_SCHEDSTATS=y
+CONFIG_TIMER_STATS=y
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_VIRTUAL is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_LKDTM is not set
+# CONFIG_FAULT_INJECTION is not set
+CONFIG_LATENCYTOP=y
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_USER_STACKTRACE_SUPPORT=y
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_FP_TEST=y
+CONFIG_HAVE_FUNCTION_TRACE_MCOUNT_TEST=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_EVENT_POWER_TRACING_DEPRECATED=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_TRACING=y
+CONFIG_GENERIC_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_FTRACE_SYSCALLS is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_STACK_TRACER is not set
+CONFIG_BLK_DEV_IO_TRACE=y
+# CONFIG_FTRACE_STARTUP_TEST is not set
+# CONFIG_MMIOTRACE is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+# CONFIG_PROVIDE_OHCI1394_DMA_INIT is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_KGDB=y
+CONFIG_KGDB_SERIAL_CONSOLE=y
+# CONFIG_KGDB_TESTS is not set
+# CONFIG_KGDB_LOW_LEVEL_TRAP is not set
+# CONFIG_KGDB_KDB is not set
+CONFIG_HAVE_ARCH_KMEMCHECK=y
+# CONFIG_KMEMCHECK is not set
+# CONFIG_TEST_KSTRTOX is not set
+CONFIG_STRICT_DEVMEM=y
+# CONFIG_X86_VERBOSE_BOOTUP is not set
+CONFIG_EARLY_PRINTK=y
+# CONFIG_EARLY_PRINTK_DBGP is not set
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+# CONFIG_X86_PTDUMP is not set
+CONFIG_DEBUG_RODATA=y
+# CONFIG_DEBUG_RODATA_TEST is not set
+# CONFIG_DEBUG_SET_MODULE_RONX is not set
+# CONFIG_DEBUG_NX_TEST is not set
+CONFIG_DOUBLEFAULT=y
+# CONFIG_IOMMU_STRESS is not set
+CONFIG_HAVE_MMIOTRACE_SUPPORT=y
+CONFIG_IO_DELAY_TYPE_0X80=0
+CONFIG_IO_DELAY_TYPE_0XED=1
+CONFIG_IO_DELAY_TYPE_UDELAY=2
+CONFIG_IO_DELAY_TYPE_NONE=3
+# CONFIG_IO_DELAY_0X80 is not set
+CONFIG_IO_DELAY_0XED=y
+# CONFIG_IO_DELAY_UDELAY is not set
+# CONFIG_IO_DELAY_NONE is not set
+CONFIG_DEFAULT_IO_DELAY_TYPE=1
+# CONFIG_DEBUG_BOOT_PARAMS is not set
+# CONFIG_CPA_DEBUG is not set
+CONFIG_OPTIMIZE_INLINING=y
+# CONFIG_DEBUG_STRICT_USER_COPY_CHECKS is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+# CONFIG_KEYS_DEBUG_PROC_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=m
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=m
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=m
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+CONFIG_CRYPTO_GF128MUL=m
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_WORKQUEUE=y
+CONFIG_CRYPTO_CRYPTD=m
+CONFIG_CRYPTO_AUTHENC=m
+CONFIG_CRYPTO_TEST=m
+
+#
+# Authenticated Encryption with Associated Data
+#
+CONFIG_CRYPTO_CCM=m
+CONFIG_CRYPTO_GCM=m
+CONFIG_CRYPTO_SEQIV=m
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=m
+CONFIG_CRYPTO_CTR=m
+CONFIG_CRYPTO_CTS=m
+CONFIG_CRYPTO_ECB=m
+CONFIG_CRYPTO_LRW=m
+CONFIG_CRYPTO_PCBC=m
+CONFIG_CRYPTO_XTS=m
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_XCBC=m
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+CONFIG_CRYPTO_CRC32C_INTEL=m
+CONFIG_CRYPTO_GHASH=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_RMD128=m
+CONFIG_CRYPTO_RMD160=m
+CONFIG_CRYPTO_RMD256=m
+CONFIG_CRYPTO_RMD320=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_WP512=m
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=m
+# CONFIG_CRYPTO_AES_586 is not set
+# CONFIG_CRYPTO_AES_NI_INTEL is not set
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_ARC4=m
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_CAMELLIA=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_DES=m
+CONFIG_CRYPTO_FCRYPT=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_SALSA20=m
+# CONFIG_CRYPTO_SALSA20_586 is not set
+CONFIG_CRYPTO_SEED=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_TWOFISH_COMMON=m
+# CONFIG_CRYPTO_TWOFISH_586 is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=m
+# CONFIG_CRYPTO_ZLIB is not set
+CONFIG_CRYPTO_LZO=m
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=m
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_PADLOCK is not set
+# CONFIG_CRYPTO_DEV_GEODE is not set
+CONFIG_CRYPTO_DEV_HIFN_795X=m
+CONFIG_CRYPTO_DEV_HIFN_795X_RNG=y
+CONFIG_HAVE_KVM=y
+CONFIG_VIRTUALIZATION=y
+# CONFIG_KVM is not set
+# CONFIG_VHOST_NET is not set
+# CONFIG_LGUEST is not set
+CONFIG_VIRTIO=y
+# CONFIG_VIRTIO_RING is not set
+# CONFIG_VIRTIO_PCI is not set
+# CONFIG_VIRTIO_BALLON is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_FIRST_BIT=y
+CONFIG_CRC_CCITT=m
+CONFIG_CRC16=y
+CONFIG_CRC_T10DIF=y
+CONFIG_CRC_ITU_T=y
+CONFIG_CRC32=y
+CONFIG_CRC7=m
+CONFIG_LIBCRC32C=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_DECOMPRESS_LZO=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=m
+CONFIG_TEXTSEARCH_BM=m
+CONFIG_TEXTSEARCH_FSM=m
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_CHECK_SIGNATURE=y
+CONFIG_NLATTR=y
+# CONFIG_AVERAGE is not set
diff -Nur linux-3.0.34/arch/x86/include/asm/desc.h linux-3.0.34-xm/arch/x86/include/asm/desc.h
--- linux-3.0.34/arch/x86/include/asm/desc.h	2012-06-09 17:33:45.000000000 +0200
+++ linux-3.0.34-xm/arch/x86/include/asm/desc.h	2013-01-13 23:14:56.000000000 +0100
@@ -329,7 +329,7 @@
 static inline void set_intr_gate(unsigned int n, void *addr)
 {
 	BUG_ON((unsigned)n > 0xFF);
-	_set_gate(n, GATE_INTERRUPT, addr, 0, 0, __KERNEL_CS);
+	_set_gate(n, GATE_INTERRUPT, addr, 0, 0, __KERNEL_CS|get_kernel_rpl());
 }
 
 extern int first_system_vector;
@@ -359,19 +359,19 @@
 static inline void set_system_intr_gate(unsigned int n, void *addr)
 {
 	BUG_ON((unsigned)n > 0xFF);
-	_set_gate(n, GATE_INTERRUPT, addr, 0x3, 0, __KERNEL_CS);
+	_set_gate(n, GATE_INTERRUPT, addr, 0x3, 0, __KERNEL_CS|get_kernel_rpl());
 }
 
 static inline void set_system_trap_gate(unsigned int n, void *addr)
 {
 	BUG_ON((unsigned)n > 0xFF);
-	_set_gate(n, GATE_TRAP, addr, 0x3, 0, __KERNEL_CS);
+	_set_gate(n, GATE_TRAP, addr, 0x3, 0, __KERNEL_CS|get_kernel_rpl());
 }
 
 static inline void set_trap_gate(unsigned int n, void *addr)
 {
 	BUG_ON((unsigned)n > 0xFF);
-	_set_gate(n, GATE_TRAP, addr, 0, 0, __KERNEL_CS);
+	_set_gate(n, GATE_TRAP, addr, 0, 0, __KERNEL_CS|get_kernel_rpl());
 }
 
 static inline void set_task_gate(unsigned int n, unsigned int gdt_entry)
@@ -383,13 +383,13 @@
 static inline void set_intr_gate_ist(int n, void *addr, unsigned ist)
 {
 	BUG_ON((unsigned)n > 0xFF);
-	_set_gate(n, GATE_INTERRUPT, addr, 0, ist, __KERNEL_CS);
+	_set_gate(n, GATE_INTERRUPT, addr, 0, ist, __KERNEL_CS|get_kernel_rpl());
 }
 
 static inline void set_system_intr_gate_ist(int n, void *addr, unsigned ist)
 {
 	BUG_ON((unsigned)n > 0xFF);
-	_set_gate(n, GATE_INTERRUPT, addr, 0x3, ist, __KERNEL_CS);
+	_set_gate(n, GATE_INTERRUPT, addr, 0x3, ist, __KERNEL_CS|get_kernel_rpl());
 }
 
 #endif /* _ASM_X86_DESC_H */
diff -Nur linux-3.0.34/arch/x86/include/asm/pgtable-2level.h linux-3.0.34-xm/arch/x86/include/asm/pgtable-2level.h
--- linux-3.0.34/arch/x86/include/asm/pgtable-2level.h	2012-06-09 17:33:45.000000000 +0200
+++ linux-3.0.34-xm/arch/x86/include/asm/pgtable-2level.h	2013-01-13 23:14:56.000000000 +0100
@@ -34,7 +34,7 @@
 static inline void native_pte_clear(struct mm_struct *mm,
 				    unsigned long addr, pte_t *xp)
 {
-	*xp = native_make_pte(0);
+	set_pte(xp, native_make_pte(0));
 }
 
 #ifdef CONFIG_SMP
diff -Nur linux-3.0.34/arch/x86/include/asm/pgtable.h linux-3.0.34-xm/arch/x86/include/asm/pgtable.h
--- linux-3.0.34/arch/x86/include/asm/pgtable.h	2012-06-09 17:33:45.000000000 +0200
+++ linux-3.0.34-xm/arch/x86/include/asm/pgtable.h	2013-01-13 23:14:57.000000000 +0100
@@ -699,7 +699,10 @@
 static inline void ptep_set_wrprotect(struct mm_struct *mm,
 				      unsigned long addr, pte_t *ptep)
 {
-	clear_bit(_PAGE_BIT_RW, (unsigned long *)&ptep->pte);
+	pte_t aux = *ptep;
+
+	clear_bit(_PAGE_BIT_RW, (unsigned long *)&aux.pte);
+	set_pte(ptep, aux);
 	pte_update(mm, addr, ptep);
 }
 
diff -Nur linux-3.0.34/arch/x86/include/asm/ptrace.h linux-3.0.34-xm/arch/x86/include/asm/ptrace.h
--- linux-3.0.34/arch/x86/include/asm/ptrace.h	2012-06-09 17:33:45.000000000 +0200
+++ linux-3.0.34-xm/arch/x86/include/asm/ptrace.h	2013-01-13 23:14:56.000000000 +0100
@@ -31,6 +31,9 @@
 	int  xfs;
 	int  xgs;
 	long orig_eax;
+#ifdef CONFIG_XM_PARTITION
+	long iflags;
+#endif
 	long eip;
 	int  xcs;
 	long eflags;
@@ -53,6 +56,9 @@
 	unsigned long fs;
 	unsigned long gs;
 	unsigned long orig_ax;
+#ifdef CONFIG_XM_PARTITION
+	long iflags;
+#endif
 	unsigned long ip;
 	unsigned long cs;
 	unsigned long flags;
diff -Nur linux-3.0.34/arch/x86/include/asm/system.h linux-3.0.34-xm/arch/x86/include/asm/system.h
--- linux-3.0.34/arch/x86/include/asm/system.h	2012-06-09 17:33:45.000000000 +0200
+++ linux-3.0.34-xm/arch/x86/include/asm/system.h	2013-01-13 23:14:56.000000000 +0100
@@ -41,6 +41,7 @@
 #define __switch_canary_iparam
 #endif	/* CC_STACKPROTECTOR */
 
+#ifndef CONFIG_XM_PARTITION
 /*
  * Saving eflags is important. It switches not only IOPL between tasks,
  * it also protects other tasks from NT leaking through sysenter etc.
@@ -93,6 +94,58 @@
 			"memory");					\
 } while (0)
 
+#else
+extern void __restore_iflags(long iflags);
+extern long __save_iflags(void);
+#define switch_to(prev, next, last)					\
+do {									\
+         unsigned long ebx, ecx, edx, esi, edi, eflags, iflags;		\
+	 iflags=__save_iflags();                                        \
+	 eflags=arch_local_save_flags();                                \
+	 asm volatile("pushl %0\n\t" /* Save iflags */ ::"r"(iflags));  \
+	 asm volatile("pushl %0\n\t" /* Save flags */ ::"r"(eflags));   \
+									\
+	asm volatile("pushl %%ebp\n\t"		/* save    EBP   */	\
+		     "movl %%esp,%[prev_sp]\n\t"	/* save    ESP   */ \
+		     "movl %[next_sp],%%esp\n\t"	/* restore ESP   */ \
+		     "movl $1f,%[prev_ip]\n\t"	/* save    EIP   */	\
+		     "pushl %[next_ip]\n\t"	/* restore EIP   */	\
+		     __switch_canary					\
+		     "jmp __switch_to\n"	/* regparm call  */	\
+		     "1:\t"						\
+		     "popl %%ebp\n\t"		/* restore EBP   */	\
+									\
+		     /* output parameters */				\
+		     : [prev_sp] "=m" (prev->thread.sp),		\
+		       [prev_ip] "=m" (prev->thread.ip),		\
+		       "=a" (last),					\
+									\
+		       /* clobbered output registers: */		\
+		       "=b" (ebx), "=c" (ecx), "=d" (edx),		\
+		       "=S" (esi), "=D" (edi)				\
+		       							\
+		       __switch_canary_oparam				\
+									\
+		       /* input parameters: */				\
+		     : [next_sp]  "m" (next->thread.sp),		\
+		       [next_ip]  "m" (next->thread.ip),		\
+		       							\
+		       /* regparm parameters for __switch_to(): */	\
+		       [prev]     "a" (prev),				\
+		       [next]     "d" (next)				\
+									\
+		       __switch_canary_iparam				\
+									\
+		     : /* reloaded segment registers */			\
+			"memory");					\
+                     asm volatile("popl %0\n\t" :"=r"(eflags));         \
+                     asm volatile("popl %0\n\t" :"=r"(iflags));         \
+                     raw_local_irq_restore(eflags);                     \
+                     __restore_iflags(iflags);                          \
+} while (0)
+
+#endif
+
 /*
  * disable hlt during certain critical i/o operations
  */
diff -Nur linux-3.0.34/arch/x86/Kconfig linux-3.0.34-xm/arch/x86/Kconfig
--- linux-3.0.34/arch/x86/Kconfig	2012-06-09 17:33:45.000000000 +0200
+++ linux-3.0.34-xm/arch/x86/Kconfig	2013-01-13 23:14:53.000000000 +0100
@@ -534,6 +534,8 @@
 
 source "arch/x86/lguest/Kconfig"
 
+source "arch/x86/xm/Kconfig"
+
 config PARAVIRT
 	bool "Enable paravirtualization code"
 	---help---
diff -Nur linux-3.0.34/arch/x86/kernel/entry_32.S linux-3.0.34-xm/arch/x86/kernel/entry_32.S
--- linux-3.0.34/arch/x86/kernel/entry_32.S	2012-06-09 17:33:45.000000000 +0200
+++ linux-3.0.34-xm/arch/x86/kernel/entry_32.S	2013-01-13 23:15:00.000000000 +0100
@@ -493,12 +493,34 @@
 	PTGS_TO_GS_EX
 ENDPROC(ia32_sysenter_target)
 
+#ifdef CONFIG_XM_PARTITION
+#define IFLAGS_IRQ_BIT 0
+#define IFLAGS_ARCH_BIT 16
+#define IFLAGS_IRQ_MASK (1<<(IFLAGS_IRQ_BIT))
+#define IFLAGS_ARCH_MASK (0xFF<<IFLAGS_ARCH_BIT)
+#define IFLAGS_MASK (IFLAGS_IRQ_MASK|IFLAGS_ARCH_MASK)
+#define _IFLAGS_OFFSET 0x4	
+#endif
+
 /*
  * syscall stub including irq exit should be protected against kprobes
  */
 	.pushsection .kprobes.text, "ax"
 	# system call handler stub
 ENTRY(system_call)
+#ifdef CONFIG_XM_PARTITION
+	subl $4, %esp
+	pushl %ds
+	pushl %eax
+	movl $(__KERNEL_DS|1), %eax
+	movl %eax, %ds	
+	movl libXmParams, %eax
+	movl _IFLAGS_OFFSET(%eax), %eax
+	andl $(IFLAGS_MASK), %eax
+	movl %eax, 8(%esp)
+	popl %eax
+	popl %ds
+#endif
 	RING0_INT_FRAME			# can't unwind into user space anyway
 	pushl_cfi %eax			# save orig_eax
 	SAVE_ALL
@@ -1420,6 +1442,44 @@
 END(async_page_fault)
 #endif
 
+#ifdef CONFIG_XM_PARTITION
+
+.section .init.rodata,"a"
+ENTRY(ext_interrupt)
+.text
+	.p2align 5
+	.p2align CONFIG_X86_L1_CACHE_SHIFT
+ENTRY(ext_irq_entries_start)
+	RING0_INT_FRAME
+vector=0
+.rept 32
+1:
+	pushl $~(vector)
+	CFI_ADJUST_CFA_OFFSET 4
+	jmp common_ext_irq
+.previous
+	.long 1b
+.text
+vector=vector+1
+.endr
+
+END(ext_irq_entries_start)
+.previous
+END(ext_interrupt)
+.previous
+
+	.p2align CONFIG_X86_L1_CACHE_SHIFT
+common_ext_irq:
+	SAVE_ALL
+	TRACE_IRQS_OFF
+	movl %esp,%eax
+	call do_extIRQ
+	jmp ret_from_intr
+ENDPROC(common_ext_irq)
+	CFI_ENDPROC
+
+#endif
+	
 /*
  * End of kprobes section
  */
diff -Nur linux-3.0.34/arch/x86/kernel/head_32.S linux-3.0.34-xm/arch/x86/kernel/head_32.S
--- linux-3.0.34/arch/x86/kernel/head_32.S	2012-06-09 17:33:45.000000000 +0200
+++ linux-3.0.34-xm/arch/x86/kernel/head_32.S	2013-01-13 23:15:01.000000000 +0100
@@ -248,6 +248,7 @@
 bad_subarch:
 WEAK(lguest_entry)
 WEAK(xen_entry)
+WEAK(xm_entry)
 	/* Unknown implementation; there's really
 	   nothing we can do at this point. */
 	ud2a
@@ -258,6 +259,7 @@
 	.long default_entry		/* normal x86/PC */
 	.long lguest_entry		/* lguest hypervisor */
 	.long xen_entry			/* Xen hypervisor */
+	.long xm_entry			/* XM hypervisor */
 	.long default_entry		/* Moorestown MID */
 num_subarch_entries = (. - subarch_entries) / 4
 .previous
diff -Nur linux-3.0.34/arch/x86/kernel/process.c linux-3.0.34-xm/arch/x86/kernel/process.c
--- linux-3.0.34/arch/x86/kernel/process.c	2012-06-09 17:33:45.000000000 +0200
+++ linux-3.0.34-xm/arch/x86/kernel/process.c	2013-01-13 23:15:01.000000000 +0100
@@ -295,6 +295,9 @@
 	regs.cs = __KERNEL_CS | get_kernel_rpl();
 	regs.flags = X86_EFLAGS_IF | 0x2;
 
+#ifdef CONFIG_XM_PARTITION
+	regs.iflags=0x1;
+#endif
 	/* Ok, create the new process.. */
 	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
 }
diff -Nur linux-3.0.34/arch/x86/kernel/setup.c linux-3.0.34-xm/arch/x86/kernel/setup.c
--- linux-3.0.34/arch/x86/kernel/setup.c	2012-06-09 17:33:45.000000000 +0200
+++ linux-3.0.34-xm/arch/x86/kernel/setup.c	2013-01-13 23:14:57.000000000 +0100
@@ -927,7 +927,9 @@
 	printk(KERN_DEBUG "initial memory mapped : 0 - %08lx\n",
 			max_pfn_mapped<<PAGE_SHIFT);
 
+#ifdef CONFIG_X86_64
 	setup_trampolines();
+#endif
 
 	init_gbpages();
 
diff -Nur linux-3.0.34/arch/x86/Makefile linux-3.0.34-xm/arch/x86/Makefile
--- linux-3.0.34/arch/x86/Makefile	2012-06-09 17:33:45.000000000 +0200
+++ linux-3.0.34-xm/arch/x86/Makefile	2013-01-13 23:14:53.000000000 +0100
@@ -127,6 +127,9 @@
 
 libs-y  += arch/x86/lib/
 
+# XtratuM paravirtualization support
+core-$(CONFIG_XM_PARTITION) += arch/x86/xm/
+
 # See arch/x86/Kbuild for content of core part of the kernel
 core-y += arch/x86/
 
diff -Nur linux-3.0.34/arch/x86/mm/init.c linux-3.0.34-xm/arch/x86/mm/init.c
--- linux-3.0.34/arch/x86/mm/init.c	2012-06-09 17:33:45.000000000 +0200
+++ linux-3.0.34-xm/arch/x86/mm/init.c	2013-01-13 23:14:56.000000000 +0100
@@ -262,9 +262,13 @@
 	if (!after_bootmem)
 		find_early_table_space(end, use_pse, use_gbpages);
 
+#ifndef CONFIG_XM_PARTITION
 	for (i = 0; i < nr_range; i++)
 		ret = kernel_physical_mapping_init(mr[i].start, mr[i].end,
 						   mr[i].page_size_mask);
+#else
+	ret = end;
+#endif
 
 #ifdef CONFIG_X86_32
 	early_ioremap_page_table_range_init();
diff -Nur linux-3.0.34/arch/x86/mm/pgtable.c linux-3.0.34-xm/arch/x86/mm/pgtable.c
--- linux-3.0.34/arch/x86/mm/pgtable.c	2012-06-09 17:33:45.000000000 +0200
+++ linux-3.0.34-xm/arch/x86/mm/pgtable.c	2013-01-13 23:14:55.000000000 +0100
@@ -308,7 +308,7 @@
 	int changed = !pte_same(*ptep, entry);
 
 	if (changed && dirty) {
-		*ptep = entry;
+		set_pte(ptep, entry);
 		pte_update_defer(vma->vm_mm, address, ptep);
 		flush_tlb_page(vma, address);
 	}
@@ -340,9 +340,12 @@
 {
 	int ret = 0;
 
-	if (pte_young(*ptep))
+	if (pte_young(*ptep)) {
+		pte_t aux= *(ptep);
 		ret = test_and_clear_bit(_PAGE_BIT_ACCESSED,
-					 (unsigned long *) &ptep->pte);
+					 (unsigned long *) &aux.pte);
+		set_pte((ptep), aux);
+	}
 
 	if (ret)
 		pte_update(vma->vm_mm, addr, ptep);
diff -Nur linux-3.0.34/arch/x86/xm/head_32.S linux-3.0.34-xm/arch/x86/xm/head_32.S
--- linux-3.0.34/arch/x86/xm/head_32.S	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.0.34-xm/arch/x86/xm/head_32.S	2013-01-13 23:14:54.000000000 +0100
@@ -0,0 +1,38 @@
+/*
+ * $FILE: head_32.S
+ *
+ * Generic boot code, sets up a valid stack and jumps to the C code
+ *
+ * $VERSION$
+ *
+ * Author: Miguel Masmano <mmasmano@ai2.upv.es>
+ *
+ * $LICENSE:
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/linkage.h>
+#include <asm/asm-offsets.h>
+#include <asm/thread_info.h>
+
+.section .init.text, "ax", @progbits
+ENTRY(xm_entry)
+	/* Set up the initial stack so we can run C code. */
+	movl $(init_thread_union+THREAD_SIZE),%esp
+	jmp (xm_start_kernel+__PAGE_OFFSET)
+
+.section ".bss.page_aligned","wa"
+ENTRY(xmPcRom)
+	.zero (96+1+1)*PAGE_SIZE // Pages+1 PGT
diff -Nur linux-3.0.34/arch/x86/xm/irq.c linux-3.0.34-xm/arch/x86/xm/irq.c
--- linux-3.0.34/arch/x86/xm/irq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.0.34-xm/arch/x86/xm/irq.c	2013-01-13 23:14:54.000000000 +0100
@@ -0,0 +1,256 @@
+/*
+ * $FILE: irq.c
+ *
+ * XM irq support functions
+ *
+ * $VERSION$
+ *
+ * Author: Miguel Masmano <mmasmano@ai2.upv.es>
+ *
+ * $LICENSE:
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "virtdrv.h"
+#include <linux/linkage.h>
+#include <linux/ftrace.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <asm/bitops.h>
+#include <linux/cdev.h>
+#include <asm/ptrace.h>
+#include <asm/desc.h>
+#include <asm/hw_irq.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/paravirt.h>
+#include <asm/pgtable.h>
+#include <asm/processor.h>
+#include <asm/setup.h>
+#include <asm/reboot.h>
+
+#define __xm_iflags_sti()  XMAtomicSetMask(IFLAGS_IRQ_MASK, &xmPartCtrTab->iFlags)
+#define __xm_iflags_cli()  XMAtomicClearMask(IFLAGS_IRQ_MASK, &xmPartCtrTab->iFlags)
+#define __xm_restore_iflags(__iflags) XMAtomicSet(&xmPartCtrTab->iFlags, __iflags)
+#define __xm_save_iflags(__iflags)  __iflags=XMAtomicGet(&xmPartCtrTab->iFlags)
+
+#define __xm_save_iflags_cli(__iflags) do { \
+	__xm_save_iflags(__iflags); \
+	__xm_iflags_cli(); \
+} while(0)
+
+static inline void disable_xmpic_irq(struct irq_data *data)
+{
+	long iflags;
+	__xm_save_iflags_cli(iflags);
+	BUG_ON(XM_mask_irq(data->irq) != XM_OK);
+	__xm_restore_iflags(iflags);
+}
+
+static inline void enable_xmpic_irq(struct irq_data *data)
+{
+	long iflags;
+	__xm_save_iflags_cli(iflags);
+	BUG_ON(XM_unmask_irq(data->irq) != XM_OK);
+	__xm_restore_iflags(iflags);	
+}
+
+static struct irq_chip xmpic_chip = {
+	.name		= "XM-PIC",
+	.irq_mask		= disable_xmpic_irq,
+	.irq_disable	= disable_xmpic_irq,
+	.irq_unmask		= enable_xmpic_irq,
+	.irq_mask_ack	= disable_xmpic_irq,
+};
+
+#undef PV_SAVE_ALL_CALLER_REGS
+#define PV_SAVE_ALL_CALLER_REGS	 \
+	"pushl %ebp;" \
+	"pushl %edi;" \
+	"pushl %esi;" \
+	"pushl %edx;" \
+	"pushl %ecx;" \
+	"pushl %ebx;"
+
+#undef PV_RESTORE_ALL_CALLER_REGS
+#define PV_RESTORE_ALL_CALLER_REGS \
+	"popl %ebx;" \
+	"popl %ecx;" \
+	"popl %edx;" \
+	"popl %esi;" \
+	"popl %edi;" \
+	"popl %ebp;"
+
+PV_CALLEE_SAVE_REGS_THUNK(XM_disable_irqs);
+PV_CALLEE_SAVE_REGS_THUNK(XM_enable_irqs);
+
+#define EXT_IRQ_VECTOR 0x90
+
+#ifndef CONFIG_X86_LOCAL_APIC
+int first_system_vector = 0xfe;
+#endif
+
+static void __init virt_init_IRQ(void)
+{
+	extern void (*ext_interrupt[0])(void);
+	unsigned int i;
+
+	for (i = 0; i < HWIRQ_NR; i++)
+		xmPartCtrTab->hwIrq2Vector[i] = i+0x30;
+
+	for (i =  FIRST_EXTERNAL_VECTOR; i < NR_VECTORS; i++) {
+		/* SYSCALL_VECTOR was reserved in trap_init. */
+		if (i != SYSCALL_VECTOR)
+			set_intr_gate(i, interrupt[i-FIRST_EXTERNAL_VECTOR]);
+	}
+	for (i = 0; i  <  (NR_IRQS<32?NR_IRQS:32); i++) {
+		irq_set_chip_and_handler_name(i, &xmpic_chip, handle_level_irq, "level");
+		XM_unmask_irq(i);
+	}
+
+	for (i = 0; i < XM_VT_EXT_MAX; i++) {
+		xmPartCtrTab->extIrq2Vector[i] = EXT_IRQ_VECTOR+i;
+			alloc_intr_gate(EXT_IRQ_VECTOR+i, ext_interrupt[i]);
+	}
+
+	if (XM_ia32_set_idt_desc(SYSCALL_VECTOR, &((genericDesc_t *)XM_params_get_PCT()->arch.idtr.linearBase)[SYSCALL_VECTOR]) < 0)
+		BUG();
+
+	irq_ctx_init(smp_processor_id());
+}
+
+
+static inline unsigned long xm_save_fl(void)
+{
+	unsigned long flags;
+
+	__asm__ __volatile__("pushfl ; popl %0" : "=g" (flags) : /* no input */);
+	if(XM_are_irqs_enabled())
+		return flags|X86_EFLAGS_IF;
+	else
+		return flags&~X86_EFLAGS_IF;
+}
+PV_CALLEE_SAVE_REGS_THUNK(xm_save_fl);
+
+static inline void xm_restore_fl(unsigned long flags)
+{
+	if (flags&X86_EFLAGS_IF)
+		XM_enable_irqs(); //__xm_iflags_sti();
+	else
+		XM_disable_irqs(); //__xm_iflags_cli();
+
+	__asm__ __volatile__(
+		"pushl %0 ; popfl"
+		: /* no output */
+		:"g" (flags)
+		:"memory", "cc"
+	);
+}
+PV_CALLEE_SAVE_REGS_THUNK(xm_restore_fl);
+
+static inline void xm_safe_halt(void)
+{
+	__xm_iflags_sti();
+}
+
+static inline void xm_halt(void)
+{
+}
+
+static inline void xm_restart(char *reason)
+{
+	xprintk("xm_restart reason %s\n", reason);
+	XM_disable_irqs();
+	XM_reset_partition(XM_PARTITION_SELF, XM_COLD_RESET, 1);
+}
+
+inline long __save_iflags(void)
+{
+	long iflags;
+	__xm_save_iflags(iflags);
+	return iflags&IFLAGS_MASK;
+}
+
+inline void __restore_iflags(long iflags)
+{
+	long iflags_tmp;
+	__xm_save_iflags(iflags_tmp);
+	iflags_tmp = (iflags_tmp&~IFLAGS_MASK)|(iflags&IFLAGS_MASK);	
+	__xm_restore_iflags(iflags_tmp);
+}
+
+struct {
+	void (*action)(int, void *);
+	void * data;
+} extIRQhndltab[XM_VT_EXT_MAX] = { [0 ... (XM_VT_EXT_MAX-1)] = {0, 0} };
+
+#define XM_IPVI_ENTRY(ipvi)		((ipvi) - XM_VT_EXT_FIRST)
+int xm_setup_irq(int irq, void (*action)(int, void *), void * data)
+{
+	int vector = XM_IPVI_ENTRY(irq);
+
+	if (!action)
+		return -EINVAL;
+	if (irq < XM_VT_EXT_FIRST || irq > XM_VT_EXT_LAST)
+		return -EINVAL;
+
+	extIRQhndltab[vector].data = data;
+	extIRQhndltab[vector].action = action;
+	XM_unmask_irq(irq);
+	return 0;
+}
+EXPORT_SYMBOL(xm_setup_irq);
+
+int xm_raise_ipvi(int partitionId, int ipvi)
+{
+    return XM_raise_ipvi(partitionId, ipvi);
+}
+EXPORT_SYMBOL(xm_raise_ipvi);
+
+unsigned int __irq_entry do_extIRQ(struct pt_regs *regs)
+{
+	struct pt_regs *old_regs = set_irq_regs(regs);
+	int vector=~regs->orig_ax;
+
+	irq_enter();
+	XM_mask_irq(XM_VT_EXT_FIRST+vector);
+	if (extIRQhndltab[vector].action)
+		extIRQhndltab[vector].action(XM_VT_EXT_FIRST+vector, extIRQhndltab[vector].data);
+	XM_unmask_irq(XM_VT_EXT_FIRST+vector);
+	irq_exit();
+	set_irq_regs(old_regs);
+	return 1;
+}
+
+static const struct pv_irq_ops xm_irq_ops __initdata = {
+	.save_fl = PV_CALLEE_SAVE(xm_save_fl),
+	.restore_fl= PV_CALLEE_SAVE(xm_restore_fl),
+	.irq_disable = PV_CALLEE_SAVE(XM_disable_irqs),
+	.irq_enable = PV_CALLEE_SAVE(XM_enable_irqs),
+	.safe_halt = xm_safe_halt,
+	.halt = xm_halt,
+#ifdef CONFIG_X86_64
+	.adjust_exception_frame = paravirt_nop,
+#endif
+};
+
+__init void init_irq_paravirt(void)
+{
+	pv_irq_ops = xm_irq_ops;
+	if(is_xm_guest())
+		machine_ops.restart = xm_restart;
+	x86_init.irqs.intr_init = virt_init_IRQ;
+}
diff -Nur linux-3.0.34/arch/x86/xm/Kconfig linux-3.0.34-xm/arch/x86/xm/Kconfig
--- linux-3.0.34/arch/x86/xm/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.0.34-xm/arch/x86/xm/Kconfig	2013-01-13 23:14:54.000000000 +0100
@@ -0,0 +1,80 @@
+#
+# This Kconfig describes xtratum options
+#
+
+config XM_PARTITION
+	bool "XM partition support"
+	select PARAVIRT
+	select HVC_DRIVER
+
+	depends on X86_32
+	depends on !X86_PAE
+	depends on !ACPI
+	depends on !CPU_FREQ
+	depends on !CPU_IDLE
+	depends on !SMP
+
+	help
+	  This is the Linux XtratuM port. Enabling this will allow the
+	  kernel to boot in a paravirtualized environment under the
+	  XtratuM hypervisor.
+
+config XM_BOOTCONSOLE
+	bool "Boot Console: Enable a boot console for each partition"
+	default n
+
+	depends on XM_PARTITION
+
+	help
+      This option enables the XtratuM boot console named "xm" which prints the
+      Linux messages displayed during the boot of the Linux kernel for all the partitions.
+      The messages are printed to the XtratuM console using the XM_write_console() hypercall,
+      by each partition are prepended with "[PX] ", where "X" is the partition number.
+      This console is useful to configure and debug driver initialization during boot.
+
+      NOTE: This option should be disabled on the final production system.
+
+config XM_DEBUGCONSOLE
+	bool "Debug Console: Enable a debug console for each partition"
+	default n
+
+	depends on XM_PARTITION
+
+config XM_VIRTSRV
+	tristate "XM virtsrv: virtual services support"
+	default y if XM_PARTITION
+
+	depends on XM_PARTITION
+
+	help
+	  This option provides a device named "/dev/xmctl" which can be accessed
+	  by user programs running on partitions (both host and guest) to perform 
+	  XtratuM hypercalls.
+
+config XM_SPARE_MANAGER
+	bool "XtratuM spare manager"
+	default y
+	
+	depends on XM_PARTITION
+	
+	help
+	  This option depends on a specific XtratuM configuration, including a 
+	  spare host, a sampling port and a specific scheduling plan with spare 
+	  slots. When all this is configured, it allows this Linux to request
+	  more CPU dynamically to the spare host through the sampling port.
+	  
+config XM_RESET
+	bool "XM_RESET: This option enables reset of Linux partitions on XtratuM"
+	default n
+
+	depends on XM_PARTITION
+
+	help
+      In order to reset Linux, the memory of the Linux partition must be the same as
+      provided on first boot. However, some kernel optimizations modify the kernel memory,
+      examples are, freeing the "init.*" section contents (see include/linux/init.h),
+      or the initrd memory (see retain_initrd in Documentation/kernel-parameters.txt).
+      This option disables such optimizations in order to reset the Linux partitions,
+      at the expense of increasing the in-use memory due to not freeing this sections.
+
+source "arch/x86/xm/xmio/Kconfig"
diff -Nur linux-3.0.34/arch/x86/xm/Makefile linux-3.0.34-xm/arch/x86/xm/Makefile
--- linux-3.0.34/arch/x86/xm/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.0.34-xm/arch/x86/xm/Makefile	2013-01-13 23:14:54.000000000 +0100
@@ -0,0 +1,45 @@
+#
+# Makefile for the XtratuM hypevisor
+#
+
+XTRATUM_PATH = /opt/xm-sdk/xm
+LIBXM_INCLUDE=$(XTRATUM_PATH)/include
+LIBXMA_PATH=$(XTRATUM_PATH)/user/libxm.a
+#LIBXM_INCLUDE=$(XTRATUM_PATH)/user/libxm/include
+#LIBXMA_PATH=$(XTRATUM_PATH)/user/libxm/libxm.a
+
+$(if $(wildcard $(LIBXM_INCLUDE) $(LIBXMA_PATH)),,\
+	$(warning "Error: XtratuM not found at "$(XTRATUM_PATH)".")\
+	$(error "Please run: make XTRATUM_PATH=/path/to/xtratum"))
+
+#EXTRA_CFLAGS += -Wunreachable-code
+EXTRA_CFLAGS += -I$(LIBXM_INCLUDE) --include xm_inc/arch/arch_types.h
+EXTRA_CFLAGS += $(call cc-option, -fno-stack-protector)
+CONFIG_XM_BUILDREVISION := '"'$(shell svn info >/dev/null 2>&1 && svn info | awk '/Revision/ {print "r"$$2}' || echo r0)'"'
+EXTRA_CFLAGS += -DCONFIG_XM_BUILDREVISION=${CONFIG_XM_BUILDREVISION}
+
+obj-$(CONFIG_XM_PARTITION)	:= head_32.o setup_32.o processor.o irq.o time.o vmm.o libxm.a
+obj-$(CONFIG_XM_VIRTSRV)	+= virtsrv.o
+
+obj-$(CONFIG_XMIO_SERVER) 	+= xmio/xmio_server.o xmio/xmio_accounting.o # xmioserver.o
+obj-$(CONFIG_XMIO_CLIENT) 	+= xmio/xmio_client.o xmio/xmio_virtio.o xmio/xmio_alloc.o # xmioclient.o
+
+obj-$(CONFIG_XMIO_SERVER) += xmio/xmcon.o
+obj-$(CONFIG_XMIO_SERVER) += xmio/xmblk.o
+obj-$(CONFIG_XMIO_SERVER) += xmio/xmnet.o
+obj-$(CONFIG_XMIO_SERVER) += xmio/xmrng.o
+obj-$(CONFIG_XMIO_SERVER) += xmio/xmrtc.o
+
+HOST_EXTRACFLAGS := -O2 -m32 -Wall -static
+hostprogs-y := usr/xmioctl
+clean-files += $(hostprogs-y)
+always += $(hostprogs-y) libxm.a checkpatch.log
+
+$(src)/libxm.a: $(LIBXMA_PATH) FORCE
+	@echo "  SYMLINK $@ -> $<"
+	@rm -f $@ && ln -s $< $@
+
+$(src)/checkpatch.log: scripts/checkpatch.pl # FORCE
+	@echo "  CALL    $<"
+	@$< --root $(srctree) --file /$(srctree)/$(src)/*.[ch] > $@ || true
+#	indent -npro -linux /$(srctree)/$(src)/*.[ch]
diff -Nur linux-3.0.34/arch/x86/xm/processor.c linux-3.0.34-xm/arch/x86/xm/processor.c
--- linux-3.0.34/arch/x86/xm/processor.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.0.34-xm/arch/x86/xm/processor.c	2013-01-13 23:14:54.000000000 +0100
@@ -0,0 +1,342 @@
+/*
+ * $FILE: processor.c
+ *
+ * processor paravirtualisation
+ *
+ * $VERSION$
+ *
+ * Author: Miguel Masmano <mmasmano@ai2.upv.es>
+ *
+ * $LICENSE:
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "virtdrv.h"
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <asm/bootparam.h>
+#include <asm/processor.h>
+#include <asm/desc.h>
+#include <asm/hw_irq.h>
+#include <asm/e820.h>
+#include <asm/paravirt.h>
+#include <asm/pgtable_32.h>
+#include <asm/pgtable.h>
+#include <asm/setup.h>
+#include <asm/io.h>
+#include <asm/stackprotector.h>
+
+static inline void virt_cpuid(unsigned int *ax, unsigned int *bx, unsigned int *cx, unsigned int *dx) {
+	int function = *ax;
+
+	native_cpuid(ax, bx, cx, dx);
+	switch (function) {
+	case 1: 
+		*cx &= 0x00002000;
+		*dx &= ~(BIT(X86_FEATURE_SEP) |
+                 BIT(X86_FEATURE_PSE36) |
+                 BIT(X86_FEATURE_PSE) |
+                 BIT(X86_FEATURE_ACPI) |
+                 BIT(X86_FEATURE_APIC) |
+                 BIT(X86_FEATURE_PGE) |
+                 BIT(X86_FEATURE_DS));
+		*ax &= 0xFFFFF0FF;
+		*ax |= 0x00000500;
+		break;
+
+	case 0x80000000:
+		if (*ax > 0x80000008)
+			*ax = 0x80000008;
+		break;
+	}
+}
+
+static inline void virt_load_tr_desc(void) {
+	struct tss_struct *t = &per_cpu(init_tss, get_cpu());
+	if (paravirt_get_lazy_mode() == PARAVIRT_LAZY_NONE) {
+		if (XM_write_register32(TSS_REG32, (xmAddress_t)t)<0)
+			BUG();
+	} else {
+		XM_lazy_write_register32(TSS_REG32, (xmAddress_t)t);
+	}
+}
+
+static inline unsigned long virt_read_cr0(void) {
+	return xmPartCtrTab->arch.cr0;
+}
+
+static inline unsigned long virt_read_cr4(void) {
+	return xmPartCtrTab->arch.cr4;	
+}
+
+static inline void virt_write_cr0(unsigned long val) {
+	if (paravirt_get_lazy_mode() == PARAVIRT_LAZY_NONE) {
+		if (XM_write_register32(CR0_REG32, val)<0)
+			BUG();
+	} else {
+		XM_lazy_write_register32(CR0_REG32, val);
+	}
+}
+
+static inline void virt_write_cr4(unsigned long val) {
+	if (paravirt_get_lazy_mode() == PARAVIRT_LAZY_NONE) {
+		if (XM_write_register32(CR4_REG32, val)<0)
+			BUG();
+	} else {
+		XM_lazy_write_register32(CR4_REG32, val);
+	}
+}
+
+static inline unsigned long virt_get_debugreg(int regno) {
+	return 0;
+}
+
+static inline void virt_set_debugreg(int regno, unsigned long value) {
+}
+
+static inline void virt_wbinvd(void) {
+	if(is_xm_guest())
+		return;
+
+	if (paravirt_get_lazy_mode() == PARAVIRT_LAZY_NONE) {
+		if (XM_write_register32(WBINVD_REG32, 0)<0)
+			BUG();
+	} else
+		XM_lazy_write_register32(WBINVD_REG32, 0);
+}
+
+static inline void virt_load_idt(const struct desc_ptr *desc) {
+	XM_ia32_save_idtr((pseudoDesc_t *)desc);
+}
+
+static inline void virt_clts(void) {
+	virt_write_cr0((virt_read_cr0()&~X86_CR0_TS));
+}
+
+static inline void virt_load_gdt(const struct desc_ptr *desc) {
+	if (paravirt_get_lazy_mode() == PARAVIRT_LAZY_NONE) {
+		if (XM_write_register32(GDT_REG32, (unsigned long)desc)<0)
+			BUG();
+	} else{
+		XM_lazy_write_register32(GDT_REG32, (unsigned long)desc);
+	}
+}
+
+static inline void virt_load_tls(struct thread_struct *t, unsigned int cpu) {
+	struct desc_struct *gdt = get_cpu_gdt_table(cpu);
+	unsigned short new_gs = 0;
+	unsigned int i;
+
+	loadsegment(gs, new_gs);
+	for (i = 0; i < GDT_ENTRY_TLS_ENTRIES; i++) {
+		gdt[GDT_ENTRY_TLS_MIN + i] = t->tls_array[i];
+		if (paravirt_get_lazy_mode() == PARAVIRT_LAZY_NONE) {
+			if (XM_ia32_update_sys_struct(IA32_UPDATE_GDT, GDT_ENTRY_TLS_MIN + i, (unsigned long)&gdt[GDT_ENTRY_TLS_MIN + i])<0)
+				BUG();
+		} else {
+			XM_lazy_ia32_update_sys_struct(IA32_UPDATE_GDT, GDT_ENTRY_TLS_MIN + i, (unsigned long)&gdt[GDT_ENTRY_TLS_MIN + i]);
+		}
+	}
+}
+
+static inline u64 virt_read_msr(unsigned int msr, int *err) {
+	u32 low=0, high=0;
+	if (is_xm_guest())
+		return 0;
+	if(XM_write_register64(RDMSR_REG64, msr, (u32)&high, (u32)&low) != XM_OK)
+		BUG();
+	return ((u64)(high)<<32)|(u64)low;
+}
+
+static inline int virt_write_msr(unsigned int msr, unsigned low, unsigned high) {
+	if (is_xm_guest())
+		return 0;
+	if(XM_write_register64(WRMSR_REG64, msr, high, low) != XM_OK)
+		BUG();
+	return 0;
+}
+
+static inline void virt_set_ldt(const void *addr, unsigned entries) {
+}
+
+static inline void virt_load_sp0(struct tss_struct *tss, struct thread_struct *thread) {
+	tss->x86_tss.sp1 = thread->sp0;
+	if (paravirt_get_lazy_mode() == PARAVIRT_LAZY_NONE) {
+		if (XM_ia32_update_sys_struct(IA32_UPDATE_SSESP1, tss->x86_tss.ss1, tss->x86_tss.sp1)<0)
+			BUG();
+	} else {
+		XM_lazy_ia32_update_sys_struct(IA32_UPDATE_SSESP1, tss->x86_tss.ss1, tss->x86_tss.sp1);
+	}
+}
+
+static inline void virt_end_context_switch(struct task_struct *next)
+{
+	XM_flush_hyp_batch();
+	paravirt_end_context_switch(next);
+}
+
+static inline void virt_io_delay(void)
+{
+}
+
+static inline __init void init_processor(void) {
+	struct desc_ptr gdt_descr;
+	struct desc_struct *gdt = get_cpu_gdt_table(get_cpu());
+
+	cpu_detect(&new_cpu_data);
+	new_cpu_data.x86_capability[0] = cpuid_edx(1);
+
+	/* Math is always hard! */
+	new_cpu_data.hard_math = 1;
+
+	(gdt[GDT_ENTRY_KERNEL_CS]).a = 0x0000bfff;
+	(gdt[GDT_ENTRY_KERNEL_CS]).b = 0x00cfba00;
+
+	(gdt[GDT_ENTRY_KERNEL_DS]).a = 0x0000bfff;
+	(gdt[GDT_ENTRY_KERNEL_DS]).b = 0x00cfb200;
+	
+	(gdt[GDT_ENTRY_DEFAULT_USER_CS]).a = 0x0000bfff;
+	(gdt[GDT_ENTRY_DEFAULT_USER_CS]).b = 0x00cffa00;
+	
+	(gdt[GDT_ENTRY_DEFAULT_USER_DS]).a = 0x0000bfff;
+	(gdt[GDT_ENTRY_DEFAULT_USER_DS]).b = 0x00cff200;
+
+	(gdt[GDT_ENTRY_PNPBIOS_CS32]).a = 0x0000ffff;
+	(gdt[GDT_ENTRY_PNPBIOS_CS32]).b = 0x0040ba00;
+	
+	(gdt[GDT_ENTRY_PNPBIOS_CS16]).a = 0x0000ffff;
+	(gdt[GDT_ENTRY_PNPBIOS_CS16]).b = 0x0000ba00;
+	
+	(gdt[GDT_ENTRY_PNPBIOS_DS]).a = 0x0000ffff;
+	(gdt[GDT_ENTRY_PNPBIOS_DS]).b= 0x0000b200;
+	
+	(gdt[GDT_ENTRY_PNPBIOS_TS1]).a = 0x0;
+	(gdt[GDT_ENTRY_PNPBIOS_TS1]).b= 0x0000b200;
+	
+	(gdt[GDT_ENTRY_PNPBIOS_TS2]).a = 0x0;
+	(gdt[GDT_ENTRY_PNPBIOS_TS2]).b = 0x0000b200;
+
+	(gdt[GDT_ENTRY_APMBIOS_BASE]).a = 0x0000ffff;
+	(gdt[GDT_ENTRY_APMBIOS_BASE]).b = 0x0040ba00;
+
+	(gdt[GDT_ENTRY_APMBIOS_BASE+1]).a = 0x0000ffff;
+	(gdt[GDT_ENTRY_APMBIOS_BASE+1]).b = 0x0000ba00;
+
+	(gdt[GDT_ENTRY_APMBIOS_BASE+2]).a = 0x0000ffff;
+	(gdt[GDT_ENTRY_APMBIOS_BASE+2]).b = 0x0040b200;
+	
+	(gdt[GDT_ENTRY_APMBIOS_BASE+2]).a = 0x0;
+	(gdt[GDT_ENTRY_APMBIOS_BASE+2]).b = 0x00c0b200;
+	
+	per_cpu(init_tss, get_cpu()).x86_tss = (struct x86_hw_tss){
+		.sp1 = sizeof(init_stack)+(long)&init_stack,
+		.ss1 = __KERNEL_DS|1,
+		.ss2 = __KERNEL_CS|1,
+		.io_bitmap_base = IO_BITMAP_OFFSET,
+	};
+	
+	memset((char *)per_cpu(init_tss, get_cpu()).io_bitmap, 0, IO_BITMAP_LONGS*sizeof(unsigned long));
+	__set_tss_desc(0, GDT_ENTRY_TSS, &per_cpu(init_tss, get_cpu()));
+
+	gdt_descr.address = (long)get_cpu_gdt_table(0);
+	gdt_descr.size = GDT_SIZE - 1;
+
+	load_gdt(&gdt_descr);
+	__asm__ __volatile__ ("movl $"TO_STR(__KERNEL_DS|1)", %%eax\n\t" \
+				"movl %%eax, %%ds\n\t" \
+				"movl %%eax, %%ss\n\t" \
+				"movl %%eax, %%es\n\t"			   \
+				"ljmp $"TO_STR(__KERNEL_CS|1)", $1f\n\t" \
+				"1:\n\t" ::);
+}
+
+/* These are in kernel/entry.S */
+extern void native_iret(void);
+extern void native_irq_enable_sysexit(void);
+extern void native_usergs_sysret32(void);
+extern void native_usergs_sysret64(void);
+
+extern void XM_iret(void);
+
+static const struct pv_cpu_ops xm_cpu_ops __initdata = {
+	.cpuid = virt_cpuid,
+	.set_debugreg = virt_set_debugreg,
+	.get_debugreg = virt_get_debugreg,
+	.clts = virt_clts,
+	.read_cr0 = virt_read_cr0,
+	.write_cr0 = virt_write_cr0,
+	.read_cr4 = virt_read_cr4,
+	.read_cr4_safe = virt_read_cr4,
+	.write_cr4 = virt_write_cr4,
+#ifdef CONFIG_X86_64
+	.read_cr8 = native_read_cr8,
+	.write_cr8 = native_write_cr8,
+#endif
+	.wbinvd = virt_wbinvd,
+	.read_msr = virt_read_msr,
+	.write_msr = virt_write_msr,
+	.read_tsc = native_read_tsc,
+	.read_pmc = native_read_pmc,
+	.read_tscp = native_read_tscp,
+	.load_tr_desc = virt_load_tr_desc,
+	.set_ldt = virt_set_ldt,
+	.load_gdt = virt_load_gdt,
+	.load_idt = virt_load_idt,
+	.store_gdt = native_store_gdt,
+	.store_idt = native_store_idt,
+	.store_tr = native_store_tr,
+	.load_tls = virt_load_tls,
+
+	
+#ifdef CONFIG_X86_64
+	.load_gs_index = native_load_gs_index,
+#endif
+	.write_ldt_entry = native_write_ldt_entry,
+	.write_gdt_entry = native_write_gdt_entry,
+	.write_idt_entry = native_write_idt_entry,
+
+	.alloc_ldt = paravirt_nop,
+	.free_ldt = paravirt_nop,
+
+	.load_sp0 = virt_load_sp0,
+
+#if defined(CONFIG_X86_32) || defined(CONFIG_IA32_EMULATION)
+	.irq_enable_sysexit = native_irq_enable_sysexit,
+#endif
+#ifdef CONFIG_X86_64
+#ifdef CONFIG_IA32_EMULATION
+	.usergs_sysret32 = native_usergs_sysret32,
+#endif
+	.usergs_sysret64 = native_usergs_sysret64,
+#endif
+	.iret = XM_iret,
+	.swapgs = native_swapgs,
+
+	.set_iopl_mask = native_set_iopl_mask,
+	.io_delay = virt_io_delay,
+
+    .start_context_switch = paravirt_start_context_switch,
+    .end_context_switch = virt_end_context_switch,
+};
+
+__init void init_cpu_paravirt(void) {
+
+	pv_cpu_ops = xm_cpu_ops;
+
+	init_processor();
+	setup_stack_canary_segment(0);
+	switch_to_new_gdt(0);
+}
diff -Nur linux-3.0.34/arch/x86/xm/setup_32.c linux-3.0.34-xm/arch/x86/xm/setup_32.c
--- linux-3.0.34/arch/x86/xm/setup_32.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.0.34-xm/arch/x86/xm/setup_32.c	2013-01-13 23:14:54.000000000 +0100
@@ -0,0 +1,309 @@
+/*
+ * $FILE: setup_32.c
+ *
+ * XM partition code
+ *
+ * $VERSION$
+ *
+ * Author: Miguel Masmano <mmasmano@ai2.upv.es>
+ *
+ * $LICENSE:
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "virtdrv.h"
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/timer.h>
+#include <linux/virtio_console.h>
+#include <linux/console.h>
+
+#include <asm/setup.h>
+#include <asm/pgtable.h>
+
+partitionInformationTable_t *xmPartInfTab;
+partitionControlTable_t *xmPartCtrTab;
+
+EXPORT_SYMBOL(xmPartInfTab);
+EXPORT_SYMBOL(xmPartCtrTab);
+EXPORT_SYMBOL(libXmParams);
+EXPORT_SYMBOL(XM_get_physmem_map);
+
+#ifdef CONFIG_XM_SPARE_MANAGER
+
+#define SPARE_USAGE_MEASURE_DELTA 6000
+#define SPARE_USAGE_TIMER_EXPIRES 6
+
+struct xm_spare {
+    char port_name[256];
+    unsigned int port_size;
+    int port_desc;
+    unsigned int slot_usage;
+};
+
+/* Current message */
+struct spareMsg {
+    xm_u32_t usage;
+    xm_u32_t sequence;
+};
+
+static struct xm_spare xm_spare;
+static struct spareMsg msg;
+static xm_u32_t t_busy, t_idle;
+static xmTime_t start_idle, start_busy;
+static struct timer_list spare_timer;
+
+static void xm_update_usage(void)
+{
+    xm_spare.slot_usage = t_busy*1000 / (t_busy + t_idle);
+    msg.usage = xm_spare.slot_usage;
+    msg.sequence++;
+    XM_write_sampling_message(xm_spare.port_desc, &msg, sizeof(struct spareMsg));
+    t_busy = t_idle = 0;
+    if (spare_timer.function) {
+        mod_timer(&spare_timer, jiffies + msecs_to_jiffies(SPARE_USAGE_TIMER_EXPIRES));
+    }
+}
+
+void xm_start_idle(void)
+{
+    xmTime_t now;
+    XM_get_time(XM_EXEC_CLOCK, &now);
+    t_busy += now - start_busy;
+    start_idle = now;
+    if (t_idle + t_busy > SPARE_USAGE_MEASURE_DELTA) {
+        xm_update_usage();
+    }
+}
+
+void xm_stop_idle(void)
+{
+    xmTime_t now;
+    XM_get_time(XM_EXEC_CLOCK, &now);
+    t_idle += now - start_idle;
+    start_busy = now;
+    if (t_idle + t_busy > SPARE_USAGE_MEASURE_DELTA) {
+        xm_update_usage();
+    }
+}
+
+void xm_spare_timer_handler(unsigned long data)
+{
+    xmTime_t now;
+    XM_get_time(XM_EXEC_CLOCK, &now);
+    if (start_busy > start_idle) {
+        t_busy += now - start_busy;
+        start_busy = now;
+    } else {
+        t_idle += now - start_idle;
+        start_idle = now;
+    }
+    xm_update_usage();
+}
+
+static __init int xm_init_spare(void) {
+    printk("XtratuM: Initializing spare manager (%s, %d)... ", xm_spare.port_name, xm_spare.port_size);
+    xm_spare.port_desc = XM_create_sampling_port(xm_spare.port_name, xm_spare.port_size, XM_SOURCE_PORT);
+    if (xm_spare.port_desc < 0) {
+        printk("Failed (port)\n");
+        return -1;
+    }
+
+    setup_timer(&spare_timer, xm_spare_timer_handler, 0);
+    if (mod_timer(&spare_timer, jiffies + msecs_to_jiffies(SPARE_USAGE_TIMER_EXPIRES))) {
+        printk("Failed (timer)\n");
+        return -1;
+    }
+    xm_spare.slot_usage = 0;
+    printk("Done\n");
+    return 0;
+}
+
+static int __init spare_port_name_setup(char *name)
+{
+    strncpy(xm_spare.port_name, name, 256);
+    printk("XtratuM: Setting spare port name (%s)\n", xm_spare.port_name);
+    return 1;
+}
+__setup("spare_port_name=", spare_port_name_setup);
+
+static int __init spare_port_size_setup(char *size)
+{
+    xm_spare.port_size = simple_strtoul(size, NULL, 0);
+    printk("XtratuM: Setting spare port size (%d)\n", xm_spare.port_size);
+    return 1;
+}
+__setup("spare_port_size=", spare_port_size_setup);
+#endif
+
+static __init char *virt_memory_setup(void) {
+	struct xmcMemoryArea memAreas[xmPartInfTab->noPhysicalMemoryAreas];
+	int e;
+
+	e = XM_get_physmem_map(memAreas, xmPartInfTab->noPhysicalMemoryAreas);
+	BUG_ON(e != xmPartInfTab->noPhysicalMemoryAreas);
+
+	for (e = 0; e<xmPartInfTab->noPhysicalMemoryAreas; e++) {
+		if (memAreas[e].flags&XM_MEM_AREA_FLAG0) continue;
+		if (memAreas[e].flags&XM_MEM_AREA_FLAG1) continue;
+		if (memAreas[e].flags&XM_MEM_AREA_FLAG2) continue;
+		if (memAreas[e].flags&XM_MEM_AREA_FLAG3) continue;
+		if (memAreas[e].flags&XM_MEM_AREA_ROM) continue;
+		e820_add_region(memAreas[e].startAddr, memAreas[e].size, E820_RAM);
+	}
+	return "XM";
+}
+
+static unsigned virt_patch(u8 type, u16 clobber, void *ibuf, unsigned long addr, unsigned len) {
+	return len;
+}
+
+#ifdef CONFIG_XM_BOOTCONSOLE
+static char xmcon_buffer[1024];
+static void xmboot_write_console(struct console *console, const char *string, unsigned len)
+{
+    unsigned int i, k;
+    static int newline=1;
+
+    k = 0;
+    if (newline) {
+        k = sprintf(xmcon_buffer, "[P%d] ", XM_PARTITION_SELF);
+        newline = 0;
+    }
+    for (i=0; i<len; ++i, ++k) {
+        xmcon_buffer[k] = string[i];
+        if (string[i] == '\n') {
+            if (i == (len-1)) {
+                newline = 1;
+            } else {
+                k += sprintf(xmcon_buffer+k, "[P%d] ", XM_PARTITION_SELF);
+            }
+        }
+    }
+    XM_write_console(xmcon_buffer, k);
+}
+
+static struct console xmboot_console = {
+	.name		= "xm",
+	.write		= xmboot_write_console,
+#ifdef CONFIG_XM_DEBUGCONSOLE
+	.flags		= CON_PRINTBUFFER | CON_ANYTIME,
+#else
+	.flags		= CON_PRINTBUFFER | CON_ANYTIME | CON_BOOT,
+#endif
+};
+#endif
+
+/* only used for debugging */
+int xprintk(const char *fmt, ...)
+{
+	int n;
+	char buf[512];
+	va_list ap;
+
+	va_start(ap, fmt);
+	n = vsnprintf(buf, sizeof(buf), fmt, ap);
+	va_end(ap);
+#ifdef CONFIG_XM_BOOTCONSOLE
+	xmboot_write_console(0, buf, n);
+#else
+	XM_write_console(buf, n);
+#endif
+	return n;
+}
+EXPORT_SYMBOL(xprintk);
+
+static __init void xm_init_boot_params(void)
+{
+    memset(&boot_params.screen_info, 0, sizeof(boot_params.screen_info));
+    if (!is_xm_guest()) {
+        boot_params.screen_info.orig_x = 0;
+        boot_params.screen_info.orig_y = 0;
+        boot_params.screen_info.orig_video_page = 8;
+        boot_params.screen_info.orig_video_mode = 3;
+        boot_params.screen_info.orig_video_cols = 80;
+        boot_params.screen_info.orig_video_ega_bx = 3;
+        boot_params.screen_info.orig_video_lines = 25;
+        boot_params.screen_info.orig_video_isVGA = 1;
+        boot_params.screen_info.orig_video_points = 16;
+    }
+}
+struct pv_info xm_pv_info = {
+	.name = "xm",
+	.kernel_rpl = 1,
+	.paravirt_enabled = 1,
+	.shared_kernel_pmd = 1,
+};
+
+asmlinkage void __init xm_start_kernel(void){
+	struct xmPartitionHdr *xmPartitionHdr = (struct xmPartitionHdr *)((u32)boot_params.hdr.hardware_subarch_data);
+
+	BUG_ON(!xmPartitionHdr);
+
+	xmPartCtrTab = __va(xmPartitionHdr->partitionControlTable);
+	xmPartInfTab = __va(xmPartitionHdr->partitionInformationTable);
+
+	BUG_ON(!xmPartCtrTab || !xmPartInfTab);
+	BUG_ON(xmPartCtrTab->magic != KTHREAD_MAGIC);
+	BUG_ON(xmPartInfTab->signature != PARTITION_INFORMATION_TABLE_SIGNATURE);
+
+	init_libxm(xmPartCtrTab, xmPartInfTab);
+
+	xm_init_boot_params();
+    
+	pv_info = xm_pv_info;
+	pv_init_ops.patch = virt_patch;
+	x86_init.resources.memory_setup = virt_memory_setup;
+
+	/*
+	 * The IDE code spends about 3 seconds probing for disks: if we reserve
+	 * all the I/O ports up front it can't get them and so doesn't probe.
+	 */
+	if(is_xm_guest())
+		paravirt_disable_iospace();
+
+	init_cpu_paravirt();
+	init_irq_paravirt();
+	init_vmm_paravirt(__va(xmPartitionHdr->pagTabAddr), xmPartitionHdr->pagTabSize/PAGE_SIZE);
+	init_time_paravirt();
+
+	lockdep_init();
+#ifdef CONFIG_XM_BOOTCONSOLE
+	register_console(&xmboot_console);
+	add_preferred_console("xm", 0, NULL);
+#endif
+	add_preferred_console("tty", 0, NULL);
+	if (is_xm_guest()) {
+	    add_preferred_console("hvc", 0, NULL);
+	}
+
+	i386_start_kernel();
+}
+
+static int __init xm_switch_plan(void) {
+	int err;
+
+	if (is_xm_guest())
+		return 0;
+	err=XM_set_plan(1);
+	printk("XtratuM: Switching to production plan ... %s\n", (err ? "FAILED": "OK"));
+	return 0;
+}
+late_initcall(xm_switch_plan);
+
+#ifdef CONFIG_XM_SPARE_MANAGER
+late_initcall(xm_init_spare);
+#endif
diff -Nur linux-3.0.34/arch/x86/xm/time.c linux-3.0.34-xm/arch/x86/xm/time.c
--- linux-3.0.34/arch/x86/xm/time.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.0.34-xm/arch/x86/xm/time.c	2013-01-13 23:14:54.000000000 +0100
@@ -0,0 +1,142 @@
+/*
+ * $FILE: time.c
+ *
+ * time emulation
+ *
+ * $VERSION$
+ *
+ * Author: Miguel Masmano <mmasmano@ai2.upv.es>
+ *
+ * $LICENSE:
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "virtdrv.h"
+#include <linux/clockchips.h>
+#include <linux/spinlock.h>
+#include <linux/jiffies.h>
+#include <linux/sysdev.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+
+#include <asm/smp.h>
+#include <asm/delay.h>
+#include <asm/i8253.h>
+#include <asm/time.h>
+#include <asm/timer.h>
+#include <asm/setup.h>
+
+static void xmpit_clockevent_set_mode(enum clock_event_mode mode,
+					struct clock_event_device *evt)
+{
+	switch (mode) {
+	case CLOCK_EVT_MODE_PERIODIC:
+		break;  /* unsupported */
+
+	case CLOCK_EVT_MODE_ONESHOT:
+	case CLOCK_EVT_MODE_RESUME:
+		break;
+
+	case CLOCK_EVT_MODE_UNUSED:
+	case CLOCK_EVT_MODE_SHUTDOWN:
+		XM_set_timer(XM_HW_CLOCK, 0, 0);  /* cancel timeout */
+		break;
+	}
+}
+
+static xmTime_t get_absolute_time(unsigned long delta)
+{
+	xmTime_t t;
+	XM_get_time(XM_HW_CLOCK, &t);
+	t += (delta/NSEC_PER_USEC);
+    return t;
+}
+
+static int xmpit_clockevent_set_next_event(unsigned long delta,
+					struct clock_event_device *evt)
+{
+	WARN_ON(evt->mode != CLOCK_EVT_MODE_ONESHOT);
+
+	if (XM_set_timer(XM_HW_CLOCK, get_absolute_time(delta), 0) != XM_OK)
+		WARN_ON(1);
+	return 0;
+}
+
+#define XM_CLOCK_MIN_DELTA 50000UL
+#define XM_CLOCK_MAX_DELTA ULONG_MAX
+
+static struct clock_event_device xmpit_clockevent = {
+	.name					= "xm-pit",
+	.features				= CLOCK_EVT_FEAT_ONESHOT,
+	.set_next_event			= xmpit_clockevent_set_next_event,
+	.set_mode				= xmpit_clockevent_set_mode,
+	.rating					= INT_MAX,
+	.mult					= 1,
+	.shift					= 0,
+	.min_delta_ns			= XM_CLOCK_MIN_DELTA,
+	.max_delta_ns			= XM_CLOCK_MAX_DELTA,
+};
+
+static cycle_t xmpit_clock_read(struct clocksource *cs) {
+	xmTime_t t;
+	XM_get_time(XM_HW_CLOCK, &t);
+	return t*1000ULL;
+}
+
+#define XM_SHIFT 22
+static struct clocksource xmpit_clock = {
+	.name		= "xm-clock",
+	.rating		= 200,
+	.read		= xmpit_clock_read,
+	.mask		= ~0,
+	.mult		= 1<<XM_SHIFT,
+	.shift		= XM_SHIFT,
+	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+static void xmpit_time_irq(int vector, void * data) {
+	unsigned long flags;
+	/* Don't interrupt us while this is running. */
+	local_irq_save(flags);
+	xmpit_clockevent.event_handler(&xmpit_clockevent);
+	local_irq_restore(flags);
+}
+
+static unsigned long virt_get_tsc_khz(void) {
+	return xmPartInfTab->cpuKhz;
+}
+
+static unsigned long virt_get_wallclock(void) {
+	return 0;
+}
+
+static void __init virt_time_init(void) {
+	clocksource_register(&xmpit_clock);
+	xmpit_clockevent.cpumask = cpumask_of(0);
+	clockevents_register_device(&xmpit_clockevent);
+	xm_setup_irq(XM_VT_EXT_HW_TIMER, xmpit_time_irq, NULL);
+}
+
+static const struct pv_time_ops xm_time_ops __initdata = {
+	.sched_clock = native_sched_clock,
+};
+
+__init void init_time_paravirt(void) {
+	pv_time_ops = xm_time_ops;
+	x86_init.timers.timer_init = virt_time_init;
+	x86_platform.calibrate_tsc = virt_get_tsc_khz;
+	x86_platform.get_wallclock = virt_get_wallclock;
+}
diff -Nur linux-3.0.34/arch/x86/xm/usr/xmioctl.c linux-3.0.34-xm/arch/x86/xm/usr/xmioctl.c
--- linux-3.0.34/arch/x86/xm/usr/xmioctl.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.0.34-xm/arch/x86/xm/usr/xmioctl.c	2013-01-13 23:30:53.000000000 +0100
@@ -0,0 +1,133 @@
+/*
+ * FILE: xmioctl.c
+ *
+ * User functions to provide devices to clients
+ *
+ * Author: Jordi Sánchez, <jsanchez@ai2.upv.es>
+ * Changes: Salva Peiró, <speiro@ai2.upv.es>
+ *
+ * $LICENSE:
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <sys/types.h>
+#include <sys/ioctl.h>
+
+#include "../xmio/xmio.h"
+
+#define EPRINT(str, ...) if(1){ printf(str, ## __VA_ARGS__); exit(-1); }
+#define NELEM(ary)  (sizeof(ary)/sizeof(ary[0]))
+
+static char *xmio_id_str[XMIO_ID_MAX] = {
+    [0]               = "",
+    [XMIO_ID_NETWORK] = "net",
+    [XMIO_ID_BLOCK]   = "blk",
+    [XMIO_ID_CONSOLE] = "con",
+    [XMIO_ID_RNG]     = "rng",
+    [XMIO_ID_BALLOON] = "bal",
+    [XMIO_ID_RTC]     = "rtc",
+    [XMIO_ID_EVENT]   = "evt",
+    [XMIO_ID_FB]      = "fb",
+    [XMIO_ID_9P]      = "9p",
+};
+
+static int get_dev(char *str)
+{
+    int i;
+    for (i = 0; i < NELEM(xmio_id_str)-1; i++)
+    {
+        if(strncmp(str, xmio_id_str[i], 3) == 0)
+            return i;
+    }
+    return -1;
+}
+
+#define OPTFLAGS "b:d:f:i:l:o:s"
+#define USAGE \
+    "usage: xmioctl -[od] <type> [-s] [-f file] [-i id] [-b bandwidth] </dev/xmcli>\n"\
+    "\tDevice types: net, con, blk, rtc, rng, 9p, bal, fb\n"
+
+int main(int argc, char **argv)
+{
+    char c;
+    int cmd, clientfd, ret;
+    char *client;
+    struct xmio_args args = {
+        .type = 0,
+        .file = NULL,
+        .bandwidth = 1,
+        .param = 0,
+    };
+
+    if (argc < 3) {
+        EPRINT(USAGE);
+    }
+
+    cmd = -1;
+    while ((c = getopt(argc, argv, OPTFLAGS)) != -1) {
+        switch (c) {
+            case 'b':
+                args.bandwidth = atoi(optarg);
+                break;
+            case 'd':
+                cmd = XMIOCTL_CMD_DETACH;
+                args.type = get_dev(optarg);
+                break;
+            case 'f':
+                args.file = optarg;
+                break;
+            case 'i':
+                args.param = atoi(optarg);
+                break;
+            case 'l':
+                cmd = XMIOCTL_CMD_STATUS;
+                break;
+            case 'o':
+                cmd = XMIOCTL_CMD_OFFER;
+                args.type = get_dev(optarg);
+                break;
+            case 's':
+                cmd = XMIOCTL_CMD_FOCUS;
+                break;
+        }
+    }
+
+    if(cmd < 0) {
+        EPRINT(USAGE);
+    }
+
+    if(args.type < 0 || args.type > NELEM(xmio_id_str)) {
+        EPRINT(USAGE);
+    }
+
+    client = argv[argc-1];
+    if ((clientfd=open(client, O_RDWR)) < 0) {
+        EPRINT("error: open %s: %s\n", client, strerror(errno));
+    }
+
+    if ((ret=ioctl(clientfd, cmd, &args)) < 0) {
+        EPRINT("error: xmio ioctl %s\n", strerror(errno));
+    }
+
+    close(clientfd);
+    return 0;
+}
diff -Nur linux-3.0.34/arch/x86/xm/virtdrv.h linux-3.0.34-xm/arch/x86/xm/virtdrv.h
--- linux-3.0.34/arch/x86/xm/virtdrv.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.0.34-xm/arch/x86/xm/virtdrv.h	2013-01-13 23:14:54.000000000 +0100
@@ -0,0 +1,70 @@
+/*
+ * $FILE: virtdrv.h
+ *
+ * Virtual drivers definitions
+ *
+ * $VERSION$
+ *
+ * Author: Miguel Masmano <mmasmano@ai2.upv.es>
+ * Modified: Salva Peiró <speiro@ai2.upv.es>
+ *
+ * $LICENSE:
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _VIRTDRV_H_
+#define _VIRTDRV_H_
+
+#include <linux/init.h>
+#include <asm/paravirt.h>
+#include <xm.h>
+#include <xm_inc/arch/physmm.h>
+
+extern partitionInformationTable_t *xmPartInfTab;
+extern partitionControlTable_t *xmPartCtrTab;
+
+static inline int is_xm_guest(void) { return ((!xmPartInfTab || xmPartInfTab->id) != 0); }
+
+static inline int get_memarea_by_flag(int flag, int idx, unsigned long *addr, unsigned long *size) {
+	struct xmcMemoryArea memAreas[xmPartInfTab->noPhysicalMemoryAreas];
+	int e, i, n;
+
+	n = XM_get_physmem_map(memAreas, xmPartInfTab->noPhysicalMemoryAreas);
+	if (n != xmPartInfTab->noPhysicalMemoryAreas)
+		return -1;
+
+	for (e=0, i=0; e<n; e++){
+		if (memAreas[e].flags&flag) {
+			if(i++ == idx){
+				*addr=memAreas[e].startAddr;
+				*size=memAreas[e].size;
+				return e;
+			}
+		}
+	}
+	return -1;
+}
+
+extern void __init init_irq_paravirt(void);
+extern void __init init_time_paravirt(void);
+extern void __init init_cpu_paravirt(void);
+extern void __init init_vmm_paravirt(unsigned long *pgd, int noPg);
+
+extern int xm_setup_irq(int irq, void (*action)(int, void *), void * data);
+extern int xm_raise_ipvi(int partitionId, int ipvi);
+
+extern int xprintk(const char *fmt, ...);
+
+#endif
diff -Nur linux-3.0.34/arch/x86/xm/virtsrv.c linux-3.0.34-xm/arch/x86/xm/virtsrv.c
--- linux-3.0.34/arch/x86/xm/virtsrv.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.0.34-xm/arch/x86/xm/virtsrv.c	2013-01-13 23:14:54.000000000 +0100
@@ -0,0 +1,143 @@
+/*
+ * $FILE: virtsrv.c
+ *
+ * Virtual services for Linux
+ *
+ * $VERSION$
+ *
+ * Author: Salva Peiro <speiro@ai2.upv.es>
+ *
+ * $LICENSE:
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "virtdrv.h"
+#include <linux/miscdevice.h>
+#include <linux/errno.h>
+#include <linux/cdev.h>
+#include <linux/netdevice.h>
+
+static DEFINE_SEMAPHORE(virtsrv_sem);
+
+static long virtsrv_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	int ret;
+	unsigned long c, a[5];
+
+	c = _IOC_NR(cmd);
+	if (_IOC_TYPE(cmd) != 'X' || c >= NR_HYPERCALLS+1)
+		return -EINVAL;
+
+	ret = copy_from_user(a, (char*)arg, sizeof(a));
+	if (ret != 0)
+		return -EFAULT;
+
+	pr_debug("virtsrv_ioctl cmd %#lx arg %#lx %#lx %#lx %lx %lx\n",
+		c, a[0], a[1], a[2], a[3], a[4]);
+
+	/*
+	 * ioctl encoding:
+	 * - cmd: encodes the XM_hypercall number
+	 * - arg: encodes the XM_hypercall arguments (0..5 args)
+	 */
+
+	if (down_interruptible(&virtsrv_sem))
+		return -ERESTARTSYS;
+
+	switch(c){
+	default:
+		ret = -EINVAL;
+		break;
+
+	/* ordered by hypercall nr */
+	case halt_partition_nr:
+		ret = XM_halt_partition(a[0]);
+		break;
+	case suspend_partition_nr:
+		ret = XM_suspend_partition(a[0]);
+		break;
+	case resume_partition_nr:
+		ret = XM_resume_partition(a[0]);
+		break;
+	case reset_partition_nr:
+		ret = XM_reset_partition(a[0], a[1], a[2]);
+		break;
+	case shutdown_partition_nr:
+		ret = XM_shutdown_partition(a[0]);
+		break;
+
+	case halt_system_nr:
+		ret = XM_halt_system();
+		break;
+	case reset_system_nr:
+		ret = XM_reset_system(a[0]);
+		break;
+	case idle_self_nr:
+		ret = XM_idle_self();
+		break;
+
+	case get_time_nr:
+		ret = XM_get_time(a[0], (xmTime_t*)a[1]);
+		break;
+	case set_timer_nr:
+		ret = XM_set_timer(a[0], a[1], a[2]);
+		break;
+	
+	case read_object_nr:
+		ret = XM_read_object(a[0], (char*)a[1], a[2], (xm_u32_t*)a[3]);
+		break;
+	case write_object_nr:
+		ret = XM_write_object(a[0], (char*)a[1], a[2], (xm_u32_t*)a[3]);
+		break;
+	case seek_object_nr:
+		ret = XM_seek_object(a[0], a[1], a[2]);
+		break;
+	case ctrl_object_nr:
+		ret = XM_ctrl_object(a[0], a[1], (char*)a[2]);
+		break;
+	
+	/* get libXmParam XM_PARTITION_SELF */
+	case NR_HYPERCALLS:
+		ret = XM_PARTITION_SELF;
+		break;
+	}
+
+	up(&virtsrv_sem);
+	return ret;
+}
+
+static struct file_operations virtsrv_fops = {
+	.owner = THIS_MODULE,
+	.unlocked_ioctl = virtsrv_ioctl,
+};
+
+static struct miscdevice virtsrv_dev =	{
+	MISC_DYNAMIC_MINOR,
+	"xmctl",
+	&virtsrv_fops,
+};
+
+static int __init virtsrv_register(void)
+{
+	int ret;
+
+	ret = misc_register(&virtsrv_dev);
+	if (ret<0){
+		printk("cannot register device %s: error %d\n", virtsrv_dev.name, ret);
+	}
+	return ret;
+}
+
+module_init(virtsrv_register);
diff -Nur linux-3.0.34/arch/x86/xm/vmm.c linux-3.0.34-xm/arch/x86/xm/vmm.c
--- linux-3.0.34/arch/x86/xm/vmm.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.0.34-xm/arch/x86/xm/vmm.c	2013-01-13 23:14:54.000000000 +0100
@@ -0,0 +1,304 @@
+/*
+ * $FILE: vmm.c
+ *
+ * memory paravirtualisation
+ *
+ * $VERSION$
+ *
+ * Author: Miguel Masmano <mmasmano@ai2.upv.es>
+ *
+ * $LICENSE:
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "virtdrv.h"
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/memblock.h>
+#include <asm/bootparam.h>
+#include <asm/processor.h>
+#include <asm/desc.h>
+#include <asm/hw_irq.h>
+#include <asm/e820.h>
+#include <asm/paravirt.h>
+#include <asm/pgtable_32.h>
+#include <asm/pgtable.h>
+#include <asm/setup.h>
+#include <asm/pgalloc.h>
+#include <asm/tlbflush.h>
+#include <asm/pgtable_types.h>
+
+#define PGT_MASK 0x003FF000
+static inline void __set_page_type(unsigned long addr, int type) {
+	u32 pgte = ((u32)__va(addr)&PGT_MASK)>>PAGE_SHIFT;
+	u32 pgde = (u32)__va(addr)>>PGDIR_SHIFT;
+	u32 *pgd, *pgt, oval;
+
+	pgd = (u32*)((xmPartCtrTab->arch.cr3&PAGE_MASK)+__PAGE_OFFSET);
+	pgt = (u32*)(pgd[pgde]&PAGE_MASK);
+	oval = ((u32 *)__va(pgt))[pgte];
+
+	if (paravirt_get_lazy_mode() == PARAVIRT_LAZY_NONE) {
+		BUG_ON (XM_update_page32((u32)&(pgt[pgte]), oval&~_PAGE_PRESENT)<0);
+		BUG_ON (XM_set_page_type(addr, type) != XM_OK);
+		if (type == PPAG_STD)
+			oval |= _PAGE_RW;
+		BUG_ON (XM_update_page32((u32)&(pgt[pgte]), oval));
+	} else {
+		XM_lazy_update_page32((u32)&(pgt[pgte]), oval&~_PAGE_PRESENT);
+		XM_lazy_set_page_type(addr, type);
+		if (type == PPAG_STD)
+			oval |= _PAGE_RW;
+		XM_lazy_update_page32((u32)&(pgt[pgte]), oval);
+	}
+}
+
+static inline unsigned long virt_read_cr2(void) {
+	return xmPartCtrTab->arch.cr2;	
+}
+
+static inline unsigned long virt_read_cr3(void) {
+	return xmPartCtrTab->arch.cr3;
+}
+
+static inline void virt_flush_tlb(void) {
+	if (paravirt_get_lazy_mode() == PARAVIRT_LAZY_NONE) {
+		XM_write_register32(TLB_REG32, -1);
+	} else {
+		XM_lazy_write_register32(TLB_REG32, -1);
+	}
+}
+
+static inline void virt_write_cr3(unsigned long cr3) {
+    unsigned long old_cr3;
+
+    old_cr3 = virt_read_cr3();
+    if (old_cr3 == cr3) {
+        virt_flush_tlb();
+    } else {
+        __set_page_type(cr3, PPAG_PGD);
+        if (paravirt_get_lazy_mode() == PARAVIRT_LAZY_MMU) {
+            XM_lazy_write_register32(CR3_REG32, cr3);
+        } else {
+            if (XM_write_register32(CR3_REG32, cr3)<0) {
+                BUG();
+            }
+        }
+        __set_page_type(old_cr3, PPAG_STD);
+    }
+}
+
+static inline void virt_flush_tlb_single(unsigned long x) {
+	if (paravirt_get_lazy_mode() == PARAVIRT_LAZY_NONE) {
+		BUG_ON (XM_write_register32(TLB_REG32, x)<0);
+	} else {
+		XM_lazy_write_register32(TLB_REG32, x);
+	}
+}
+
+static inline void virt_set_pmd(pmd_t *pmdp, pmd_t pmdval) {
+	if (paravirt_get_lazy_mode() == PARAVIRT_LAZY_NONE) {
+		BUG_ON(XM_update_page32(__pa(pmdp), *((u32*)&pmdval)) != XM_OK);
+	} else {
+		XM_lazy_update_page32(__pa(pmdp), *((u32*)&pmdval));
+	}
+}
+
+static inline void virt_set_pte(pte_t *ptep, pte_t pte){
+	if (paravirt_get_lazy_mode() == PARAVIRT_LAZY_NONE) {
+		BUG_ON (XM_update_page32(__pa(ptep), pte_val(pte)) != XM_OK);
+	} else {
+		XM_lazy_update_page32(__pa(ptep), pte_val(pte));
+	}
+}
+
+static inline void virt_set_pte_at(struct mm_struct *mm, unsigned long addr, pte_t *ptep, pte_t pte) {
+	virt_set_pte(ptep, pte);
+}
+
+static void virt_alloc_pte(struct mm_struct *mm, unsigned long pfn) {
+	__set_page_type(pfn<<PAGE_SHIFT, PPAG_PGT);
+}
+
+static void virt_alloc_pmd(struct mm_struct *mm, unsigned long pfn) {
+	__set_page_type(pfn<<PAGE_SHIFT, PPAG_PGD);
+}
+
+static void virt_release_pte(unsigned long pfn) {
+	__set_page_type(pfn<<PAGE_SHIFT, PPAG_STD);
+}
+	
+static int virt_pgd_alloc(struct mm_struct *mm) {
+	return 0;
+}
+
+static void virt_pgd_free(struct mm_struct *mm, pgd_t *pgd) {
+	__set_page_type(__pa(mm->pgd), PPAG_STD);
+}
+
+static void virt_release_pmd(unsigned long pfn) {
+	__set_page_type(pfn<<PAGE_SHIFT, PPAG_STD);
+}
+
+static  void virt_leave_lazy_mode(void) {
+	XM_flush_hyp_batch();
+	paravirt_leave_lazy_mmu();
+}
+
+#define PTE_IDENT __PV_IS_CALLEE_SAVE(_paravirt_ident_32)
+
+static const struct pv_mmu_ops xm_mmu_ops __initdata = {
+
+	.read_cr2 = virt_read_cr2,
+	.write_cr2 = native_write_cr2,
+	.read_cr3 = virt_read_cr3,
+	.write_cr3 = virt_write_cr3,
+
+	.flush_tlb_user = virt_flush_tlb,
+	.flush_tlb_kernel = virt_flush_tlb,
+	.flush_tlb_single = virt_flush_tlb_single,
+	.flush_tlb_others = native_flush_tlb_others,
+
+	.pgd_alloc = virt_pgd_alloc,
+	.pgd_free = virt_pgd_free,
+
+	.alloc_pte = virt_alloc_pte,
+	.alloc_pmd = virt_alloc_pmd,
+	.release_pte = virt_release_pte,
+	.release_pmd = virt_release_pmd,
+
+	.alloc_pud = paravirt_nop,
+	.release_pud = paravirt_nop,
+
+	.set_pte = virt_set_pte,
+	.set_pte_at = virt_set_pte_at,
+	.set_pmd = virt_set_pmd,
+
+	.pte_update = paravirt_nop,
+	.pte_update_defer = paravirt_nop,
+
+	.ptep_modify_prot_start = __ptep_modify_prot_start,
+	.ptep_modify_prot_commit = __ptep_modify_prot_commit,
+
+#if PAGETABLE_LEVELS >= 3
+#ifdef CONFIG_X86_PAE
+	.set_pte_atomic = native_set_pte_atomic,
+	.pte_clear = native_pte_clear,
+	.pmd_clear = native_pmd_clear,
+#endif
+	.set_pud = native_set_pud,
+
+	.pmd_val = PTE_IDENT,
+	.make_pmd = PTE_IDENT,
+
+#if PAGETABLE_LEVELS == 4
+	.pud_val = PTE_IDENT,
+	.make_pud = PTE_IDENT,
+
+	.set_pgd = native_set_pgd,
+#endif
+#endif /* PAGETABLE_LEVELS >= 3 */
+
+	.pte_val = PTE_IDENT,
+	.pgd_val = PTE_IDENT,
+
+	.make_pte = PTE_IDENT,
+	.make_pgd = PTE_IDENT,
+
+	.dup_mmap = paravirt_nop,
+	.exit_mmap = paravirt_nop,
+	.activate_mm = paravirt_nop,
+
+	.lazy_mode = {
+		.enter = paravirt_enter_lazy_mmu,
+		.leave = virt_leave_lazy_mode,
+	},
+
+	.set_fixmap = native_set_fixmap,
+};
+
+__init void init_vmm_paravirt(unsigned long *pgd, int noPg) {
+	struct xmcMemoryArea memAreas[xmPartInfTab->noPhysicalMemoryAreas];
+	extern unsigned long xmPcRom[];
+	unsigned long *pgt, page, addr;
+	int e, i, noRsv;
+
+	e = XM_get_physmem_map(memAreas, xmPartInfTab->noPhysicalMemoryAreas);
+	BUG_ON (e != xmPartInfTab->noPhysicalMemoryAreas);
+
+	for (e = 0; e<(__PAGE_OFFSET>>PGDIR_SHIFT); e++)
+		if (pgd[e]&_PAGE_PRESENT) {
+			XM_lazy_update_page32(__pa(&pgd[e]), 0);
+		}
+
+	for (e = 0, max_pfn_mapped=0; e<xmPartInfTab->noPhysicalMemoryAreas; e++)
+		if (max_pfn_mapped<(memAreas[e].startAddr+memAreas[e].size)) 
+			max_pfn_mapped = memAreas[e].startAddr+memAreas[e].size;
+
+	memcpy(initial_page_table, pgd, PAGE_SIZE);
+	memcpy(swapper_pg_dir, pgd, PAGE_SIZE);
+	pgt = (unsigned long*)&pgd[1024];
+	for (e = 0, noRsv=0; e<noPg; e++) {
+		for (i = (__PAGE_OFFSET>>PGDIR_SHIFT); i<1024; i++)
+			if ((pgd[i]&PAGE_MASK) == __pa(&pgt[e*1024]))
+				break;
+
+		if (i >= 1024) {
+			__set_page_type(__pa(&pgt[e*1024]), PPAG_STD);	
+		} else
+			noRsv++;
+	}
+
+	virt_write_cr3(__pa(initial_page_table));
+
+	// Mapping all the pcROM
+	page = (u32)xmPcRom;
+	if (!(initial_page_table[0].pgd&_PAGE_PRESENT)) {
+		__set_page_type(__pa(page), PPAG_PGT);
+		XM_update_page32(__pa(&(initial_page_table[0].pgd)), __pa(page)|_PAGE_PRESENT|_PAGE_RW);
+		page += PAGE_SIZE;
+	} else
+		pgt = __va(initial_page_table[0].pgd&PAGE_MASK);
+	
+	if (!(pgt[0]&_PAGE_PRESENT)) {
+		XM_lazy_update_page32(__pa(&pgt[0]), __pa(page)|_PAGE_PRESENT|_PAGE_RW);
+		page += PAGE_SIZE;
+	}
+
+	for (addr = 640*1024; addr<1024*1024; addr+=PAGE_SIZE)
+		if (!(pgt[addr>>PAGE_SHIFT]&_PAGE_PRESENT)) {	
+			XM_lazy_update_page32(__pa(&pgt[addr>>PAGE_SHIFT]), __pa(page)|_PAGE_PRESENT|_PAGE_RW);
+			page += PAGE_SIZE;
+		}
+
+	memblock_init();
+
+	memblock_x86_reserve_range(__pa(pgd), __pa(pgt)+noRsv*PAGE_SIZE, "Pgt-pages");
+	memblock_x86_reserve_range(__pa(&libXmParams), __pa(&libXmParams)+PAGE_SIZE, "XM-libXMParams");
+	memblock_x86_reserve_range(__pa(xmPartCtrTab)-PAGE_SIZE, __pa(xmPartCtrTab), "XM-ImgHdr");
+	memblock_x86_reserve_range(__pa(xmPartCtrTab), __pa(xmPartCtrTab)+PAGE_SIZE, "XM-PartCtrTab");
+	memblock_x86_reserve_range(__pa(xmPartInfTab), __pa(xmPartInfTab)+PAGE_SIZE, "XM-PartInfTab");
+
+    memblock_dump_all();
+
+	XM_flush_hyp_batch();
+	max_pfn_mapped >>= PAGE_SHIFT;	
+
+	pv_mmu_ops = xm_mmu_ops;
+
+	// Top memory is reserved for XM
+	reserve_top_address(-XM_OFFSET+PAGE_SIZE);
+}
diff -Nur linux-3.0.34/arch/x86/xm/xmio/Kconfig linux-3.0.34-xm/arch/x86/xm/xmio/Kconfig
--- linux-3.0.34/arch/x86/xm/xmio/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.0.34-xm/arch/x86/xm/xmio/Kconfig	2013-01-13 23:14:53.000000000 +0100
@@ -0,0 +1,42 @@
+
+#	select FB_CFB_FILLRECT
+#	select FB_CFB_COPYAREA
+#	select FB_CFB_IMAGEBLIT
+
+config XMIO_SERVER
+	tristate "XMIO Server"
+	default m
+	select VIRTIO
+	depends on XM_PARTITION
+	help
+	  This option sets the role for this configuration, either server or client.
+	  
+config XMIO_CLIENT
+	tristate "XMIO Client"
+	default m
+	select VIRTIO
+	depends on XM_PARTITION
+
+#	NOTE: Ensure to enable each of the required drivers for each virtio device.
+#	select HW_RANDOM_VIRTIO
+#	select VIRTIO_CONSOLE
+#	select VIRTIO_NET
+#	select VIRTIO_BLK
+#	select RTC_DRV_VIRTIO
+
+config XMIO_SCAN_PERIOD
+	int "XMIO Scan Period"
+	depends on XMIO_SERVER || XMIO_CONSOLE
+	default 500
+	help
+	  System probes periodically for new XMIO devices. This value
+	  sets the period in milliseconds.
+
+config XMIO_SSE2_MEMCPY
+	depends on XM_PARTITION
+	bool "Use Fast XMIO memcpy for data transfer"
+	default false
+	help
+	  An implementation using SSE2 technology has been done, that
+	  notably increases performance of memcpy. However, alignment
+	  problems may arise, so this is still experimental
diff -Nur linux-3.0.34/arch/x86/xm/xmio/xmblk.c linux-3.0.34-xm/arch/x86/xm/xmio/xmblk.c
--- linux-3.0.34/arch/x86/xm/xmio/xmblk.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.0.34-xm/arch/x86/xm/xmio/xmblk.c	2013-01-13 23:14:53.000000000 +0100
@@ -0,0 +1,331 @@
+/*
+ * $FILE: xmblk.c
+ *
+ * XMIO virtual block device implementation
+ *
+ * Authors: Salva Peiró, <speiro@ai2.upv.es>
+ *          Jordi Sánchez, <jsanchez@ai2.upv.es>
+ *
+ * $LICENSE:
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include "xmio_accounting.h"
+#include "xmio_server.h"
+#include "xmio_virtio.h"
+
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/kthread.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/virtio.h>
+#include <linux/virtio_blk.h>
+#include <linux/workqueue.h>
+#include <linux/delay.h>
+
+#include <asm/uaccess.h>
+
+#define XMBLK_NODESCS       256
+#define KERNEL_SECTOR_SIZE  512
+#define VIRTIO_CONFIG_OK (VIRTIO_CONFIG_S_ACKNOWLEDGE|VIRTIO_CONFIG_S_DRIVER|VIRTIO_CONFIG_S_DRIVER_OK)
+
+static struct xmblk_extended {
+    struct xmio_virtio_features features;
+    struct virtio_blk_config virtio_config;
+} xmblk_extended = {
+    .features.config_len = sizeof(struct virtio_blk_config),
+};
+
+static void xmblk_irq(void);
+static int xmblk_ioctl(struct xmio_client *client, unsigned int cmd, struct xmio_args *args);
+static struct xmio_device xmblk = {
+    .type = XMIO_ID_BLOCK,
+    .ioctl = xmblk_ioctl,
+    .noqueues = 1,
+    .irq = XMIO_ID_BLOCK,
+    .extdata = &xmblk_extended,
+    .extlen = sizeof(xmblk_extended),
+};
+
+static struct xmio_account xmblk_account;
+static DEFINE_SEMAPHORE(xmblk_sem);
+static struct delayed_work xmblk_shrink_work;
+static struct completion attachment;
+static struct completion detachment;
+
+static xm_s32_t xmblk_detach(struct xmio_connection *conn)
+{
+    xm_s32_t ret;
+    struct xmblk_control *ctrl;
+
+    /* Disallow detach of mis-configured devices */
+    if (conn->shared->status != (VIRTIO_CONFIG_OK))
+        return -ENXIO;
+
+    ctrl = conn->priv;
+    conn->status = XMIO_CMD_DETACH;         /* Local device status is detaching */
+    msleep(100); 	                        /* Time delay to finish in progress requests */
+    xmio_send_command(conn, XMIO_CMD_DETACH);
+    /*xmio_acc_delete_queue(&xmblk_account, &conn->queues[0]);*/
+    /*xmio_connection_finish(conn); TODO: review conn free() */
+    ret = wait_for_completion_interruptible_timeout(&detachment, msecs_to_jiffies(XMIO_TIMEOUT));
+    filp_close(ctrl->file, NULL);
+    ctrl->file=NULL;
+    kfree(ctrl);
+    conn->priv = NULL;
+
+    return ret;
+}
+
+static xm_s32_t xmblk_offer(struct xmio_client *client, struct xmio_args *args)
+{
+    xm_s32_t ret;
+    struct xmblk_control *ctrl;
+    struct xmio_connection *conn;
+
+#if 0
+    if (xmblk.connects[client->id]) {
+        return -EPERM;
+    }
+#endif
+    if (args->file == NULL) {
+        return -ENXIO;
+    }
+    if ((ctrl=kzalloc(sizeof(struct xmblk_control), GFP_KERNEL)) == NULL) {
+        return -ENOMEM;
+    }
+
+    /* First we open the file and store the length. */
+    ctrl->file = filp_open(getname(args->file), O_RDWR|O_LARGEFILE, 0);
+    if (IS_ERR(ctrl->file)) {
+        return PTR_ERR(ctrl->file);
+    }
+    ctrl->len = ctrl->file->f_op->llseek(ctrl->file, 0, SEEK_END);
+    ctrl->id = args->param;
+
+    /* Extended data and features */
+    xmblk_extended.virtio_config.capacity = cpu_to_le64(ctrl->len / KERNEL_SECTOR_SIZE);
+    xmblk_extended.virtio_config.seg_max = cpu_to_le32(XMBLK_NODESCS - 2);
+    xmblk_extended.virtio_config.size_max = 8*KERNEL_SECTOR_SIZE;
+    xmblk_extended.virtio_config.blk_size = KERNEL_SECTOR_SIZE;
+
+    xmblk_extended.features.offered = 0
+        | BIT(VIRTIO_BLK_F_SEG_MAX)
+        | BIT(VIRTIO_BLK_F_BARRIER)
+        | BIT(VIRTIO_BLK_F_SIZE_MAX)
+        | BIT(VIRTIO_BLK_F_BLK_SIZE);
+
+    xmblk_extended.features.accepted = 0;
+
+    if ((conn=xmio_connection_new(&xmblk, client)) == NULL) {
+        return -ENOMEM;
+    }
+    conn->priv = ctrl;
+    conn->status = XMIO_CMD_RESET;
+
+    xmio_init_queue(conn, &conn->queues[0], XMBLK_NODESCS);
+    xmio_acc_insert_queue(&xmblk_account, &conn->queues[0]);
+    xmioserver_setup_irq(client, xmblk.irq, xmblk_irq);
+    xmio_connection_start(conn);                                            /* Make the device available to the client */
+
+    printk("xmblk %d offered to %d\n", ctrl->id, client->id);
+    ret = wait_for_completion_interruptible_timeout(&attachment, msecs_to_jiffies(XMIO_TIMEOUT));
+    return ret;
+}
+
+static void xmblk_irq(void)
+{
+    int s32a;
+    struct xmio_connection *conn;
+    struct xmio_list *list;
+
+    for (s32a=0; s32a<xmio_noclients(); ++s32a) {
+        for (list=xmblk.connects[s32a]; list!=NULL; list=list->next) {
+            conn = list->this;
+            if(conn != NULL) {
+                switch (conn->status) {
+                case XMIO_CMD_RESET:    /* Device boot status */
+                    if (conn->shared->status & XMIO_STATUS_DRIVER_OK) {
+                        conn->status = 0;
+                    }
+                    if (conn->shared->status == (VIRTIO_CONFIG_OK)) {
+                        complete(&attachment);
+                    }
+                    break;
+
+                case XMIO_CMD_DETACH:   /* Device detaching status */
+                    complete(&detachment);
+                    break;
+
+                case 0:                 /* Device normal operation status */
+                    if (conn->shared->status == 0) {
+                        xmio_connection_reset(conn);
+                    }
+                    break;
+                }
+            }
+        }
+    }
+    up(&xmblk_sem);                     /* up() can be called from any context */
+}
+
+#define VFS_CALL(vfs_func,...) \
+    ({                          \
+        int __ret;                      \
+        mm_segment_t oldfs = get_fs();  \
+        set_fs(get_ds());               \
+        __ret = vfs_func(__VA_ARGS__);  \
+        set_fs(oldfs);                  \
+        __ret;                          \
+    })
+
+static int xmblk_io(struct xmio_queue *xmque)
+{
+    struct virtio_blk_outhdr *outhdr;
+    struct xmblk_control *ctrl;
+    unsigned int in, out, head, ret, wlen;
+    char *status;
+    loff_t off;
+    struct kvec iov[32];
+
+    if ((head=xmioserver_get_request(xmque, iov, &out, &in)) < 0) {           /* Buffer addresses are checked here */
+        return -EAGAIN;
+    }
+    if (out == 0 || in == 0) {
+        /* TODO: Improve bad request */
+        return -1;
+    }
+    outhdr = iov[0].iov_base;
+    status = iov[out+in-1].iov_base;
+    off = outhdr->sector * KERNEL_SECTOR_SIZE;
+    ctrl = xmque->connect->priv;
+    wlen = sizeof(*status);
+
+    // Check for invalid types of requests
+    if (!ctrl || ctrl->file == NULL) {
+        *status = VIRTIO_BLK_S_IOERR;
+        goto xmblk_error;
+    }
+    if (xmque->connect->status == XMIO_CMD_DETACH) {
+        *status = VIRTIO_BLK_S_IOERR;
+        goto xmblk_error;
+    }
+
+    if (outhdr->type & VIRTIO_BLK_T_BARRIER) {
+        ret = VFS_CALL(vfs_fsync, ctrl->file, 1);
+    }
+
+    if (outhdr->type & VIRTIO_BLK_T_SCSI_CMD) {
+        *status = VIRTIO_BLK_S_UNSUPP;
+    } else if (outhdr->type & VIRTIO_BLK_T_OUT) {
+        if (ctrl->file->f_op->llseek(ctrl->file, off, SEEK_SET) != off) {
+            printk("xmblk: Bad seek to sector %llu\n", outhdr->sector);
+        }
+        ret = VFS_CALL(vfs_writev, ctrl->file, (const struct iovec *)iov+1, out-1, &off);
+        if (ret > 0 && off + ret > ctrl->len) {
+            printk("xmblk: Write past end %llu+%u\n", off, ret);
+        }
+        *status = (ret >= 0 ? VIRTIO_BLK_S_OK : VIRTIO_BLK_S_IOERR);
+    } else {
+        if (ctrl->file->f_op->llseek(ctrl->file, off, SEEK_SET) != off) {
+            printk("xmblk: Bad seek to sector %llu\n", outhdr->sector);
+        }
+        ret = VFS_CALL(vfs_readv, ctrl->file, (const struct iovec *)iov+1, in-1, &off);
+        if (ret >= 0)
+            wlen = sizeof(*status) + ret;
+        *status = (ret >= 0 ? VIRTIO_BLK_S_OK : VIRTIO_BLK_S_IOERR);
+    }
+
+xmblk_error:
+    xmio_request_served(xmque, head, wlen);
+    return 0;
+}
+
+static int xmblk_thread(void *data)
+{
+    struct xmio_queue *xmque;
+    int res;
+
+    for (;;) {
+        /* XXX: The down() operation times out and panics after a long period */
+        res = down_timeout(&xmblk_sem, msecs_to_jiffies(XMIO_TIMEOUT));
+        while ((xmque=xmio_acc_next(&xmblk_account)) != NULL) {
+            xmblk_io(xmque);
+        }
+    }
+
+    return 0;
+}
+
+/* TODO: Check race conditions. Insert mutex to operation */
+static void xmblk_shrink(struct work_struct *work)
+{
+    struct xmio_queue *xmque;
+
+    for (xmque=xmblk_account.list; xmque; xmque=xmque->next) {
+        xmio_acc_shrink(xmque, XMIO_ACCOUNT_DELTA);
+    }
+    schedule_delayed_work(&xmblk_shrink_work, msecs_to_jiffies(XMIO_ACCOUNT_TMOUT));
+}
+
+static int xmblk_ioctl(struct xmio_client *client, unsigned int cmd, struct xmio_args *args)
+{
+    struct xmblk_control *ctrl;
+    struct xmio_connection *conn;
+    struct xmio_list *list;
+
+    switch (cmd){
+    default:
+        return -1;
+
+    case XMIOCTL_CMD_DETACH:
+        for (list=xmblk.connects[client->id]; list; list=list->next) {
+            conn = list->this;
+            ctrl = conn->priv;
+            if (conn && ctrl && ctrl->id == args->param) {
+                return xmblk_detach(conn);
+            }
+        }
+        return -ENXIO;
+        break;
+
+    case XMIOCTL_CMD_OFFER:
+        return xmblk_offer(client, args);
+    }
+}
+
+static int __init xmblk_init(void)
+{
+    if(is_xm_guest())
+        return 0;
+    xmio_register_device(&xmblk);
+
+    kthread_run(xmblk_thread, NULL, "xmblk_thread");
+
+    INIT_DELAYED_WORK(&xmblk_shrink_work, xmblk_shrink);
+    schedule_delayed_work(&xmblk_shrink_work, msecs_to_jiffies(XMIO_ACCOUNT_TMOUT));
+
+    init_completion(&attachment);
+    init_completion(&detachment);
+    printk("xmblk initialized\n");
+
+    return 0;
+}
+
+module_init(xmblk_init);
+/*module_exit(xmblk_exit);*/
+MODULE_LICENSE("GPL");
diff -Nur linux-3.0.34/arch/x86/xm/xmio/xmcon.c linux-3.0.34-xm/arch/x86/xm/xmio/xmcon.c
--- linux-3.0.34/arch/x86/xm/xmio/xmcon.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.0.34-xm/arch/x86/xm/xmio/xmcon.c	2013-01-13 23:14:54.000000000 +0100
@@ -0,0 +1,307 @@
+/*
+ * $FILE: xmcon.c
+ *
+ * XMIO virtual console device implementation
+ *
+ * Authors: Salva Peiró, <speiro@ai2.upv.es>
+ *          Jordi Sánchez, <jsanchez@ai2.upv.es>
+ *
+ * $LICENSE:
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include "xmio_server.h"
+#include "xmio_virtio.h"
+
+#include <linux/cdev.h>
+#include <linux/console.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/termios.h>
+#include <linux/types.h>
+
+#include <linux/virtio.h>
+#include <linux/virtio_console.h>
+
+#define XMIO_CONSOLE_NODE           "xmcon"
+#define XMIO_CONSOLE_DELAY          (10)
+
+#define XMIO_CONSOLE_NODESCS        64
+#define XMIO_CONSOLE_POOLSIZE       16384
+
+struct xmcon_control {
+    struct completion read, write;
+    xm_s32_t inuse;
+};
+
+static struct {
+    struct xmio_virtio_features features;
+} xmcon_extended;
+
+static int xmcon_ioctl(struct xmio_client *client, unsigned int cmd, struct xmio_args *args);
+static struct xmio_device xmcon = {
+    .type = XMIO_ID_CONSOLE,
+    .noqueues = 2,
+    .irq = XMIO_ID_CONSOLE,
+    .ioctl = xmcon_ioctl,
+
+    .extdata = &xmcon_extended,
+    .extlen = sizeof(xmcon_extended),
+};
+
+/*
+ * xmcon_irq
+ *
+ *  Complete pending works. Currently, there is no accounting for this device.
+ */
+static void xmcon_irq(void)
+{
+    int s32a;
+    struct xmcon_control *ctrl;
+    struct xmio_connection *conn;
+
+    for (s32a=0; s32a<xmio_noclients(); ++s32a) {
+        conn = xmio_list_get_head(xmcon.connects[s32a]);
+        if(conn != NULL) {
+            conn->status = conn->shared->status;
+
+            ctrl = conn->priv;
+            if (xmio_more_requests(&conn->queues[0])) {
+                complete(&ctrl->write);
+            }
+            if (xmio_more_requests(&conn->queues[1])) {
+                complete(&ctrl->read);
+            }
+        }
+    }
+}
+
+static ssize_t xmconsole_write(struct file *file, const char __user *buf, size_t count, loff_t *f_pos)
+{
+    int in, out, head;
+    struct xmio_connection *conn = file->private_data;
+    struct xmio_queue *xmque = &conn->queues[0];
+    struct xmcon_control *ctrl = conn->priv;
+    struct kvec iov[XMIO_CONSOLE_NODESCS];
+
+    wait_for_completion_interruptible_timeout(&ctrl->write, msecs_to_jiffies(XMIO_CONSOLE_DELAY));
+
+    if ((head=xmioserver_get_request(xmque, iov, &out, &in)) < 0) {           /* Buffer addresses are checked here */
+        return -EAGAIN;
+    }
+    if (out > 0) {
+        return -EIO;
+    }
+
+    if (count > iov[0].iov_len) {
+        count = iov[0].iov_len;
+    }
+
+    if (copy_from_user(iov[0].iov_base, buf, count) != 0) {
+        return -EAGAIN;
+    }
+    xmio_request_served(xmque, head, count);
+
+    return count;
+}
+
+static ssize_t xmconsole_read(struct file *file, char __user *buf, size_t count, loff_t *f_pos)
+{
+    int in, out, head;
+    struct xmio_connection *conn = file->private_data;
+    struct xmio_queue *xmque = &conn->queues[1];
+    struct xmcon_control *ctrl = conn->priv;
+    struct kvec iov[XMIO_CONSOLE_NODESCS];
+
+    wait_for_completion_interruptible_timeout(&ctrl->read, msecs_to_jiffies(XMIO_CONSOLE_DELAY));
+
+    if ((head=xmioserver_get_request(xmque, iov, &out, &in)) < 0) {           /* Buffer addresses are checked here */
+        return -EAGAIN;
+    }
+    if (in > 0) {
+        return -EIO;
+    }
+
+    if (count > iov[0].iov_len) {
+        count = iov[0].iov_len;
+    }
+
+    if (copy_to_user(buf, iov[0].iov_base, count) != 0) {
+        return -EAGAIN;
+    }
+    xmio_request_served(xmque, head, count);
+
+    return count;
+}
+
+static long xmconsole_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    switch(cmd) {
+    default:
+        return -EFAULT;
+
+    /* fake termios ioctls: allows using minicom/screen /dev/xmguest */
+    case TCGETA:
+    case TCGETS:
+    case TCSETA:
+    case TCSETS:
+    case TCSETSF:
+    case TCSAFLUSH:
+    case TIOCEXCL:
+        return 0;
+    }
+}
+
+static int xmconsole_open(struct inode *inode, struct file *file)
+{
+    int cid;
+    struct xmcon_control *ctrl;
+    struct xmio_connection *conn;
+
+    cid = iminor(inode);
+    conn = xmio_list_get_head(xmcon.connects[cid]);
+    if (conn == NULL) {
+        return -ENOSYS;
+    }
+    ctrl = conn->priv;
+    if(ctrl->inuse && (file->f_flags & O_EXCL)) {
+        return -EBUSY;
+    }
+    ctrl->inuse++;
+    file->private_data = conn;
+
+    return 0;
+}
+
+static int xmconsole_release(struct inode *inode, struct file *file)
+{
+    struct xmio_connection *conn = file->private_data;
+    struct xmcon_control *ctrl = conn->priv;
+
+    ctrl->inuse--;
+
+    return 0;
+}
+
+static struct file_operations xmconsole_fops = {
+    .owner = THIS_MODULE,
+    .read = xmconsole_read,
+    .write = xmconsole_write,
+    .open = xmconsole_open,
+    .unlocked_ioctl = xmconsole_ioctl,
+    .release = xmconsole_release,
+};
+
+
+static int xmcon_ioctl(struct xmio_client *client, unsigned int cmd, struct xmio_args *args)
+{
+    struct xmcon_control *ctrl;
+    struct xmio_connection *conn;
+
+    switch (cmd){
+    default:
+        return -1;
+
+    case XMIOCTL_CMD_OFFER:
+#ifndef CONFIG_XM_RESET
+        if (xmcon.connects[client->id] != NULL) {
+            return -EPERM;
+        }
+#endif
+        if ((ctrl=kzalloc(sizeof(struct xmcon_control), GFP_KERNEL)) == NULL) {
+            return -ENOMEM;
+        }
+        conn = xmio_connection_new(&xmcon, client);
+        if (conn == NULL) {
+            return -ENOMEM;
+        }
+
+        xmio_init_queue(conn, &conn->queues[0], 32);
+        xmio_init_queue(conn, &conn->queues[1], 256);
+
+        conn->priv = ctrl;
+        init_completion(&ctrl->read);
+        init_completion(&ctrl->write);
+
+        xmioserver_setup_irq(client, xmcon.irq, xmcon_irq);
+        xmio_connection_start(conn);                                            /* Make the device available to the client */
+
+        pr_debug("%s offered to %d\n", XMIO_CONSOLE_NODE, client->id);
+        return 0;
+    }
+}
+
+static int __init xmcon_init(void)
+{
+    struct xmio_client *clients;
+    dev_t dev = 0;
+    struct cdev *cdev;
+    struct class *xmio_class;
+    struct device *device;
+    int ret, major, i, noclients;
+
+    if(is_xm_guest())
+        return 0;
+    printk("xmcon: initializing... \n");
+    clients = xmio_get_clients();
+    noclients = xmio_noclients();
+    BUG_ON(!clients);
+
+    xmio_class = class_create(THIS_MODULE, XMIO_CONSOLE_NODE);              /* Create class */
+    if (IS_ERR(xmio_class)) {
+        return PTR_ERR(xmio_class);
+    }
+
+    cdev = kzalloc(sizeof(struct cdev)*noclients, GFP_KERNEL);              /* Allocate char device */
+    if (cdev == NULL) {
+        printk("xmcon: char device structure could not be created\n");
+        return -ENOMEM;
+    }
+
+    ret = alloc_chrdev_region(&dev, 0, noclients, XMIO_CONSOLE_NODE);
+    if (ret < 0) {
+        printk("xmcon: can't get device %s major\n", XMIO_CONSOLE_NODE);
+        goto error_n1;
+    }
+
+    xmio_register_device(&xmcon);
+
+    major = MAJOR(dev);
+    for (i=0; i<noclients; i++) {                                           /* Instantiate the console for each client */
+        dev = MKDEV(major, i);
+        cdev_init(&cdev[i], &xmconsole_fops);
+        if (cdev_add(&cdev[i], dev, 1)) {
+            printk("[xmcon] Error adding device %s%d\n", XMIO_CONSOLE_NODE, i);
+        }
+        device = device_create(xmio_class, NULL, dev, NULL, "%s%d", XMIO_CONSOLE_NODE, i);
+        xmcon_ioctl(&clients[i], XMIOCTL_CMD_OFFER, NULL);
+    }
+
+    XMIO_DEBUG("%s offered to %d clients\n", XMIO_CONSOLE_NODE, noclients);
+    
+    return 0;
+
+error_n1:
+    kfree(cdev);
+
+    printk("xmcon failed\n");
+    return -ENOMEM;
+}
+
+module_init(xmcon_init);
+/*module_exit(xmcon_exit);*/
+MODULE_LICENSE("GPL");
diff -Nur linux-3.0.34/arch/x86/xm/xmio/xmio_accounting.c linux-3.0.34-xm/arch/x86/xm/xmio/xmio_accounting.c
--- linux-3.0.34/arch/x86/xm/xmio/xmio_accounting.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.0.34-xm/arch/x86/xm/xmio/xmio_accounting.c	2013-01-13 23:14:54.000000000 +0100
@@ -0,0 +1,113 @@
+/*
+ * FILE: xmio_accounting.c
+ *
+ * I/O bandwidth accounting
+ *
+ * Author: Jordi Sánchez, <jsanchez@ai2.upv.es>
+ *
+ * $LICENSE:
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include "xmio_server.h"
+
+#include <linux/bug.h>
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <linux/module.h>
+
+/*
+ * xmio_acc_update
+ *
+ *      Update client accounting
+ */
+static inline void xmio_acc_update(struct xmio_queue *xmque, xm_u32_t lapse)
+{
+    WARN_ON(!xmque);
+    xmque->usage.effort += xmque->usage.bw * lapse;
+    xmque->usage.ratio = xmque->usage.effort / (xmque->usage.bytes + 1);
+}
+
+/*
+ * xmio_acc_shrink
+ *
+ *      Shrink operation of the XMVIO accounting mechanism
+ */
+void xmio_acc_shrink(struct xmio_queue *xmque, xm_u32_t delta)
+{
+    xmque->usage.effort /= delta;
+    xmque->usage.bytes /= delta;
+}
+EXPORT_SYMBOL(xmio_acc_shrink);
+
+/*
+ * xmio_acc_next
+ *
+ *  We should have accounting for each queue. This causes problems
+ *  as all the queues of a single device have the same accounting
+ */
+struct xmio_queue *xmio_acc_next(struct xmio_account *acc)
+{
+    struct xmio_queue *tmpque, *xmque;
+    xm_u32_t max = 0;
+    xm_s64_t now;
+    struct timespec tm = CURRENT_TIME;
+
+    xmque = NULL;
+    now = timespec_to_ns(&tm);
+    for (tmpque=acc->list; tmpque; tmpque=tmpque->next) {
+        if(!tmpque)
+            continue;
+        xmio_acc_update(tmpque, now - acc->last_time);
+        if (xmio_more_requests(tmpque)) {
+            if (tmpque->usage.ratio >= max) {
+                max = tmpque->usage.ratio;
+                xmque = tmpque;
+            }
+        }
+    }
+    acc->last_time = now;
+
+    return xmque;
+}
+EXPORT_SYMBOL(xmio_acc_next);
+
+void xmio_acc_insert_queue(struct xmio_account *acc, struct xmio_queue *xmque)
+{
+    BUG_ON(!acc);
+    BUG_ON(!xmque);
+
+    xmque->next = acc->list;
+    acc->list = xmque;
+}
+EXPORT_SYMBOL(xmio_acc_insert_queue);
+
+void xmio_acc_delete_queue(struct xmio_account *acc, struct xmio_queue *xmque)
+{
+	struct xmio_queue *tmpque;
+	BUG_ON(!acc);
+	BUG_ON(!xmque);
+
+	if(acc->list == xmque)
+		acc->list = NULL;
+	for (tmpque=acc->list; tmpque; tmpque=tmpque->next) {
+		if(tmpque->next && tmpque->next == xmque){
+			tmpque->next=tmpque->next->next;
+			break;
+		}
+	}
+}
+EXPORT_SYMBOL(xmio_acc_delete_queue);
+
+MODULE_LICENSE("GPL");
diff -Nur linux-3.0.34/arch/x86/xm/xmio/xmio_accounting.h linux-3.0.34-xm/arch/x86/xm/xmio/xmio_accounting.h
--- linux-3.0.34/arch/x86/xm/xmio/xmio_accounting.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.0.34-xm/arch/x86/xm/xmio/xmio_accounting.h	2013-01-13 23:14:53.000000000 +0100
@@ -0,0 +1,33 @@
+/*
+ * FILE: xmio_accounting.h
+ *
+ * I/O banndwidth accounting
+ *
+ * Author: Jordi Sánchez, <jsanchez@ai2.upv.es>
+ *
+ * $LICENSE:
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#ifndef _XMIO_ACCOUNTING_H_
+#define _XMIO_ACCOUNTING_H_
+
+#include "xmio_server.h"
+
+extern void xmio_acc_shrink(struct xmio_queue *xmque, xm_u32_t delta);
+extern struct xmio_queue *xmio_acc_next(struct xmio_account *acc);
+extern void xmio_acc_insert_queue(struct xmio_account *acc, struct xmio_queue *xmque);
+extern void xmio_acc_delete_queue(struct xmio_account *acc, struct xmio_queue *xmque);
+
+#endif //_XMIO_ACCOUNTING_H_
diff -Nur linux-3.0.34/arch/x86/xm/xmio/xmio_alloc.c linux-3.0.34-xm/arch/x86/xm/xmio/xmio_alloc.c
--- linux-3.0.34/arch/x86/xm/xmio/xmio_alloc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.0.34-xm/arch/x86/xm/xmio/xmio_alloc.c	2013-01-13 23:14:54.000000000 +0100
@@ -0,0 +1,132 @@
+/*
+ * FILE: xmio_alloc.c
+ *
+ * XtratuM I/O memory allocator
+ *  · The pool grows downwards
+ *  · Buffers are kept cache and page aligned
+ *
+ * Author: Jordi Sánchez, <jsanchez@ai2.upv.es>
+ */
+#include <linux/fs.h>
+#include <linux/bitops.h>
+#include <linux/compiler.h>
+#include <linux/string.h>
+#include <linux/module.h>
+
+#define PGSIZE              4096
+#define PAGE_INDEX(P, B)    (((P) - (B))>>12)
+#define PAGE_ALIGN(P)       ((unsigned int)(P) & ~(PGSIZE-1))
+#define ROUNDTO_PAGE(V)     (((V) + (PGSIZE-1)) & ~(PGSIZE-1))
+#define NULL                ((void *)0)
+
+struct block {
+    struct block *next;
+};
+
+struct page_index {
+    unsigned int page;
+    unsigned int offset;
+};
+
+struct xmio_pool {
+    unsigned int base;
+    unsigned int size;
+    unsigned int mask;
+    unsigned int current_page;
+    unsigned short *page_lut;                   /* Lookup Table */
+    struct block *block_list[16];               /* We waste some memory at no cost, but the code looks nicer */
+    struct page_index index[16];                /* Index to the pages and offsets */
+};
+
+static unsigned int xmio_alloc_page(struct xmio_pool *pool)
+{
+    pool->current_page = pool->current_page - PGSIZE;
+    return pool->current_page;
+}
+
+static unsigned int alloc_npages(struct xmio_pool *pool, int npages)
+{
+    pool->current_page = pool->current_page - PGSIZE*npages;
+    return pool->current_page;
+}
+
+/*
+ * TODO: Check pointer
+ */
+void xmio_free(void *base, void *ptr)
+{
+    struct xmio_pool *pool = base;
+    struct block *block = ptr;
+    unsigned int size, u32a;
+
+    if (likely(ptr != NULL && base != NULL)) {
+        size = pool->page_lut[PAGE_INDEX((unsigned int)ptr, pool->base)];
+        if (likely(size != 0)) {
+            u32a = __ffs(size);
+            block->next = pool->block_list[u32a];
+            pool->block_list[u32a] = block;
+        }
+    }
+}
+EXPORT_SYMBOL(xmio_free);
+
+/*
+ * TODO: should check that size is not 0
+ */
+void *xmio_alloc(void *base, unsigned int size)
+{
+    unsigned int u32a, rsize, mask;
+    struct xmio_pool *pool = base;
+    void *ptr = NULL;
+
+    u32a = __fls(size-1) + 1;
+    rsize = 1<<u32a;                                                    /* Round up size to the next power of 2 */
+    mask = pool->mask & (~(rsize-1));
+
+    if (likely(mask != 0)) {                                            /* Size in range */
+        if ((rsize & pool->mask) == 0) {                                /* Size unavailable, get next size */
+            u32a = __ffs(mask);
+            rsize = 1<<u32a;
+        }
+        if (likely(pool->block_list[u32a] != NULL)) {                   /* Extraction from the list. Likely at long term */
+            ptr = pool->block_list[u32a];
+            pool->block_list[u32a] = pool->block_list[u32a]->next;
+        } else {
+            if (unlikely((pool->index[u32a].offset + rsize) > PGSIZE)) {/* Allocate new page. Unlikely at long term */
+                pool->index[u32a].page = xmio_alloc_page(pool);
+                pool->index[u32a].offset = 0;
+                pool->page_lut[PAGE_INDEX(pool->index[u32a].page, pool->base)] = rsize;
+            }
+            ptr = (void *)(pool->index[u32a].page + pool->index[u32a].offset);/* Allocate buffer from page. Unlikely at long term */
+            pool->index[u32a].offset += rsize;
+        }
+    }
+
+    return ptr;
+}
+EXPORT_SYMBOL(xmio_alloc);
+
+void *xmio_init_pool(void *base, unsigned int size, unsigned int mask)
+{
+    unsigned int u32a;
+    struct xmio_pool *pool = (void *)PAGE_ALIGN(base + size - sizeof(struct xmio_pool));
+
+    pool->base = (int)base;
+    pool->current_page = (unsigned int)pool;
+    pool->page_lut = (unsigned short *)alloc_npages(pool, (((size*sizeof(unsigned short))>>12) + (PGSIZE-1))>>12);
+    pool->mask = mask;
+    memset(pool->block_list, 0, sizeof(pool->block_list));
+
+    while (mask != 0) {
+        u32a = __ffs(mask);
+        pool->index[u32a].page = xmio_alloc_page(pool);
+        pool->index[u32a].offset = 0;
+        pool->page_lut[PAGE_INDEX(pool->index[u32a].page, pool->base)] = 1<<u32a;
+        __clear_bit(u32a, (volatile long unsigned int*)&mask);
+    }
+
+    return pool;
+}
+EXPORT_SYMBOL(xmio_init_pool);
+
+MODULE_LICENSE("GPL");
diff -Nur linux-3.0.34/arch/x86/xm/xmio/xmio_alloc.h linux-3.0.34-xm/arch/x86/xm/xmio/xmio_alloc.h
--- linux-3.0.34/arch/x86/xm/xmio/xmio_alloc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.0.34-xm/arch/x86/xm/xmio/xmio_alloc.h	2013-01-13 23:14:53.000000000 +0100
@@ -0,0 +1,31 @@
+/*
+ * FILE: xmio_alloc.h
+ *
+ * XtratuM I/O memory allocator
+ *
+ * Authors: Jordi Sánchez, <jsanchez@ai2.upv.es>
+ *          Salvador Peiró <speiro@ai2.upv.es>
+ *
+ * $LICENSE:
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#ifndef _XMIO_MALLOC_H_
+#define _XMIO_MALLOC_H_
+
+extern void *xmio_init_pool(void *base, unsigned int size, int mask);
+extern void *xmio_alloc(void *base, unsigned int size);
+extern void xmio_free(void *base, void *ptr);
+
+#endif //_XMIO_MALLOC_H_
diff -Nur linux-3.0.34/arch/x86/xm/xmio/xmio_client.c linux-3.0.34-xm/arch/x86/xm/xmio/xmio_client.c
--- linux-3.0.34/arch/x86/xm/xmio/xmio_client.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.0.34-xm/arch/x86/xm/xmio/xmio_client.c	2013-01-13 23:14:53.000000000 +0100
@@ -0,0 +1,320 @@
+/*
+ * FILE: xmio_client.c
+ *
+ * XtratuM device virtualization engine client side
+ *
+ * Author: Jordi Sánchez, <jsanchez@ai2.upv.es>
+ *
+ * $LICENSE:
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include "xmio_alloc.h"
+#include "xmio_client.h"
+
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/module.h>
+
+/* To be defined */
+#define TO_VIRT(X)                  __va(X)
+#define TO_PHYS(X)                  __pa(X)
+
+#define BIT_SET(NR, ADDR)           __set_bit(NR, (volatile unsigned long *)(ADDR))
+#define BIT_CLEAR(NR, ADDR)         __clear_bit(NR, (volatile unsigned long *)(ADDR))
+#define BIT_TEST(NR, ADDR)          test_bit(NR, (volatile unsigned long *)(ADDR))
+
+#define XMIO_ID_MAX                 10
+
+static struct {
+    void (*action)(void *);
+    void *data;
+} xmio_handler[XMIO_ID_MAX];
+
+static struct {
+    struct xmio_main_header *main;
+    void *base;
+    xm_u32_t size;
+} mem_data = { 0, 0, 0 };
+
+static void *xmio_buffer_pool;
+static xm_u32_t xmio_irq_mask, xmio_device_mask;
+
+static inline void *xmio_to_virt(xmAddress_t phys)
+{
+    void *addr = __va(phys);
+    if (addr < (void *)mem_data.main || (addr - (void *)mem_data.main) > mem_data.size) {
+        return NULL;
+    }
+    return addr;
+}
+
+static void xmio_client_irq(xm_s32_t vector, void *data)
+{
+    xm_u32_t mask, u32a;
+
+    mask = mem_data.main->server_irqpend & xmio_irq_mask; /* Only allowed irqs */
+    while (mask) {
+        u32a = __ffs(mask);
+        BIT_CLEAR(u32a, &mem_data.main->server_irqpend);
+        if (xmio_handler[u32a].action) {
+            xmio_handler[u32a].action(xmio_handler[u32a].data);
+        }
+        BIT_CLEAR(u32a, &mask);
+    }
+}
+
+xm_s32_t xmio_setup_irq(xm_s32_t devirq, void (*handler)(void *), void *data)
+{
+    if (devirq >= 0 && devirq < XMIO_ID_MAX) {
+        BIT_SET(devirq, &xmio_irq_mask);
+        xmio_handler[devirq].action = handler;
+        xmio_handler[devirq].data = data;
+    }
+
+    return 0;
+}
+EXPORT_SYMBOL(xmio_setup_irq);
+
+void xmio_clear_irq(xm_s32_t devirq)
+{
+    if (devirq >= 0 && devirq < XMIO_ID_MAX) {
+        xmio_handler[devirq].action = NULL;
+        xmio_handler[devirq].data = NULL;
+        BIT_CLEAR(devirq, &xmio_irq_mask);
+    }
+}
+EXPORT_SYMBOL(xmio_clear_irq);
+
+xm_s32_t xmio_add_buf(struct xmio_desc *desc, struct xmio_buffer *xmbuf)
+{
+    void *shbuf;
+#ifdef CONFIG_XMIO_SSE2_MEMCPY
+    xm_s32_t rsize;
+
+    desc->offset = buffer & 0x7;                                        /* This allows input buffers to be correctly aligned */
+    rsize = ALIGN_TO((buffer & 0x7) + size, 8);
+    xmbuf = xmio_alloc(xmio_buffer_pool, rsize);
+#else
+    desc->offset = 0;
+    shbuf = xmio_alloc(xmio_buffer_pool, xmbuf->size);
+#endif
+    if (shbuf == NULL) {
+        return -1;
+    }
+
+    desc->addr = (xm_u32_t)TO_PHYS(shbuf);
+    desc->size = xmbuf->size;
+    desc->flags = xmbuf->flags;
+    desc->orig = xmbuf->addr;                                       /* Cookie */
+
+    if (!(xmbuf->flags & XMIO_BUFFER_WRITE)) {
+        xmio_memcpy(shbuf, xmbuf->addr, xmbuf->size);
+    }
+
+    return 0;
+}
+
+xm_s32_t xmio_raise_irq(xm_u32_t partition_id, xm_u8_t devirq)
+{
+    BIT_SET(devirq, &mem_data.main->client_irqpend);
+    return xm_raise_ipvi(partition_id, XMIO_IRQ);
+}
+EXPORT_SYMBOL(xmio_raise_irq);
+
+xm_s32_t xmio_kick(struct xmio_queue *xmque)
+{
+    xmque->shared->avail = xmque->avail;                                         /* Expose the buffer to the available list */
+    return xmio_raise_irq(xmque->xmdev->shared->sid, xmque->xmdev->shared->sirq);/* and interrupt the I/O Server            */
+}
+EXPORT_SYMBOL(xmio_kick);
+
+xm_s32_t xmio_add_request(struct xmio_queue *xmque, struct xmio_buffer chain[], xm_u32_t out, xm_u32_t in)
+{
+    xm_u32_t u32a, u32b;
+    struct xmio_desc *desc = NULL;
+    xm_s32_t head;
+
+    if (xmque->free < out + in + 1) {
+        return -1;
+    }
+
+    xmque->free -= out + in;
+    u32b = head = xmque->free_head;
+    for (u32a=0; out; --out, ++u32a) {
+        desc = &xmque->desc_pool[u32b];
+        if (unlikely(xmio_add_buf(desc, &chain[u32a]) < 0)) {
+            return -1;
+        }
+        u32b = desc->next;
+    }
+    for (; in; --in, ++u32a) {
+        desc = &xmque->desc_pool[u32b];
+        if (unlikely(xmio_add_buf(desc, &chain[u32a]) < 0)) {
+            return -1;
+        }
+        u32b = desc->next;
+    }
+    desc->flags |= XMIO_BUFFER_LAST;
+
+    xmque->free_head = u32b;
+    xmque->avail_pool[xmque->avail] = head;
+    xmque->avail = (xmque->avail + 1) % xmque->nodescs;
+
+    return head;
+}
+EXPORT_SYMBOL(xmio_add_request);
+
+xm_s32_t xmioclient_get_request(struct xmio_queue *xmque, xm_u32_t *len)
+{
+    void *buf;
+    struct xmio_desc *desc;
+    xm_u32_t idx, head;
+
+    *len = xmque->used_pool[xmque->used].written;
+    head = idx = xmque->used_pool[xmque->used].idx;
+    do {
+        desc = &xmque->desc_pool[idx];                                  /* Get buffer descriptor */
+        buf = xmio_to_virt(desc->addr + desc->offset);                  /* Address on shared memory */
+        if (desc->flags & XMIO_BUFFER_WRITE) {
+            void *orig = desc->orig;
+            xmio_memcpy(orig, buf, desc->size);
+        }
+        xmio_free(xmio_buffer_pool, buf);
+        xmque->free++;
+        idx = desc->next;
+    } while (!(desc->flags & XMIO_BUFFER_LAST));
+
+    desc->next = xmque->free_head;                                      /* desc is the last descriptor of the chain */
+    xmque->free_head = head;                                            /* The left operation inserts the chain into a list */
+                                                                        /* of free descriptors                              */
+    xmque->used = (xmque->used + 1) % xmque->nodescs;
+
+    return head;
+}
+EXPORT_SYMBOL(xmioclient_get_request);
+
+/*
+ * xmio_find_queues
+ */
+xm_s32_t xmio_find_queues(struct xmio_device *xmdev)
+{
+    struct xmio_queue *xmque;
+    struct xmio_queue_shared *shared;
+    xm_u32_t u32a, u32b;
+
+    shared = xmio_to_virt(xmdev->shared->queue_addr);
+
+    for (u32a=0; u32a<xmdev->noqueues; ++u32a) {
+        if ((shared != NULL) && (shared->signature == XMIO_QUEUE_SIGNATURE)) {
+            xmque = &xmdev->queues[u32a];
+            xmque->shared = shared;
+            xmque->free = xmque->nodescs = shared->nodescs;
+            xmque->avail_pool = (void *)TO_VIRT(shared->avail_addr);
+            xmque->used_pool = (void *)TO_VIRT(shared->used_addr);
+            xmque->desc_pool = (void *)TO_VIRT(shared->desc_addr);
+            xmque->xmdev = xmdev;
+
+            xmque->free_head = 0;
+            for (u32b=0; u32b<xmque->nodescs-1; ++u32b) {
+                xmque->desc_pool[u32b].next = u32b+1;
+            }
+            shared = xmio_to_virt(xmque->shared->next_addr);
+        }
+    }
+
+    return 0;
+}
+EXPORT_SYMBOL(xmio_find_queues);
+
+/*
+ * xmio_scan
+ *
+ *  Probes for new devices in shared memory
+ */
+xm_u32_t xmio_scan(struct xmio_device_shared *shared[])
+{
+    xm_u32_t u32a, found;
+    struct xmio_device xmdev;
+
+    if (!mem_data.main)
+        return 0;
+
+    found = 0;
+    for (u32a=0; u32a<XMIO_MAX_DEVICES; ++u32a) {
+        shared[found] = xmio_to_virt(mem_data.main->devices[u32a]);
+        if ((shared[found] != NULL) && ((xmio_device_mask & 1<<u32a) == 0)) {
+            if (shared[found]->cmd == XMIO_CMD_RESET) {                     /* Cold discovery */
+                shared[found]->cmd = 0;                                     /* Ack command */
+                shared[found]->cirq = u32a;                                 /* Early data storage */
+                shared[found]->cid = XM_PARTITION_SELF;
+                BIT_SET(u32a, &xmio_device_mask);
+                found++;
+            } else {                                                        /* Warm discovery */
+                xmdev.shared = shared[found];
+                xmdev.shared->cirq = u32a;
+                xmio_restart_device(&xmdev);                                /* Force device restart */
+            }
+        }
+    }
+    XMIO_DEBUG("found %d\n", found);
+    return found;
+}
+EXPORT_SYMBOL(xmio_scan);
+
+void xmio_restart_device(struct xmio_device *xmdev)
+{
+    xm_u32_t u32a;
+
+    u32a = xmdev->shared->cirq;
+    mem_data.main->devices[u32a] = 0;
+    BIT_CLEAR(u32a, &xmio_device_mask);
+    xmdev->shared->status = 0;
+    xmio_raise_irq(xmdev->shared->sid, xmdev->shared->sirq);
+}
+EXPORT_SYMBOL(xmio_restart_device);
+
+static int __init xmio_init(void)
+{
+    struct xmcMemoryArea mem_areas[xmPartInfTab->noPhysicalMemoryAreas];
+    xm_s32_t s32a, noareas;
+
+    if(!is_xm_guest())
+        return 0;
+
+    XMIO_DEBUG("initializing...\n");
+    noareas = XM_get_physmem_map(mem_areas, xmPartInfTab->noPhysicalMemoryAreas);
+    BUG_ON(noareas != xmPartInfTab->noPhysicalMemoryAreas);
+
+    for (s32a=0; s32a<noareas; ++s32a) {
+        if (mem_areas[s32a].flags & XM_MEM_AREA_FLAG3) {
+            XMIO_DEBUG("Client: Found shared memory area: %x\n", mem_areas[s32a].startAddr);
+            mem_data.main = (void *)TO_VIRT(mem_areas[s32a].startAddr);
+            mem_data.size = mem_areas[s32a].size;
+            xmio_buffer_pool = xmio_init_pool((void *)mem_data.main,
+                                              mem_data.size,
+                                              4096|2048|512|128|64|16);
+            xm_setup_irq(XMIO_IRQ_TO_IPVI(XMIO_IRQ), xmio_client_irq, NULL);
+            return 0;
+        }
+    }
+
+    XMIO_DEBUG("Client: Shared memory area not found\n");
+    return -1; /* Shared memory area not found */
+}
+module_init(xmio_init);
+/*module_exit(xmio_exit);*/
+MODULE_LICENSE("GPL");
diff -Nur linux-3.0.34/arch/x86/xm/xmio/xmio_client.h linux-3.0.34-xm/arch/x86/xm/xmio/xmio_client.h
--- linux-3.0.34/arch/x86/xm/xmio/xmio_client.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.0.34-xm/arch/x86/xm/xmio/xmio_client.h	2013-01-13 23:14:53.000000000 +0100
@@ -0,0 +1,80 @@
+/*
+ * FILE: xmio_client.h
+ *
+ * XtratuM Device Virtualization, client side
+ *
+ * Authors: Jordi Sánchez, <jsanchez@ai2.upv.es>
+ *          Salva Peiró, <speiro@ai2.upv.es>
+ *
+ * $LICENSE:
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _XMIO_CLIENT_H_
+#define _XMIO_CLIENT_H_
+
+#include "xmio.h"
+
+/* XMIO Client interrupt definition */
+#define XMIO_IRQ               0
+#define XMIO_IRQ_TO_IPVI(IRQ)  (XM_VT_EXT_IPVI0+(IRQ))
+
+struct xmio_device;
+
+struct xmio_queue {
+   struct xmio_queue_shared *shared;       /* Queue shared header */
+   xm_u16_t avail;                                  /* Local index to the last buffer available */
+   xm_u16_t used;                                   /* Local index to the last used buffer */
+   xm_u32_t free_head;                              /* Pointer to the first free descriptor */
+   xm_u32_t free;                                   /* Free descriptors */
+   xm_u32_t nodescs;                                /* Number of buffer descriptors */
+   xm_u32_t *avail_pool;                            /* Available descriptor chain pool */
+   struct xmio_used *used_pool;                     /* Used descriptor chain pool */
+   struct xmio_desc *desc_pool;                     /* Descriptor pool */
+   struct xmio_device *xmdev;                       /* Device to which this queue belongs */
+   struct xmio_queue *next;                         /* Queue list */
+};
+
+struct xmio_device {
+    struct xmio_device_shared *shared;     /* Device shared header */
+    xm_u32_t type;                                  /* Device type */
+    xm_u32_t noqueues;                              /* Number of queues */
+    void (*callback)(struct xmio_device *xmdev);    /* 1 callback per device */
+    struct xmio_queue queues[];                     /* Device queues */
+};
+
+struct xmio_buffer {
+    void *addr;
+    xm_u32_t size;
+    xm_u32_t flags;
+};
+
+static inline xm_s32_t xmio_more_used(struct xmio_queue *xmque)
+{
+    return xmque->used != xmque->shared->used;
+}
+
+extern xm_s32_t xmio_raise_irq(xm_u32_t partition_id, xm_u8_t devirq);
+
+extern void xmio_clear_irq(xm_s32_t devirq);
+extern xm_s32_t xmio_setup_irq(xm_s32_t devirq, void (*handler)(void *), void *data);
+extern xm_s32_t xmio_add_request(struct xmio_queue *xmque, struct xmio_buffer chain[], xm_u32_t out, xm_u32_t in);
+extern xm_s32_t xmioclient_get_request(struct xmio_queue *xmque, xm_u32_t *len);
+extern xm_s32_t xmio_kick(struct xmio_queue *xmque);
+extern xm_s32_t xmio_find_queues(struct xmio_device *xmdev);
+extern void xmio_restart_device(struct xmio_device *xmdev);
+extern xm_u32_t xmio_scan(struct xmio_device_shared *shared[]);
+
+#endif //_XMIO_CLIENT_H_
diff -Nur linux-3.0.34/arch/x86/xm/xmio/xmio.h linux-3.0.34-xm/arch/x86/xm/xmio/xmio.h
--- linux-3.0.34/arch/x86/xm/xmio/xmio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.0.34-xm/arch/x86/xm/xmio/xmio.h	2013-01-13 23:14:53.000000000 +0100
@@ -0,0 +1,291 @@
+/*
+ * FILE: xmio.h
+ *
+ * XtratuM device virtualization engine definitions
+ *
+ * Authors: Jordi Sánchez, <jsanchez@ai2.upv.es>
+ *          Salva Peiró, <speiro@ai2.upv.es>
+ *
+ * $LICENSE:
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _XMIO_H_
+#define _XMIO_H_
+
+#define XMIO_DEBUG(fmt,...)
+//#define XMIO_DEBUG(fmt,...)         xprintk("["__FILE__":"__stringify(__LINE__)"] %s " fmt, __FUNCTION__, ## __VA_ARGS__)
+
+/* XtratuM server device */
+#define XM_MAJOR                   205
+
+/* XMVIO Device IDs */
+#define XMIO_ID_NETWORK            1
+#define XMIO_ID_BLOCK              2
+#define XMIO_ID_CONSOLE            3
+#define XMIO_ID_RNG                4
+#define XMIO_ID_BALLOON            5
+#define XMIO_ID_RTC                6
+#define XMIO_ID_EVENT              7
+#define XMIO_ID_FB                 8
+#define XMIO_ID_9P                 9
+#define XMIO_ID_MAX                10
+
+/* XMIO commands */
+#define XMIOCTL_CMD_OFFER       _IOW('X', 0x1, struct xmio_args)
+#define XMIOCTL_CMD_DETACH      _IOW('X', 0x2, struct xmio_args)
+#define XMIOCTL_CMD_STATUS      _IOW('X', 0x3, struct xmio_args)
+#define XMIOCTL_CMD_FOCUS       _IOW('X', 0x4, struct xmio_args)
+
+/* XMIO ioctl arguments */
+struct xmio_args {
+    int type;
+    int param;
+    char *file;
+    unsigned int bandwidth;                 /* Allocated bandwidth */
+};
+
+#if defined(CONFIG_XMIO_SERVER) || defined(CONFIG_XMIO_CLIENT) || \
+    defined(CONFIG_XMIO_SERVER_MODULE) || defined(CONFIG_XMIO_SERVER_MODULE)
+
+#include <xm.h>
+
+#include <linux/string.h>
+#include <linux/types.h>
+
+#include <asm/i387.h>
+#include <asm/asm.h>
+
+#define XMIO_MAIN_SIGNATURE     0x584d494f //"XMIO"
+#define XMIO_DEVICE_SIGNATURE   0x58444556 //"XDEV"
+#define XMIO_QUEUE_SIGNATURE    0x58515545 //"XQUE"
+
+/* XMVIO buffer flags */
+#define XMIO_BUFFER_WRITE       1
+#define XMIO_BUFFER_LAST        2
+#define XMIO_BUFFER_ERROR       0x80      /* Error code set by server */
+
+#define XMIO_AVAIL_SIZE(N)      (sizeof(xm_u32_t)*(N))
+#define XMIO_USED_SIZE(N)       (sizeof(struct xmio_used)*(N))
+#define XMIO_DESC_SIZE(N)       (sizeof(struct xmio_desc)*(N))
+
+#define XMIO_STATUS_ACKNOWLEDGE 1
+#define XMIO_STATUS_DRIVER      2
+#define XMIO_STATUS_DRIVER_OK   4
+#define XMIO_STATUS_FAILED      0x80
+
+#define XMIO_CMD_RESET          1
+#define XMIO_CMD_DETACH         2
+
+#define XMIO_MAX_DEVICES        32
+
+#define ALIGN_TO(X, A)  (((xm_u32_t)(X) + ((A)-1)) & ~((A)-1))
+
+/* XMVIO buffer descriptor (shared memory) */
+struct xmio_desc {
+    xm_u32_t addr;                  /* Physical address of the buffer */
+    xm_u16_t offset;                /* Data offset from addr */
+    xm_u16_t flags;                 /* Flags */
+    xm_u16_t size;                  /* Size of the buffer */
+    xm_u16_t next;                  /* Next descriptor */
+    void *orig;                     /* Pointer to the client original buffer */
+};
+
+/* XMVIO available descriptor chain (shared memory) */
+struct xmio_avail_elem {
+    xm_u16_t idx;
+    xm_u16_t chlen;                 /* Length of the buffer chain */
+};
+
+/* XMVIO used descriptor chain (shared memory) */
+struct xmio_used_elem {
+    xm_u32_t written;               /* In case of a write-only buffer, bytes written to it by the server */
+    xm_u32_t idx;
+};
+
+struct xmio_used {
+    xm_u32_t written;
+    xm_u32_t idx;
+};
+
+struct xmio_main_header {
+    xm_u32_t signature;             /* Main signature */
+    xm_u32_t client_irqpend;        /* Pending client irqs */
+    xm_u32_t server_irqpend;        /* Pending server irqs */
+    xmAddress_t devices[XMIO_MAX_DEVICES];/* Devices addresses */
+};
+
+/* XMVIO device (shared memory) */
+struct xmio_device_shared {
+    /* Server Write, Client Read */
+    xm_u32_t signature;             /* Device Signature */
+    xm_u32_t type;                  /* Device type */
+    xm_u32_t noqueues;              /* Number of queues */
+    xm_u16_t sid, sirq;             /* Server id and associated irq */
+    xm_u16_t cmd;                   /* Auxiliary command field */
+
+    /* Client Write, Server Read */
+    xm_u16_t status;                /* Connection status */
+    xm_u16_t cid, cirq;             /* Client id and associated irq */
+
+    /* Server Write */
+    xmAddress_t queue_addr;         /* First queue physical address */
+    xm_u32_t extlen;                /* Length of extended features */
+    xm_u8_t extdata[];              /* Extended features processed at device level, */
+};                                  /* not at transport level (xmio_server.c)       */
+
+/* XMIO queue (shared memory) */
+struct xmio_queue_shared {
+    /* Server Write, Client Read */
+    xm_u32_t signature;             /* Queue Signature */
+    xm_u32_t nodescs;               /* Number of buffer descriptors */
+    xm_u16_t used;                  /* Shared index to the last served request */
+
+    /* Client Write, Server Read */
+    xm_u16_t avail;                 /* Shared index to the last request */
+
+    /* Server Write */
+    xmAddress_t avail_addr;         /* These pointers are used for a more reliable */
+    xmAddress_t used_addr;          /* and simple performance of the client */
+    xmAddress_t desc_addr;
+
+    xmAddress_t next_addr;          /* Next queue physical address */
+};
+
+extern partitionInformationTable_t *xmPartInfTab;
+extern partitionControlTable_t *xmPartCtrTab;
+
+extern int xm_setup_irq(int irq, void (*action)(int, void *), void * data);
+extern int xm_raise_ipvi(int partitionId, int ipvi);
+static inline int is_xm_guest(void) { return ((!xmPartInfTab || xmPartInfTab->id) != 0); }
+extern int xprintk(const char*,...);
+
+static inline xm_u32_t xmio_queue_size(xm_u32_t nodescs)
+{
+    return sizeof(struct xmio_queue_shared) +
+           XMIO_AVAIL_SIZE(nodescs) +
+           XMIO_USED_SIZE(nodescs) +
+           XMIO_DESC_SIZE(nodescs);
+}
+
+/*
+ * Fast memcpy implementation for optimization purposes
+ * Author: Jordi Sánchez, <jsanchez@ai2.upv.es>
+ *
+ * Experimental:
+ *   - using SSE2
+ *   - Data must be aligned to 8-byte boundary
+ *   - Measured 430 MB/s at 2 GHz
+ */
+static void *_mmx_memcpy(void *to, const void *from, size_t len)
+{
+    void *p;
+    int i;
+
+    if (unlikely(in_interrupt()))
+        return __memcpy(to, from, len);
+
+    p = to;
+    i = len >> 6; /* len/64 */
+
+    kernel_fpu_begin();
+
+    __asm__ __volatile__ (
+        "1: prefetch (%0)\n"        /* This set is 28 bytes */
+        "   prefetch 64(%0)\n"
+        "   prefetch 128(%0)\n"
+        "   prefetch 192(%0)\n"
+        "   prefetch 256(%0)\n"
+        "2:  \n"
+        ".section .fixup, \"ax\"\n"
+        "3: movw $0x1AEB, 1b\n" /* jmp on 26 bytes */
+        "   jmp 2b\n"
+        ".previous\n"
+            _ASM_EXTABLE(1b, 3b)
+            : : "r" (from));
+
+    for ( ; i > 5; i--) {
+        __asm__ __volatile__ (
+        "1:  prefetch 320(%0)\n"
+        "2:  movq (%0), %%mm0\n"
+        "  movq 8(%0), %%mm1\n"
+        "  movq 16(%0), %%mm2\n"
+        "  movq 24(%0), %%mm3\n"
+        "  movq %%mm0, (%1)\n"
+        "  movq %%mm1, 8(%1)\n"
+        "  movq %%mm2, 16(%1)\n"
+        "  movq %%mm3, 24(%1)\n"
+        "  movq 32(%0), %%mm0\n"
+        "  movq 40(%0), %%mm1\n"
+        "  movq 48(%0), %%mm2\n"
+        "  movq 56(%0), %%mm3\n"
+        "  movq %%mm0, 32(%1)\n"
+        "  movq %%mm1, 40(%1)\n"
+        "  movq %%mm2, 48(%1)\n"
+        "  movq %%mm3, 56(%1)\n"
+        ".section .fixup, \"ax\"\n"
+        "3: movw $0x05EB, 1b\n" /* jmp on 5 bytes */
+        "   jmp 2b\n"
+        ".previous\n"
+            _ASM_EXTABLE(1b, 3b)
+            : : "r" (from), "r" (to) : "memory");
+
+        from += 64;
+        to += 64;
+    }
+
+    for ( ; i > 0; i--) {
+        __asm__ __volatile__ (
+        "  movq (%0), %%mm0\n"
+        "  movq 8(%0), %%mm1\n"
+        "  movq 16(%0), %%mm2\n"
+        "  movq 24(%0), %%mm3\n"
+        "  movq %%mm0, (%1)\n"
+        "  movq %%mm1, 8(%1)\n"
+        "  movq %%mm2, 16(%1)\n"
+        "  movq %%mm3, 24(%1)\n"
+        "  movq 32(%0), %%mm0\n"
+        "  movq 40(%0), %%mm1\n"
+        "  movq 48(%0), %%mm2\n"
+        "  movq 56(%0), %%mm3\n"
+        "  movq %%mm0, 32(%1)\n"
+        "  movq %%mm1, 40(%1)\n"
+        "  movq %%mm2, 48(%1)\n"
+        "  movq %%mm3, 56(%1)\n"
+            : : "r" (from), "r" (to) : "memory");
+
+        from += 64;
+        to += 64;
+    }
+    /*
+     * Now do the tail of the block:
+     */
+    __memcpy(to, from, len & 63);
+    kernel_fpu_end();
+
+    return p;
+}
+
+static inline void *xmio_memcpy(void *to, const void *from, size_t len)
+{
+    if (len > 64) {
+        return _mmx_memcpy(to, from, len);
+    } else {
+        return __memcpy(to, from, len);
+    }
+}
+#endif // CONFIG_XMIO_SERVER || CONFIG_XMIO_CLIENT
+
+#endif //_XMIO_H_
diff -Nur linux-3.0.34/arch/x86/xm/xmio/xmio_server.c linux-3.0.34-xm/arch/x86/xm/xmio/xmio_server.c
--- linux-3.0.34/arch/x86/xm/xmio/xmio_server.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.0.34-xm/arch/x86/xm/xmio/xmio_server.c	2013-01-13 23:14:53.000000000 +0100
@@ -0,0 +1,570 @@
+/*
+ * FILE: xmio_server.c
+ *
+ * XtratuM device virtualization engine server
+ *
+ * Author: Jordi Sánchez, <jsanchez@ai2.upv.es>
+ * Changes: Salva Peiró, <speiro@ai2.upv.es>
+ *
+ * $LICENSE:
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include "xmio_server.h"
+
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/major.h>
+#include <linux/miscdevice.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+#include <linux/module.h>
+
+
+#define XMIO_CLIENT_NODE            "xmcli"
+
+#define BIT_SET(NR, ADDR)           __set_bit(NR, (volatile unsigned long *)(ADDR))
+#define BIT_CLEAR(NR, ADDR)         __clear_bit(NR, (volatile unsigned long *)(ADDR))
+
+static void (*xmio_handler[XMIO_ID_MAX])(void);
+static struct class *xmio_class;
+static struct xmio_device *devices[XMIO_ID_MAX] = { [0 ... (XMIO_ID_MAX-1)] = 0};
+static struct xmio_client *clients;
+static xm_s32_t noclients;
+
+/*
+ * The following implements a best_fit memory allocator with no coalescing
+ */
+static void xmio_free(struct xmio_client *client, void *addr)
+{
+    struct xmio_mem_block *blk = NULL;
+    struct xmio_list *list;
+
+    for (list=client->pool.u_list; list!=NULL; list=list->next) {
+        blk = list->this;
+        if (blk->addr == addr) {
+            xmio_list_delete(&client->pool.u_list, &blk->list);
+            break;
+        }
+    }
+    if (blk != NULL) {
+        xmio_list_insert(&client->pool.f_list, &blk->list);
+    }
+}
+
+static void *xmio_alloc(struct xmio_client *client, xm_u32_t size)
+{
+    struct xmio_mem_block *blk, *min;
+    xm_u32_t best_fit = client->size;
+    struct xmio_list *list;
+    void *ptr = NULL;
+
+    min = NULL;
+    for (list=client->pool.f_list; list!=NULL; list=list->next) {
+        blk = list->this;
+        if (size <= blk->size) {
+            if (blk->size < best_fit) {
+                min = blk;
+                best_fit = blk->size;
+            }
+        }
+    }
+
+    if (min == NULL) {
+        min = kzalloc(sizeof(struct xmio_mem_block), GFP_KERNEL);
+        min->addr = client->pool.free;
+        min->size = size;
+        min->list.this = min;
+        client->pool.free = (void *)ALIGN_TO((client->pool.free+size), 8);
+    }
+
+    if (likely(min != NULL)) {
+        xmio_list_delete(&client->pool.f_list, &min->list);                                         /* This works OK even if min has been allocated with kzalloc */
+        xmio_list_insert(&client->pool.u_list, &min->list);
+        ptr = min->addr;
+    }
+
+    if (likely(ptr != NULL)) {
+        memset(ptr, 0, size);
+    }
+
+    return ptr;
+}
+
+/*
+ * xmio_get_buf
+ *
+ *  Recovers a buffer described by @desc and stores the references to @iov. This
+ *  function also checks the pointer
+ */
+static inline xm_s32_t xmio_get_buf(struct xmio_queue *xmque, struct xmio_desc *desc, struct kvec *iov)
+{
+    void *addr;
+    xm_u32_t size;
+    struct xmio_client *client = xmque->connect->client;
+
+    addr = __va(desc->addr) + desc->offset;
+    size = desc->size;
+
+    if (addr > (void *)client->main &&
+        (((void *)client->main + client->size) - addr > size)) {
+        iov->iov_len = size;
+        iov->iov_base = addr;
+        return 0;
+    }
+
+    return -1;
+}
+
+static void xmio_server_irq(xm_s32_t vector, void *data)
+{
+    xm_u32_t mask, u32a;
+
+    mask = 0;
+    for (u32a=0; u32a<noclients; ++u32a) {
+        mask |= (clients[u32a].main->client_irqpend & clients[u32a].irq_mask);  /* Only allowed irqs */
+        clients[u32a].main->client_irqpend = 0;                                 /* Clear all pending irqs as we are supposed to */
+    }                                                                           /* process them all                             */
+
+    while (mask) {
+        u32a = __ffs(mask);
+        if (xmio_handler[u32a] != NULL) {
+            xmio_handler[u32a]();
+        }
+        BIT_CLEAR(u32a, &mask);
+    }
+}
+
+xm_s32_t xmioserver_setup_irq(struct xmio_client *client, xm_s32_t devirq, void (*handler)(void))
+{
+    xm_s32_t s32a = -1;
+
+    if (devirq >= 0 && devirq < XMIO_ID_MAX) {
+        xmio_handler[devirq] = handler;
+        BIT_SET(devirq, &client->irq_mask);
+        s32a = 0;
+    }
+
+    return s32a;
+}
+EXPORT_SYMBOL(xmioserver_setup_irq);
+
+static void xmio_clear_irq(struct xmio_client *client, xm_s32_t devirq)
+{
+    if (devirq >= 0 && devirq < XMIO_ID_MAX) {
+        xmio_handler[devirq] = 0;
+        BIT_CLEAR(devirq, &client->irq_mask);
+    }
+}
+
+/*
+ * xmio_get_request
+ *
+ *  A request is a pointer to a buffer chain referring to its physical location.
+ *  Request checks must be performed upwards, by each specific device.
+ */
+xm_s32_t xmioserver_get_request(struct xmio_queue *xmque, struct kvec iov[], xm_s32_t *out, xm_s32_t *in)
+{
+    xm_s32_t s32a, head;
+    struct xmio_desc *desc;
+
+    if (!xmio_more_requests(xmque)) {                                           /* Double checked if using bw accounting */
+        return -1;
+    }
+
+    s32a = head = xmque->avail_pool[xmque->avail];
+    if (head > xmque->nodescs) {
+        return -2;
+    }
+
+    *out = *in = 0;
+    do {
+        if (s32a < 0 || s32a > xmque->nodescs) {                       /* Bad descriptor number */
+            /* TODO: Recover queue */
+            return -2;
+        }
+        desc = &xmque->desc_pool[s32a];
+        if (xmio_get_buf(xmque, desc, &iov[*out + *in]) < 0) {
+            return -2;
+        }
+        if (desc->flags & XMIO_BUFFER_WRITE) {
+            (*in)++;
+        } else {
+            (*out)++;
+        }
+        if (*out + *in > xmque->nodescs) {
+            /* TODO: bad request, no last buffer found */
+            return -2;
+        }
+        s32a = desc->next;
+    } while (!(desc->flags & XMIO_BUFFER_LAST));
+
+    xmque->avail = (xmque->avail + 1) % xmque->nodescs;
+
+    return head;
+}
+EXPORT_SYMBOL(xmioserver_get_request);
+
+/*
+ * xmio_request_served
+ *  @idx: descriptor chain start index
+ */
+void xmio_request_served(struct xmio_queue *xmque, xm_s32_t idx, xm_u32_t written)
+{
+    xmque->used_pool[xmque->used].idx = idx;
+    xmque->used_pool[xmque->used].written = written;
+    xmque->used = (xmque->used + 1) % xmque->nodescs;
+    xmque->shared->used = xmque->used;
+    BIT_SET(xmque->connect->shared->cirq, &xmque->connect->client->main->server_irqpend);
+    xm_raise_ipvi(xmque->connect->shared->cid, XMIO_IRQ);
+}
+EXPORT_SYMBOL(xmio_request_served);
+
+struct xmio_connection *xmio_connection_new(struct xmio_device *xmdev, struct xmio_client *client)
+{
+    struct xmio_connection *conn;
+
+    conn = kzalloc(sizeof(struct xmio_connection), GFP_KERNEL);
+    if (conn != NULL) {
+        conn->device = xmdev;
+        conn->client = client;
+        conn->queues = kzalloc(sizeof(struct xmio_queue) * xmdev->noqueues, GFP_KERNEL);
+
+        if (conn->queues != NULL) {
+            conn->shared = xmio_alloc(client, sizeof(struct xmio_device_shared) + xmdev->extlen);
+            if (conn->shared != NULL) {
+                memcpy((void *)conn->shared->extdata, xmdev->extdata, xmdev->extlen);   /* Extended features */
+                conn->shared->extlen = xmdev->extlen;
+                conn->shared->type = xmdev->type;
+                conn->shared->sid = XM_PARTITION_SELF;
+                conn->shared->sirq = xmdev->irq;
+                conn->shared->noqueues = xmdev->noqueues;
+
+                wmb();
+            } else {
+                kfree(conn->queues);
+                kfree(conn);
+                conn = NULL;
+            }
+        } else {
+            kfree(conn);
+            conn = NULL;
+        }
+    }
+    if (conn != NULL) {
+        conn->list.this = conn;
+        xmio_list_insert(&xmdev->connects[client->id], &conn->list);
+    }
+
+    return conn;
+}
+EXPORT_SYMBOL(xmio_connection_new);
+
+void xmio_connection_start(struct xmio_connection *conn)
+{
+    xm_u32_t u32a;
+
+    conn->shared->queue_addr = __pa(conn->queues[0].shared);        /* Set addresses */
+    for (u32a=1; u32a<conn->device->noqueues; ++u32a) {
+        conn->queues[u32a-1].shared->next_addr = __pa(conn->queues[u32a].shared);
+    }
+
+    for (u32a=0; u32a<XMIO_MAX_DEVICES; ++u32a) {                   /* Look for an empty slot and publish the device */
+        if (conn->client->main->devices[u32a] == 0) {
+            conn->index = u32a;
+            xmio_send_command(conn, XMIO_CMD_RESET);
+            conn->client->main->devices[u32a] = __pa(conn->shared);
+            break;
+        }
+    }
+}
+EXPORT_SYMBOL(xmio_connection_start);
+
+void xmio_connection_reset(struct xmio_connection *conn)
+{
+    xm_u32_t u32a;
+    struct xmio_queue *queue;
+
+    BIT_CLEAR(conn->device->irq, &conn->client->irq_mask);
+    for (u32a=0; u32a<conn->device->noqueues; ++u32a) {
+        queue = &conn->queues[u32a];
+        queue->avail = 0;
+        queue->used = 0;
+        queue->shared->avail = 0;
+        queue->shared->used = 0;
+    }
+    xmio_connection_start(conn);
+    BIT_SET(conn->device->irq, &conn->client->irq_mask);
+}
+EXPORT_SYMBOL(xmio_connection_reset);
+
+void xmio_connection_finish(struct xmio_connection *conn)
+{
+    xm_u32_t u32a;
+    struct xmio_queue *queue;
+
+    xmio_clear_irq(conn->client, conn->device->irq);
+
+    for (u32a=0; u32a<conn->device->noqueues; ++u32a) {
+        queue = &conn->queues[u32a];
+        xmio_free(conn->client, (void*)queue);
+    }
+    xmio_free(conn->client, conn->shared);
+    conn->client->main->devices[conn->index] = 0;
+    xmio_list_delete(&conn->device->connects[conn->client->id], &conn->list);
+
+    kfree(conn->queues);
+    kfree(conn);
+}
+EXPORT_SYMBOL(xmio_connection_finish);
+
+void xmio_send_command(struct xmio_connection *conn, xm_u32_t cmd)
+{
+    conn->shared->cmd = cmd;
+    BIT_SET(conn->shared->cirq, &conn->client->main->server_irqpend);
+    wmb();
+    xm_raise_ipvi(conn->shared->cid, XMIO_IRQ);
+}
+EXPORT_SYMBOL(xmio_send_command);
+
+xm_s32_t xmio_init_queue(struct xmio_connection *conn, struct xmio_queue *queue, xm_u32_t nodescs)
+{
+    xm_s32_t ret = -1;
+
+    if (likely(queue != NULL)) {
+        queue->avail = 0;
+        queue->used = 0;
+        queue->nodescs = nodescs;
+        queue->usage.bw = 1;                                        /* Initially, all queues receive fair amount of bw */
+        queue->connect = conn;
+
+        /* TODO: CHECK_ROOM, Is there enough space for the queue? */
+
+        queue->shared = xmio_alloc(conn->client, sizeof(struct xmio_queue_shared));
+        queue->avail_pool = xmio_alloc(conn->client, XMIO_AVAIL_SIZE(nodescs));
+        queue->used_pool = xmio_alloc(conn->client, XMIO_USED_SIZE(nodescs));
+        queue->desc_pool = xmio_alloc(conn->client, XMIO_DESC_SIZE(nodescs));
+
+        queue->shared->nodescs = nodescs;
+        queue->shared->avail_addr = (xm_u32_t)__pa(queue->avail_pool);
+        queue->shared->used_addr = (xm_u32_t)__pa(queue->used_pool);
+        queue->shared->desc_addr = (xm_u32_t)__pa(queue->desc_pool);
+
+        queue->shared->signature = XMIO_QUEUE_SIGNATURE;
+
+        wmb();
+
+        ret = 0;
+    }
+
+    return ret;
+}
+EXPORT_SYMBOL(xmio_init_queue);
+
+xm_s32_t xmio_register_device(struct xmio_device *device)
+{
+    xm_s32_t s32a = -1;
+
+    if (device != NULL) {
+        if (device->type >= 0 && device->type < XMIO_ID_MAX) {
+            if (devices[device->type] == NULL) {
+                device->connects = kzalloc(sizeof(struct xmio_list *)*noclients, GFP_KERNEL);
+                devices[device->type] = device;
+                s32a = 0;
+            }
+        }
+    }
+
+    return s32a;
+}
+EXPORT_SYMBOL(xmio_register_device);
+
+struct xmio_client *xmio_get_clients(void)
+{
+    return clients;
+}
+EXPORT_SYMBOL(xmio_get_clients);
+
+xm_s32_t xmio_noclients(void)
+{
+    return noclients;
+}
+EXPORT_SYMBOL(xmio_noclients);
+
+static char *xmio_id_str[XMIO_ID_MAX] = {
+    [0]               = "",
+    [XMIO_ID_NETWORK] = "net",
+    [XMIO_ID_BLOCK]   = "blk",
+    [XMIO_ID_CONSOLE] = "con",
+    [XMIO_ID_RNG]     = "rng",
+    [XMIO_ID_BALLOON] = "bal",
+    [XMIO_ID_RTC]     = "rtc",
+    [XMIO_ID_EVENT]   = "evt",
+    [XMIO_ID_FB]      = "fb",
+    [XMIO_ID_9P]      = "9p",
+};
+
+static int xmdev_procinfo(char *buf, char **start, off_t offset, int count, int *eof, void *data)
+{
+    int i, j, len = 0;
+    int limit = count - 80;
+    struct xmio_list *list;
+    struct xmio_device *dev;
+
+    len += sprintf(buf+len, "XtratuM version %s: build revision: %s\n\n",
+            CONFIG_KERNELVERSION, CONFIG_XM_BUILDREVISION);
+
+    for (i=0; i<noclients && len <= limit; i++) {
+        for (j=0; j<XMIO_ID_MAX && len <= limit; j++) {
+            dev = devices[j];
+            if (!dev)
+                continue;
+            for(list=dev->connects[i]; list; list=list->next) {
+                if(dev->type == XMIO_ID_BLOCK) {
+                    char data[256];
+                    struct xmio_connection *con=list->this;
+                    struct xmblk_control *ctrl = con->priv;
+                    if (ctrl && ctrl->file && !IS_ERR(ctrl->file)) {
+                        char *name = d_path(&ctrl->file->f_path, data, sizeof(data));
+                        len += sprintf(buf+len, "Client%d: dev: %s (%d) irq: %d state: %s (%x)",
+                                i, xmio_id_str[dev->type], dev->type, dev->irq, dev->status==0?"ok":"ko", dev->status);
+                        len += sprintf(buf+len, " disk%d: %s size: %lld bytes\n",
+                                ctrl->id, IS_ERR(name)? "" : name, ctrl->len);
+                    }
+                }else{
+                    len += sprintf(buf+len, "Client%d: dev: %s (%d) irq: %d state: %s (%x)\n",
+                        i, xmio_id_str[dev->type], dev->type, dev->irq, dev->status==0?"ok":"ko", dev->status);
+                }
+            }
+        }
+    }
+
+    *eof = 1;
+    return len;
+}
+
+static long xmio_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	struct inode *inode = filp->f_dentry->d_inode;
+    int minor = iminor(inode);
+    struct xmio_client *client;
+    struct xmio_device *device;
+    struct xmio_args args;
+
+    if (copy_from_user(&args, (char *)arg, sizeof(struct xmio_args)) != 0) {
+        return -EFAULT;
+    }
+
+    if (args.type < 0 || args.type >= XMIO_ID_MAX)
+        return -EINVAL;
+    device=devices[args.type];
+    if (!device)
+        return -EINVAL;
+
+    if (minor < 0 || minor > noclients)
+        return -EINVAL;
+    client=&clients[minor];
+
+    if(!client)
+        return -ENXIO;
+
+    switch (cmd) {
+    default:
+        return -EINVAL;
+
+    case XMIOCTL_CMD_OFFER:
+    case XMIOCTL_CMD_DETACH:
+    case XMIOCTL_CMD_FOCUS:
+        return device->ioctl(client, cmd, (void*)&args);
+
+    }
+    return 0;
+}
+
+static struct file_operations xmio_fops = {
+    .owner = THIS_MODULE,
+    .unlocked_ioctl = xmio_ioctl,
+};
+
+/*
+ * xmio_init
+ *
+ * Currently, we force all the clients to initialize correctly. If an
+ * error occurs, the function returns immediately, which may leave
+ * broken data on the system. Nevertheless, this function should never
+ * fail at initialization
+ */
+
+static int __init xmio_init(void)
+{
+    struct xmcMemoryArea mem_areas[xmPartInfTab->noPhysicalMemoryAreas];
+    struct xmio_client cls[xmPartInfTab->noPhysicalMemoryAreas];
+    struct device *device;
+    xm_s32_t s32a, noareas;
+    dev_t dev = 0;
+
+    if(is_xm_guest())
+        return 0;
+
+    XMIO_DEBUG("initializing...\n");
+    noareas = XM_get_physmem_map(mem_areas, xmPartInfTab->noPhysicalMemoryAreas);
+    BUG_ON(noareas != xmPartInfTab->noPhysicalMemoryAreas);
+
+    xmio_class = class_create(THIS_MODULE, XMIO_CLIENT_NODE);               /* Create class */
+    if (IS_ERR(xmio_class)) {
+        pr_debug("server class could not be created\n");
+        return PTR_ERR(xmio_class);
+    }
+    if (register_chrdev(XM_MAJOR, XMIO_CLIENT_NODE, &xmio_fops)) {          /* Register device as char */
+        pr_debug("server device structure could not be registered\n");
+        return -1;
+    }
+
+    memset(cls, 0, sizeof(cls));
+    for (s32a=0; s32a<noareas; ++s32a) {
+        if (mem_areas[s32a].flags & XM_MEM_AREA_FLAG3) {
+            cls[noclients].main = (void *)__va(mem_areas[s32a].startAddr);
+            memset(cls[noclients].main, 0, sizeof(struct xmio_main_header));
+            cls[noclients].size = mem_areas[s32a].size;
+            cls[noclients].id = noclients;
+            cls[noclients].pool.free = (void *)ALIGN_TO(cls[noclients].main + 1, 16);
+            cls[noclients].main->signature = XMIO_MAIN_SIGNATURE;
+
+            dev = MKDEV(XM_MAJOR, noclients);
+            device = device_create(xmio_class, NULL, dev, NULL, "%s%d", XMIO_CLIENT_NODE, noclients);
+            if (IS_ERR(device)) {
+                pr_debug("server device creation failed\n");
+                return PTR_ERR(device);
+            }
+
+            noclients++;
+        }
+    }
+
+    clients = kzalloc(sizeof(struct xmio_client)*noclients, GFP_KERNEL);
+    memcpy(clients, cls, sizeof(struct xmio_client)*noclients);
+    create_proc_read_entry("xminfo", 0, NULL, xmdev_procinfo, NULL);
+    
+    xm_setup_irq(XMIO_IRQ_TO_IPVI(XMIO_IRQ), xmio_server_irq, NULL);
+
+    pr_debug("found %d clients\n", noclients);
+    return 0;
+}
+
+module_init(xmio_init);
+/*module_exit(xmio_exit);*/
+MODULE_LICENSE("GPL");
diff -Nur linux-3.0.34/arch/x86/xm/xmio/xmio_server.h linux-3.0.34-xm/arch/x86/xm/xmio/xmio_server.h
--- linux-3.0.34/arch/x86/xm/xmio/xmio_server.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.0.34-xm/arch/x86/xm/xmio/xmio_server.h	2013-01-13 23:14:53.000000000 +0100
@@ -0,0 +1,177 @@
+/*
+ * FILE: xmio_server.h
+ *
+ * XtratuM device virtualization engine server
+ *
+ * Authors: Jordi Sánchez, <jsanchez@ai2.upv.es>
+ *          Salva Peiró, <speiro@ai2.upv.es>
+ *
+ * $LICENSE:
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef _XMIO_SERVER_H_
+#define _XMIO_SERVER_H_
+
+#include "xmio.h"
+#include <linux/uio.h>
+#include <linux/list.h>
+
+/* XMIO Server interrupt definition */
+#define XMIO_IRQ                0
+#define XMIO_IRQ_TO_IPVI(IRQ)   (XM_VT_EXT_IPVI0+(IRQ))
+
+#define XMIO_ACCOUNT_DELTA      100                 /* Shrink factor */
+#define XMIO_ACCOUNT_TMOUT      3000                /* Timeout for shrink operation (ms) */
+#define XMIO_TIMEOUT            3000
+
+/* TODO: Should define error codes */
+
+struct xmio_client;
+struct xmio_device;
+struct xmio_queue;
+
+struct xmio_usage {
+    xm_u32_t bw;                                    /* Allocated bandwidth */
+    xm_u32_t effort;                                /* = (time * bw) */
+    xm_u32_t bytes;                                 /* = bytes_Transferred */
+    xm_u32_t ratio;                                 /* = effort / bytes */
+};
+
+struct xmio_account {
+    struct xmio_queue *list;
+    xmTime_t last_time;
+};
+
+struct xmio_queue {
+    struct xmio_queue_shared *shared;      /* Queue shared header */
+    xm_u32_t *avail_pool;                           /* Available descriptor chain pool */
+    struct xmio_used *used_pool;                    /* Used descriptor chain pool */
+    struct xmio_desc *desc_pool;                    /* Descriptor pool */
+    xm_u16_t avail;                                 /* Local index to the last buffer available */
+    xm_u16_t used;                                  /* Local index to the last used buffer */
+    xm_u32_t nodescs;                               /* Number of descriptors */
+    struct xmio_usage usage;                        /* Bandwidth accounting */
+    struct xmio_connection *connect;                /* Device to which this queue belongs */
+    struct xmio_queue *next;                        /* Used by accounting module */
+};
+
+struct xmio_list {
+    void *this;
+    struct xmio_list *prev, *next;
+};
+
+struct xmio_mem_block {
+    void *addr;                                     /* Block start address */
+    xm_u32_t size;                                  /* Block size */
+    struct xmio_list list;
+};
+
+struct xmio_pool {
+    void *free;                                     /* Current free pointer */
+    struct xmio_list *f_list, *u_list;
+};
+
+struct xmio_client {
+    xm_u32_t id;                                    /* Local client id reference */
+    struct xmio_main_header *main;         /* Shared main header */
+    struct xmio_pool pool;                          /* Device memory pool */
+    xm_u32_t size;                                  /* Size of shared memory */
+    struct xmio_connection *connects;               /* Client connections */
+    xm_u32_t irq_mask;                              /* Masked irqs */
+};
+
+struct xmio_device {
+    xm_u32_t type;                                                            /* Device type */
+    xm_u32_t irq;                                                             /* IRQ */
+    xm_u32_t status;                                                          /* Device status */
+    xm_u32_t noqueues;                                                        /* Number of queues */
+    xm_u32_t extlen;                                                          /* Length of extended features */
+    void *extdata;                                                            /* Extended data (shared) */
+    int (*ioctl)(struct xmio_client *, unsigned int cmd, struct xmio_args *); /* Device ioctl handler */
+    struct xmio_list **connects;                                              /* Device connections */
+};
+
+struct xmio_connection {
+    xm_u32_t index;
+    struct xmio_device_shared *shared;
+    struct xmio_client *client;
+    struct xmio_device *device;
+    struct xmio_queue *queues;
+    xm_u32_t status;                                /* Connection status */
+    void *priv;                                     /* Private connection data */
+
+    struct xmio_list list;                          /* There may be several connections between a */
+};                                                  /* single device and a single client          */
+
+struct xmblk_control {
+    xm_u32_t id;        /* Connection identifier */
+    loff_t len;         /* The size of the file. */
+    struct file *file;  /* The file pointer for the file. */
+};
+
+static inline void xmio_list_delete(struct xmio_list **head, struct xmio_list *list)
+{
+    if (list->prev) {
+        list->prev->next = list->next;
+    }
+    if (list->next) {
+        list->next->prev = list->prev;
+    }
+    if (*head == list) {
+        *head = (*head)->next;
+    }
+    list->next = NULL;
+    list->prev = NULL;
+}
+
+static inline void xmio_list_insert(struct xmio_list **head, struct xmio_list *list)
+{
+    list->next = *head;
+    *head = list;
+    if (list->next != NULL) {
+        list->next->prev = list;
+    }
+}
+
+static inline void *xmio_list_get_head(struct xmio_list *head)
+{
+    if (head) {
+        return head->this;
+    }
+    return NULL;
+}
+
+static inline xm_s32_t xmio_more_requests(struct xmio_queue *xmque)
+{
+    return xmque->avail != xmque->shared->avail;
+}
+
+extern xm_s32_t xmio_noclients(void);
+extern struct xmio_client *xmio_get_clients(void);
+extern xm_s32_t xmio_register_device(struct xmio_device *device);
+extern void xmio_send_command(struct xmio_connection *conn, xm_u32_t cmd);
+
+extern struct xmio_connection *xmio_connection_new(struct xmio_device *xmdev, struct xmio_client *client);
+extern void xmio_connection_start(struct xmio_connection *conn);
+extern void xmio_connection_reset(struct xmio_connection *conn);
+extern void xmio_connection_finish(struct xmio_connection *conn);
+extern xm_s32_t xmioserver_get_request(struct xmio_queue *xmque, struct kvec iov[], xm_s32_t *out, xm_s32_t *in);
+extern void xmio_request_served(struct xmio_queue *xmque, xm_s32_t idx, xm_u32_t written);
+
+extern xm_s32_t xmio_init_queue(struct xmio_connection *conn, struct xmio_queue *queue, xm_u32_t nodescs);
+extern xm_s32_t xmioserver_setup_irq(struct xmio_client *client, xm_s32_t devirq, void (*handler)(void));
+
+#endif //_XMIO_SERVER_H_
diff -Nur linux-3.0.34/arch/x86/xm/xmio/xmio_virtio.c linux-3.0.34-xm/arch/x86/xm/xmio/xmio_virtio.c
--- linux-3.0.34/arch/x86/xm/xmio/xmio_virtio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.0.34-xm/arch/x86/xm/xmio/xmio_virtio.c	2013-01-13 23:14:53.000000000 +0100
@@ -0,0 +1,444 @@
+/*
+ * FILE: xmio_virtio.c
+ *
+ * XMIO wrapper implementation for virtio
+ *
+ * Author: Jordi Sánchez, <jsanchez@ai2.upv.es>
+ * Detach Fixes: Salva Peiró, <speiro@ai2.upv.es>
+ *
+ * $LICENSE:
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "xmio_client.h"
+#include "xmio_virtio.h"
+
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/module.h>
+
+#include <linux/virtio.h>
+#include <linux/virtio_config.h>
+#include <linux/virtio_console.h>
+
+#define to_xmque(_vq)   container_of(_vq, struct xmio_virtio_queue, vq)
+#define to_xmdev(_vdev) container_of(_vdev, struct xmio_virtio_device, vdev)
+#define BAD_RING(...)
+
+struct xmio_virtio_queue {
+    struct virtqueue vq;
+    struct xmio_queue *xmque;
+    bool broken;                                                /* Broken queue */
+    bool active;                                                /* Receiving callbacks */
+    void *data[];                                               /* Tokens for callbacks. */
+};
+
+struct xmio_virtio_device {
+    struct virtio_device vdev;
+    struct xmio_device_shared *shared;
+    struct xmio_device *xmdev;
+    struct xmio_virtio_queue **xmvqs;
+};
+
+/* The root device for the xm virtio devices. */
+static struct device *xm_root;
+static struct delayed_work xmio_scan_work;
+static struct delayed_work xmio_detach_work;
+
+int virtqueue_add_buf_gfp(struct virtqueue *vq,
+			  struct scatterlist sg[],
+			  unsigned int out,
+			  unsigned int in,
+			  void *data,
+			  gfp_t gfp)
+{
+    struct xmio_virtio_queue *xvque;
+    int head, i, iout, iin;
+    struct xmio_buffer chain[out+in];
+
+    xvque = to_xmque(vq);
+
+    BUG_ON(data == NULL);
+    BUG_ON(out + in > xvque->xmque->nodescs);
+    BUG_ON(out + in == 0);
+
+    if (xvque->xmque->free < out + in + 1) {
+#if 0
+        if (out) {                                              /* This is done in Virtio, but it's not really necessary */
+            xmio_kick(xvque->xmque);
+        }
+#endif
+        return -ENOSPC;
+    }
+
+    iout = out;
+    iin = in;
+    for (i=0; out; --out, ++i) {
+        chain[i].addr = __va(sg_phys(sg));                      /* We do it this way so, instead of sg_virt,       */
+        chain[i].size = sg->length;                             /* __pa() can be used to decode virtual address    */
+        chain[i].flags = 0;
+        ++sg;
+    }
+    for (; in; --in, ++i) {
+        chain[i].addr = __va(sg_phys(sg));
+        chain[i].size = sg->length;
+        chain[i].flags = XMIO_BUFFER_WRITE;
+        ++sg;
+    }
+
+    head = xmio_add_request(xvque->xmque, chain, iout, iin);
+    if (unlikely(head < 0)) {
+        return -EIO;
+    }
+
+    /* Set token. */
+    xvque->data[head] = data;
+
+    return xvque->xmque->free;
+}
+EXPORT_SYMBOL(virtqueue_add_buf_gfp);
+
+/* XXX: Recover a full chain */
+void *virtqueue_get_buf(struct virtqueue *vq, unsigned int *len)
+{
+    struct xmio_virtio_queue *xvque;
+    void *ret;
+    unsigned int head;
+
+    xvque = to_xmque(vq);
+
+    if (unlikely(xvque->broken)) {
+        return NULL;
+    }
+
+    if (!xmio_more_used(xvque->xmque)) {                        /* No more buffers used */
+        return NULL;
+    }
+
+    head = xmioclient_get_request(xvque->xmque, len);
+    if (unlikely(head >= xvque->xmque->nodescs)) {
+        BAD_RING(vq, "id %u out of range\n", head);
+        return NULL;
+    }
+    if (unlikely(!xvque->data[head])) {
+        BAD_RING(vq, "id %u is not a head!\n", head);
+        return NULL;
+    }
+
+    ret = xvque->data[head];
+    xvque->data[head] = NULL;
+
+    return ret;
+}
+EXPORT_SYMBOL(virtqueue_get_buf);
+
+void virtqueue_kick(struct virtqueue *vq)
+{
+    struct xmio_virtio_queue *xvque;
+    xvque = to_xmque(vq);
+    xmio_kick(xvque->xmque);
+}
+EXPORT_SYMBOL(virtqueue_kick);
+
+void virtqueue_disable_cb(struct virtqueue *vq)
+{
+    to_xmque(vq)->active = false;
+}
+EXPORT_SYMBOL(virtqueue_disable_cb);
+
+bool virtqueue_enable_cb(struct virtqueue *vq)
+{
+    to_xmque(vq)->active = true;
+    return true;
+}
+EXPORT_SYMBOL(virtqueue_enable_cb);
+
+bool virtqueue_enable_cb_delayed(struct virtqueue *vq)
+{
+    virtqueue_enable_cb(vq);
+	return true;
+}
+EXPORT_SYMBOL(virtqueue_enable_cb_delayed);
+
+/*
+ * xmio_virtio_detach_unused_buf
+ *
+ *  Currently, this function is only called when a virtual
+ *  driver is about to be destroyed.
+ */
+void *virtqueue_detach_unused_buf(struct virtqueue *vq)
+{
+    /* How to free all the allocated buffers? */
+    return NULL;
+}
+EXPORT_SYMBOL(virtqueue_detach_unused_buf);
+
+static struct xmio_virtio_device *xvdev_detach=0;
+static void xmio_virtio_irqhandler(void *data)
+{
+    struct xmio_virtio_device *xvdev=data;
+    int q;
+
+    if (xvdev->shared->cmd == XMIO_CMD_DETACH) {/* The only command so far */
+        xvdev_detach=xvdev;
+        schedule_delayed_work(&xmio_detach_work, 0);
+        return;
+    }
+
+    for (q=0; q<xvdev->xmdev->noqueues; ++q) {
+        if (xmio_more_used(&xvdev->xmdev->queues[q])) {
+            if (xvdev->xmvqs[q]->active) {
+                xvdev->xmvqs[q]->vq.callback(&xvdev->xmvqs[q]->vq);
+            }
+        }
+    }
+}
+
+static u32 xmio_get_features(struct virtio_device *vdev)
+{
+    struct xmio_virtio_device *xvdev;
+    struct xmio_virtio_features *features;
+
+    xvdev = to_xmdev(vdev);
+    features = (struct xmio_virtio_features *)xvdev->shared->extdata;
+
+    return features->offered;
+}
+
+static void xmio_finalize_features(struct virtio_device *vdev)
+{
+    struct xmio_virtio_device *xvdev;
+    struct xmio_virtio_features *features;
+
+    xvdev = to_xmdev(vdev);
+    features = (struct xmio_virtio_features *)xvdev->shared->extdata;
+
+    features->accepted = vdev->features[0];
+}
+
+static inline void set_status(struct virtio_device *vdev, u8 status)
+{
+    struct xmio_virtio_device *xvdev;
+
+    xvdev = to_xmdev(vdev);
+    xvdev->shared->status = status;
+    xmio_raise_irq(xvdev->shared->sid, xvdev->shared->sirq);
+}
+
+static void xmio_set_status(struct virtio_device *vdev, u8 status)
+{
+    BUG_ON(!status);
+    set_status(vdev, status);
+}
+
+static u8 xmio_get_status(struct virtio_device *vdev)
+{
+    return to_xmdev(vdev)->shared->status;
+}
+
+static void xmio_reset(struct virtio_device *vdev)
+{
+    set_status(vdev, 0);
+}
+
+static void xmio_get(struct virtio_device *vdev, unsigned int offset, void *buf, unsigned len)
+{
+    struct xmio_virtio_features *features = (struct xmio_virtio_features *)to_xmdev(vdev)->shared->extdata;
+
+    BUG_ON(offset + len > features->config_len);
+    memcpy(buf, features->config + offset, len);
+}
+
+static void xmio_set(struct virtio_device *vdev, unsigned int offset, const void *buf, unsigned len)
+{
+    struct xmio_virtio_features *features = (struct xmio_virtio_features *)to_xmdev(vdev)->shared->extdata;
+
+    BUG_ON(offset + len > features->config_len);
+    memcpy(features->config + offset, buf, len);
+}
+
+/*
+ * xmio_find_vqs
+ *
+ *  This function is called after a new device has been registered into the
+ *  Virtio infrastructure. This call also initializes the missing device
+ *  parameters
+ */
+static int xmio_find_vqs(struct virtio_device *vdev, unsigned nvqs,
+               struct virtqueue *vqs[],
+               vq_callback_t *callbacks[],
+               const char *names[])
+{
+    struct xmio_virtio_device *xvdev;
+    struct xmio_virtio_queue *xvque;
+    int s32a;
+
+    xvdev = to_xmdev(vdev);
+
+    if (nvqs != xvdev->shared->noqueues) {
+        printk("[xmio_virtio] wants %d queues. Offered %d\n", nvqs, xvdev->shared->noqueues);
+        return -ENOENT;
+    }
+
+    xvdev->xmdev = kzalloc(sizeof(struct xmio_device) + sizeof(struct xmio_queue)*nvqs, GFP_KERNEL);
+    if (xvdev->xmdev == NULL) {
+        return -ENOMEM;
+    }
+
+    xvdev->xmdev->shared = xvdev->shared;
+    xvdev->xmdev->type = xvdev->shared->type;
+    xvdev->xmdev->noqueues = nvqs;
+
+    if (xmio_find_queues(xvdev->xmdev) < 0) {                     /* Find the queues on shared memory */
+        kfree(xvdev->xmdev);
+        return -ENODEV;
+    }
+
+    xvdev->xmvqs = kzalloc(sizeof(struct xmio_virtio_queue *)*nvqs, GFP_KERNEL);
+    for (s32a=0; s32a<nvqs; ++s32a) {                                    /* Create client structures */
+        xvque = kzalloc(sizeof(struct xmio_virtio_queue) + sizeof(void *)*xvdev->xmdev->queues[s32a].nodescs, GFP_KERNEL);
+
+        xvque->vq.callback = callbacks[s32a];
+        /*xvque->vq.vq_ops = &xmio_virtio_vq_ops;*/
+        xvque->vq.vdev = vdev;
+        xvque->vq.name = names[s32a];
+        xvque->broken = false;
+        xvque->active = true;
+        xvque->xmque = &xvdev->xmdev->queues[s32a];
+        list_add_tail(&xvque->vq.list, &vdev->vqs);
+
+        vqs[s32a] = &xvque->vq;                                        /* Save reference to the vq */
+        xvdev->xmvqs[s32a] = xvque;
+    }
+
+    xmio_setup_irq(xvdev->shared->cirq, xmio_virtio_irqhandler, xvdev);
+
+    return 0;
+}
+
+static void xmio_del_vqs(struct virtio_device *vdev)
+{
+    struct xmio_virtio_device *xvdev;
+    xvdev = to_xmdev(vdev);
+
+    /* TODO: free all the buffers of this queue */
+
+    xmio_clear_irq(xvdev->shared->cirq);
+    xmio_restart_device(xvdev->xmdev);
+    kfree(xvdev->xmdev);
+    kfree(xvdev);
+}
+
+static struct virtio_config_ops xmio_config_ops = {
+    .get_features = xmio_get_features,
+    .finalize_features = xmio_finalize_features,
+    .get = xmio_get,
+    .set = xmio_set,
+    .get_status = xmio_get_status,
+    .set_status = xmio_set_status,
+    .reset = xmio_reset,
+    .find_vqs = xmio_find_vqs,
+    .del_vqs = xmio_del_vqs,
+};
+
+static void xmio_virtio_release(struct device *xvdev)
+{
+    XMIO_DEBUG("%p %s\n", xvdev, dev_name(xvdev));
+}
+
+/* Device prober */
+static void xmio_virtio_device_scanner(struct work_struct *work)
+{
+    struct xmio_device_shared *shared[XMIO_MAX_DEVICES];
+    struct xmio_virtio_device *xvdev;
+    u32 found, u32a;
+
+    memset(shared, 0, sizeof(*shared));
+    found = xmio_scan(shared);
+    for (u32a=0; u32a<found; ++u32a) {
+        if ((xvdev=kzalloc(sizeof(*xvdev), GFP_KERNEL)) == NULL) {
+            printk("[xmio_virtio] Failed to allocate device type %u\n", shared[u32a]->type);
+            break;
+        }
+
+        xvdev->vdev.dev.release = xmio_virtio_release;
+        xvdev->vdev.dev.parent = xm_root;
+        xvdev->vdev.id.device = shared[u32a]->type;
+        xvdev->vdev.config = &xmio_config_ops;
+        xvdev->shared = shared[u32a];
+
+        if (register_virtio_device(&xvdev->vdev) != 0) {
+            printk("[xmio_virtio] Failed to register device type %u\n", shared[u32a]->type);
+            kfree(xvdev);
+        }
+
+        printk("[xmio_virtio] New device found %d, %d\n", u32a, shared[u32a]->type);
+    }
+    schedule_delayed_work(&xmio_scan_work, msecs_to_jiffies(CONFIG_XMIO_SCAN_PERIOD));
+}
+
+static void xmio_virtio_device_detacher(struct work_struct *work)
+{
+    struct xmio_virtio_device *xvdev=xvdev_detach;
+
+    if(!xvdev)
+        return;
+
+    /* Disallow detach of mis-configured devices */
+    if (xvdev->shared->status != (VIRTIO_CONFIG_S_ACKNOWLEDGE|VIRTIO_CONFIG_S_DRIVER|VIRTIO_CONFIG_S_DRIVER_OK))
+        return;
+
+    /* Ack command */
+    xvdev->shared->cmd = 0;
+
+    /* Free all requests */
+    unregister_virtio_device(&xvdev->vdev);
+    xvdev_detach=0;
+}
+
+static int early_put_chars(u32 vtermno, const char *buf, int count)
+{
+#ifdef CONFIG_XM_BOOTCONSOLE
+    xprintk("%.*s", count, buf);
+#endif
+    return count;
+}
+
+static int __init xmio_virtio_init(void)
+{
+    if(!is_xm_guest())
+        return 0;
+
+    INIT_DELAYED_WORK(&xmio_scan_work, xmio_virtio_device_scanner);
+    INIT_DELAYED_WORK(&xmio_detach_work, xmio_virtio_device_detacher);
+    xm_root = root_device_register("xm");
+    if (IS_ERR(xm_root)) {
+        panic("[xmio_virtio] Could not register xm root");
+    }
+
+    virtio_cons_early_init(early_put_chars);
+
+    /* Initially schedule a device scan */
+    schedule_delayed_work(&xmio_scan_work, 0);
+    printk("[xmio_virtio] initialized\n");
+
+    return 0;
+}
+
+module_init(xmio_virtio_init);
+MODULE_LICENSE("GPL");
diff -Nur linux-3.0.34/arch/x86/xm/xmio/xmio_virtio.h linux-3.0.34-xm/arch/x86/xm/xmio/xmio_virtio.h
--- linux-3.0.34/arch/x86/xm/xmio/xmio_virtio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.0.34-xm/arch/x86/xm/xmio/xmio_virtio.h	2013-01-13 23:14:53.000000000 +0100
@@ -0,0 +1,33 @@
+/*
+ * FILE: xmio_virtio.h
+ *
+ * XMIO wrapper implementation for virtio
+ *
+ * Author: Jordi Sánchez, <jsanchez@ai2.upv.es>
+ *
+ * $LICENSE:
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#ifndef _XMIO_VIRTIO_H_
+#define _XMIO_VIRTIO_H_
+
+struct xmio_virtio_features {
+    xm_u32_t offered;
+    xm_u32_t accepted;
+    xm_u32_t config_len;
+    xm_u8_t config[];
+};
+
+#endif //_XMIO_VIRTIO_H_
diff -Nur linux-3.0.34/arch/x86/xm/xmio/xmnet.c linux-3.0.34-xm/arch/x86/xm/xmio/xmnet.c
--- linux-3.0.34/arch/x86/xm/xmio/xmnet.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.0.34-xm/arch/x86/xm/xmio/xmnet.c	2013-01-13 23:14:53.000000000 +0100
@@ -0,0 +1,451 @@
+/*
+ * $FILE: xmnet.c
+ *
+ * XMIO virtual network device implementation
+ *
+ * Authors: Jordi Sánchez, <jsanchez@ai2.upv.es>
+ *          Salva Peiró, <speiro@ai2.upv.es>
+ *
+ * $LICENSE:
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include "xmio_accounting.h"
+#include "xmio_server.h"
+#include "xmio_virtio.h"
+
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/if_vlan.h>
+#include <linux/init.h>
+#include <linux/kthread.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/netlink.h>
+#include <linux/semaphore.h>
+#include <linux/workqueue.h>
+#include <net/rtnetlink.h>
+
+#include <linux/virtio.h>
+#include <linux/virtio_net.h>
+
+#define XMIO_NETWORK_NODESCS        256
+#define XMIO_NETWORK_POOLSIZE       (512*1024)
+
+#define VIRTIO_CONFIG_OK (VIRTIO_CONFIG_S_ACKNOWLEDGE|VIRTIO_CONFIG_S_DRIVER|VIRTIO_CONFIG_S_DRIVER_OK)
+
+// This structure will help to maintain the virtio network devices
+struct xmnet_control {
+    struct net_device *netdev;
+    struct rtnl_link_ops rtnl_ops;
+    char name[IFNAMSIZ];
+};
+
+static struct {
+    struct xmio_virtio_features features;
+    struct virtio_net_config virtio_config;
+} xmnet_extended = {
+    .features.config_len = sizeof(struct virtio_net_config),
+};
+
+static int xmnet_ioctl(struct xmio_client *client, unsigned int cmd, struct xmio_args *args);
+static struct xmio_device xmnet = {
+    .type = XMIO_ID_NETWORK,
+    .ioctl = xmnet_ioctl,
+    .noqueues = 2,                      /* First queue:  S -> C,  Second queue; C -> S */
+    .irq = XMIO_ID_NETWORK,
+    .extdata = &xmnet_extended,
+    .extlen = sizeof(xmnet_extended),
+};
+
+static struct xmio_account xmnet_account;
+static DEFINE_SEMAPHORE(xmnet_sem);
+static struct delayed_work xmnet_shrink_work;
+
+static int xmnet_rx(void *data, int len, struct net_device *dev)
+{
+    struct sk_buff *skb;
+
+    if (!(skb = dev_alloc_skb(len + NET_IP_ALIGN))) {
+        // Oh oh! If we could not allocate memory for a sk_buff, does this mean
+        // that we are going to throw away all the remaining packets on the virtqueue?
+        dev->stats.rx_dropped++;
+        // For now, we return error
+        XMIO_DEBUG("skb_alloc failed for packet reception %p\n", data);
+        return -1;
+    }
+
+    skb_reserve(skb, NET_IP_ALIGN);                 /* Retrieve packet data */
+
+    xmio_memcpy(skb_put(skb, len), data, len);
+    skb->dev = dev;
+    skb->protocol = eth_type_trans(skb, dev);
+    skb->ip_summed = CHECKSUM_UNNECESSARY;
+
+    if (netif_rx(skb) == NET_RX_DROP) {             /* Upload the packet to the upper layers */
+        dev->stats.rx_dropped++;
+        // Shall we return error?
+    } else {
+        dev->stats.rx_packets++;
+        dev->stats.rx_bytes += len;
+    }
+
+    if (netif_queue_stopped(dev)) {
+        netif_wake_queue(dev);
+    }
+
+    return 0;
+}
+
+static void xmnet_output(struct xmio_queue *xmque)
+{
+    int in, out, head, i;
+    struct xmnet_control *ctrl = xmque->connect->priv;
+    struct kvec iov[32];
+
+    if ((head=xmioserver_get_request(xmque, iov, &out, &in)) > 0) {
+        if (in > 0) {
+            //XMIO_DEBUG("net_output: Found %d input buffers in output queue\n", in);
+            return;
+        }
+
+        if (xmque->connect->shared->status != (VIRTIO_CONFIG_OK)){
+            XMIO_DEBUG("device not ready %x\n", xmque->connect->shared->status);
+            return;
+        }
+
+        // The first buffer of a virtio_net buffer chain is always a header. As we
+        // still don't support GSO or CSUM features, we ignore the header as mentioned
+        // on "virtio_net.h"
+        for (i = 1; i < out; ++i) {
+            xmnet_rx(iov[i].iov_base, iov[i].iov_len, ctrl->netdev);
+            xmque->usage.bytes += iov[i].iov_len;
+        }
+        xmio_request_served(xmque, head, 0);
+    }
+}
+
+static void xmnet_input(struct net_device *netdev)
+{
+    if(!netdev) {
+        return;
+    }
+
+    if (netif_queue_stopped(netdev)) {
+        netif_wake_queue(netdev);
+    }
+}
+
+static int xmnet_thread(void *data)
+{
+    struct xmio_queue *xmque;
+    int res;
+
+    for (;;) {
+        /* XXX: The down() operation times out and panics after a long period */
+        res = down_timeout(&xmnet_sem, msecs_to_jiffies(XMIO_TIMEOUT));
+        while ((xmque=xmio_acc_next(&xmnet_account)) != NULL) {         /* This only works for transmission queues */
+            xmnet_output(xmque);
+        }
+    }
+
+    return 0;
+}
+
+static void xmnet_irq(void)
+{
+    int s32a;
+    struct xmnet_control *ctrl;
+    struct xmio_connection *conn;
+
+    for (s32a=0; s32a<xmio_noclients(); ++s32a) {
+        conn = xmio_list_get_head(xmnet.connects[s32a]);
+        if(conn != NULL) {
+            switch (conn->status) {
+            case XMIO_CMD_RESET:                                    /* Device boot */
+                if (conn->shared->status & XMIO_STATUS_DRIVER_OK) {
+                    conn->status = 0;
+                }
+                break;
+
+            case XMIO_CMD_DETACH:
+                break;
+
+            case 0:
+                if (conn->shared->status != 0) {
+                    if (xmio_more_requests(&conn->queues[0])) {     /* When new receive requests arrive, we wake up the network queue */
+                        ctrl = conn->priv;
+                        xmnet_input(ctrl->netdev);
+                    }
+                } else {
+                    if (conn->shared->status == (VIRTIO_CONFIG_OK))
+                        xmio_connection_reset(conn);
+                }
+                break;
+            }
+        }
+    }
+    up(&xmnet_sem);                                                 /* up() can be called from any context */
+}
+
+static int xmnet_open(struct net_device *dev)
+{
+    netif_start_queue(dev);
+    netif_device_attach(dev);
+    return 0;
+}
+
+static int xmnet_close(struct net_device *dev)
+{
+    netif_stop_queue(dev);
+    netif_device_detach(dev);
+    return 0;
+}
+
+static int xmnet_config(struct net_device *dev, struct ifmap *map)
+{
+    if (dev->flags & IFF_UP)
+        return -EBUSY;
+    return 0;
+}
+
+/*
+ * xmnet_start_xmit
+ *  This function targets a passive xmio_queue, which means that this queue
+ *  does not participate in the accounting policies
+ */
+static int xmnet_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+    int in, out, head;
+    struct xmio_connection *conn = *((struct xmio_connection **)netdev_priv(dev));
+    struct xmio_queue *xmque = &conn->queues[0];
+    struct kvec iov[32];
+
+    dev->trans_start = jiffies;
+
+    if ((head=xmioserver_get_request(xmque, iov, &out, &in)) < 0) {
+        dev->stats.tx_dropped++;
+        goto net_xmit_out;
+    }
+    if (iov[1].iov_len < skb->len) {
+        /* TODO: Something is missing as getting here would mean that a request has been
+         * gathered from the queue */
+        dev->stats.tx_dropped++;
+        goto net_xmit_out;
+    }
+
+    memset(iov[0].iov_base, 0, iov[0].iov_len);
+    xmio_memcpy(iov[1].iov_base, skb->data, skb->len);
+
+    dev->stats.tx_packets++;
+    dev->stats.tx_bytes += skb->len;
+
+    xmio_request_served(xmque, head, skb->len + iov[0].iov_len);
+net_xmit_out:
+    dev_kfree_skb_any(skb);
+    return 0;
+}
+
+static int xmnet_mac_addr(struct net_device *dev, void *p)
+{
+    if (netif_running(dev))
+        return -EBUSY;
+    return -EPERM;
+}
+
+static const struct net_device_ops xmnet_ops = {
+    .ndo_open            = xmnet_open,
+    .ndo_stop            = xmnet_close,
+    .ndo_start_xmit      = xmnet_start_xmit,
+//  .ndo_tx_timeout      = xmnet_tx_timeout,
+    .ndo_set_config      = xmnet_config,
+    .ndo_set_mac_address = xmnet_mac_addr,
+    .ndo_change_mtu      = eth_change_mtu,
+    .ndo_validate_addr   = eth_validate_addr,
+};
+
+static struct {
+    const char str[ETH_GSTRING_LEN];
+} ethtool_stats_keys[] = {
+    { "tx_ok" },
+    { "rx_ok" },
+    { "tx_err" },
+    { "rx_err" },
+    { "rx_fifo" },
+};
+
+static void xmnet_get_ethtool_stats (struct net_device *dev, struct ethtool_stats *estats, u64 *stats)
+{
+    int i = 0;
+
+    stats[i++] = le64_to_cpu(dev->stats.tx_bytes);
+    stats[i++] = le64_to_cpu(dev->stats.rx_bytes);
+    stats[i++] = le64_to_cpu(dev->stats.tx_errors);
+    stats[i++] = le32_to_cpu(dev->stats.rx_errors);
+    stats[i++] = le32_to_cpu(0);
+}
+
+static void xmnet_get_drvinfo(struct net_device *net_dev, struct ethtool_drvinfo *info)
+{
+    strncpy(info->driver, KBUILD_MODNAME, ARRAY_SIZE(info->driver));
+    strncpy(info->version, "N/A", ARRAY_SIZE(info->version));
+    strncpy(info->fw_version, "N/A", ARRAY_SIZE(info->fw_version));
+    strncpy(info->bus_info, dev_name(&net_dev->dev), ARRAY_SIZE(info->bus_info));
+    info->n_stats = ARRAY_SIZE(ethtool_stats_keys);
+}
+
+static void xmnet_get_strings (struct net_device *dev, u32 stringset, u8 *buf)
+{
+    switch (stringset) {
+    case ETH_SS_STATS:
+        memcpy(buf, &ethtool_stats_keys, sizeof(ethtool_stats_keys));
+        break;
+    default:
+        BUG();
+        break;
+    }
+}
+
+static struct ethtool_ops xmnet_ethtool_ops = {
+    .get_drvinfo = xmnet_get_drvinfo,
+    .get_strings = xmnet_get_strings,
+    .get_link = ethtool_op_get_link,
+    .get_ethtool_stats  = xmnet_get_ethtool_stats,
+};
+
+#define XMNET_MTU_SIZE 2048
+static void xmnet_setup(struct net_device *dev)
+{
+    ether_setup(dev);
+
+    SET_ETHTOOL_OPS(dev, &xmnet_ethtool_ops);
+    dev->netdev_ops = &xmnet_ops;
+    dev->watchdog_timeo = 0;
+
+    dev->features |= NETIF_F_NO_CSUM;
+    dev->hard_header_len = ETH_HLEN;
+    dev->addr_len = ETH_ALEN;
+    dev->mtu = XMNET_MTU_SIZE - ETH_HLEN - ETH_ALEN;
+
+    random_ether_addr(dev->dev_addr);
+    *(unsigned long *)&dev->dev_addr[2] = XM_PARTITION_SELF;
+}
+
+static int __init xmnet_init_netdev(struct xmio_connection *conn)
+{
+    struct xmnet_control *ctrl = conn->priv;
+    struct xmio_connection **priv;
+
+    ctrl->rtnl_ops = (struct rtnl_link_ops) {
+        .kind      = "XMIO",
+        .priv_size = sizeof(struct xmio_connection *),
+        .setup     = xmnet_setup,
+    };
+    rtnl_lock();
+    if (__rtnl_link_register(&ctrl->rtnl_ops)) {
+        goto error;
+    }
+
+    ctrl->netdev = alloc_netdev(sizeof(struct xmio_connection *), ctrl->name, xmnet_setup);
+    if (!ctrl->netdev) {
+        goto error;
+    }
+
+    ctrl->netdev->rtnl_link_ops = &ctrl->rtnl_ops;
+    if (register_netdevice(ctrl->netdev) < 0) {
+        free_netdev(ctrl->netdev);
+        goto error;
+    }
+
+    priv = netdev_priv(ctrl->netdev);
+    *priv = conn;
+    rtnl_unlock();
+
+    return 0;
+error:
+    printk("[xmnet] failed\n");
+    return -1;
+}
+
+/* TODO: Check race conditions. Insert mutex to operation */
+static void xmnet_shrink(struct work_struct *work)
+{
+    struct xmio_queue *xmque;
+
+    for (xmque=xmnet_account.list; xmque; xmque=xmque->next) {
+        xmio_acc_shrink(xmque, XMIO_ACCOUNT_DELTA);
+    }
+    schedule_delayed_work(&xmnet_shrink_work, msecs_to_jiffies(XMIO_ACCOUNT_TMOUT));
+}
+
+static int xmnet_ioctl(struct xmio_client *client, unsigned int cmd, struct xmio_args *args)
+{
+    struct xmnet_control *ctrl;
+    struct xmio_connection *conn;
+
+    switch (cmd){
+    default:
+        return -1;
+
+    case XMIOCTL_CMD_OFFER:
+        if (xmnet.connects[client->id] != NULL) {
+            return -EPERM;
+        }
+
+        conn = xmio_connection_new(&xmnet, client);
+        if (conn == NULL) {
+            return -ENOMEM;
+        }
+        xmio_init_queue(conn, &conn->queues[0], XMIO_NETWORK_NODESCS);
+        xmio_init_queue(conn, &conn->queues[1], XMIO_NETWORK_NODESCS);
+
+        if ((ctrl=kzalloc(sizeof(struct xmnet_control), GFP_KERNEL)) == NULL) {
+            return -ENOMEM;
+        }
+
+        random_ether_addr((u8*)&xmnet_extended.virtio_config.mac);
+        xmnet_extended.virtio_config.mac[2] = XM_PARTITION_SELF;
+
+        snprintf(ctrl->name, IFNAMSIZ, "xmnet%d", client->id);                       /* Interface name */
+        conn->priv = ctrl;
+        xmnet_init_netdev(conn);                               /* Initialize connection */
+        xmio_acc_insert_queue(&xmnet_account, &conn->queues[1]);/* Insert the transmission queue in the accounting mechanism */
+
+        xmioserver_setup_irq(client, xmnet.irq, xmnet_irq);
+        xmio_connection_start(conn);                                            /* Make the device available to the client */
+
+        printk("xmnet offered to %d\n", client->id);
+
+        return 0;
+    }
+}
+
+static int __init xmnet_init(void)
+{
+    if(is_xm_guest())
+        return 0;
+    xmio_register_device(&xmnet);
+    kthread_run(xmnet_thread, NULL, "xmnet_thread");
+
+    INIT_DELAYED_WORK(&xmnet_shrink_work, xmnet_shrink);
+    schedule_delayed_work(&xmnet_shrink_work, msecs_to_jiffies(XMIO_ACCOUNT_TMOUT));
+
+    printk("xmnet initialized\n");
+
+    return 0;
+}
+
+module_init(xmnet_init);
+/*module_exit(xmnet_exit);*/
+MODULE_LICENSE("GPL");
diff -Nur linux-3.0.34/arch/x86/xm/xmio/xmrng.c linux-3.0.34-xm/arch/x86/xm/xmio/xmrng.c
--- linux-3.0.34/arch/x86/xm/xmio/xmrng.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.0.34-xm/arch/x86/xm/xmio/xmrng.c	2013-01-13 23:14:53.000000000 +0100
@@ -0,0 +1,131 @@
+/*
+ * $FILE: xmrng.c
+ *
+ * XMIO virtual RNG device implementation
+ *
+ * Authors: Salva Peiró, <speiro@ai2.upv.es>
+ *          Jordi Sánchez, <jsanchez@ai2.upv.es>
+ *
+ * $LICENSE:
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "xmio_accounting.h"
+#include "xmio_server.h"
+#include "xmio_virtio.h"
+
+#include <linux/cdev.h>
+#include <linux/console.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/random.h>
+
+#include <linux/virtio.h>
+#include <linux/virtio_rng.h>
+
+#define XMRNG_NODESCS   32
+/*#define pr_debug printk*/
+
+static struct {
+    struct xmio_virtio_features features;
+} xmrng_extended;
+
+static int xmrng_ioctl(struct xmio_client *client, unsigned int cmd, struct xmio_args *args);
+static struct xmio_device xmrng = {
+    .type = XMIO_ID_RNG,
+    .ioctl = xmrng_ioctl,
+    .noqueues = 1,
+    .irq = XMIO_ID_RNG,
+    .extdata = &xmrng_extended,
+    .extlen = sizeof(xmrng_extended),
+};
+
+static struct xmio_account xmrng_account;
+
+static bool xmrng_io(struct xmio_queue *xmque)
+{
+    struct kvec iov[32];
+    unsigned int in, out, head;
+
+    if ((head=xmioserver_get_request(xmque, iov, &out, &in)) < 0) {           /* Buffer addresses are checked here */
+        return -EAGAIN;
+    }
+    if (out > 0) {
+        return -EIO;
+    }
+
+    get_random_bytes(iov[0].iov_base, iov[0].iov_len);
+    xmio_request_served(xmque, head, iov[0].iov_len);
+    return 0;
+}
+
+static void xmrng_irq(void)
+{
+    struct xmio_queue *xmque;
+
+    while ((xmque=xmio_acc_next(&xmrng_account)) != NULL) {
+        xmrng_io(xmque);
+    }
+}
+
+static int xmrng_ioctl(struct xmio_client *client, unsigned int cmd, struct xmio_args *args)
+{
+    struct xmio_connection *conn;
+
+    switch (cmd){
+    default:
+        return -1;
+
+    case XMIOCTL_CMD_OFFER:
+        if (xmrng.type != XMIO_ID_RNG || xmrng.connects[client->id]) {
+            return -EPERM;
+        }
+
+        conn = xmio_connection_new(&xmrng, client);
+        if (conn == NULL) {
+            return -ENOMEM;
+        }
+
+        xmio_init_queue(conn, &conn->queues[0], XMRNG_NODESCS);
+        xmio_acc_insert_queue(&xmrng_account, &conn->queues[0]);
+
+        xmioserver_setup_irq(client, xmrng.irq, xmrng_irq);
+        xmio_connection_start(conn);                 /* Make the device available to the client */
+
+        pr_debug("xmrng offered to %d\n", client->id);
+        return 0;
+    }
+}
+
+static int __init xmrng_init(void)
+{
+    if(is_xm_guest())
+        return 0;
+    xmio_register_device(&xmrng);
+    return 0;
+}
+
+static void __init xmrng_exit(void)
+{
+    /*xmio_unregister_device(&xmrng);*/
+}
+
+module_init(xmrng_init);
+module_exit(xmrng_exit);
+MODULE_LICENSE("GPL");
diff -Nur linux-3.0.34/arch/x86/xm/xmio/xmrtc.c linux-3.0.34-xm/arch/x86/xm/xmio/xmrtc.c
--- linux-3.0.34/arch/x86/xm/xmio/xmrtc.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.0.34-xm/arch/x86/xm/xmio/xmrtc.c	2013-01-13 23:14:53.000000000 +0100
@@ -0,0 +1,130 @@
+/*
+ * $FILE: xmrtc.c
+ *
+ * XMIO virtual RTC device implementation
+ *
+ * Authors: Salva Peiró, <speiro@ai2.upv.es>
+ *          Jordi Sánchez, <jsanchez@ai2.upv.es>
+ *
+ * $LICENSE:
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "xmio_accounting.h"
+#include "xmio_server.h"
+#include "xmio_virtio.h"
+
+#include <linux/cdev.h>
+#include <linux/console.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+
+#include <linux/virtio.h>
+
+#define XMRTC_NODESCS   64
+
+static struct {
+    struct xmio_virtio_features features;
+} xmrtc_extended;
+
+static int xmrtc_ioctl(struct xmio_client *client, unsigned int cmd, struct xmio_args *args);
+static struct xmio_device xmrtc = {
+    .type = XMIO_ID_RTC,
+    .ioctl = xmrtc_ioctl,
+    .noqueues = 1,
+    .irq = XMIO_ID_RTC,
+    .extdata = &xmrtc_extended,
+    .extlen = sizeof(xmrtc_extended),
+};
+static struct xmio_account xmrtc_account;
+
+static bool xmrtc_io(struct xmio_queue *xmque)
+{
+    struct kvec iov[32];
+    unsigned int in, out, head;
+	struct timeval timeval;
+
+    if ((head=xmioserver_get_request(xmque, iov, &out, &in)) < 0) {           /* Buffer addresses are checked here */
+        return -EAGAIN;
+    }
+    if (out > 0) {
+        return -EIO;
+    }
+
+    do_gettimeofday(&timeval);
+    if(iov[0].iov_len == sizeof(timeval.tv_sec))
+        *(u32*)iov[0].iov_base = timeval.tv_sec;
+    xmio_request_served(xmque, head, iov[0].iov_len);
+    return 0;
+}
+
+static void xmrtc_irq(void)
+{
+    struct xmio_queue *xmque;
+
+    while ((xmque=xmio_acc_next(&xmrtc_account)) != NULL) {
+        xmque->connect->client->main->client_irqpend &= ~XMIO_ID_RTC;
+        xmrtc_io(xmque);
+    }
+}
+
+static int xmrtc_ioctl(struct xmio_client *client, unsigned int cmd, struct xmio_args *args)
+{
+    struct xmio_connection *conn;
+
+    switch (cmd){
+    default:
+        return -1;
+
+    case XMIOCTL_CMD_OFFER:
+        if (xmrtc.type != XMIO_ID_RTC || xmrtc.connects[client->id]) {
+            return -EPERM;
+        }
+
+        conn = xmio_connection_new(&xmrtc, client);
+        if (conn == NULL) {
+            return -ENOMEM;
+        }
+        xmio_init_queue(conn, &conn->queues[0], XMRTC_NODESCS);
+        xmio_acc_insert_queue(&xmrtc_account, &conn->queues[0]);
+
+        xmioserver_setup_irq(client, xmrtc.irq, xmrtc_irq);
+        xmio_connection_start(conn);                 /* Make the device available to the client */
+
+        pr_debug("xmrtc offered to %d\n", client->id);
+        return 0;
+    }
+}
+
+static int __init xmrtc_init(void)
+{
+    if(is_xm_guest())
+        return 0;
+    xmio_register_device(&xmrtc);
+    return 0;
+}
+
+static void __init xmrtc_exit(void)
+{
+    /*xmio_unregister_device(&xmrtc);*/
+}
+
+module_init(xmrtc_init);
+module_exit(xmrtc_exit);
+MODULE_LICENSE("GPL");
diff -Nur linux-3.0.34/drivers/block/virtio_blk.c linux-3.0.34-xm/drivers/block/virtio_blk.c
--- linux-3.0.34/drivers/block/virtio_blk.c	2012-06-09 17:33:45.000000000 +0200
+++ linux-3.0.34-xm/drivers/block/virtio_blk.c	2013-01-13 23:13:00.000000000 +0100
@@ -451,6 +451,7 @@
 
 	/* No real sector limit. */
 	blk_queue_max_hw_sectors(q, -1U);
+	blk_queue_max_hw_sectors(q, 8);
 
 	/* Host can optionally specify maximum segment size and number of
 	 * segments. */
diff -Nur linux-3.0.34/drivers/net/virtio_net.c linux-3.0.34-xm/drivers/net/virtio_net.c
--- linux-3.0.34/drivers/net/virtio_net.c	2012-06-09 17:33:45.000000000 +0200
+++ linux-3.0.34-xm/drivers/net/virtio_net.c	2013-01-13 23:13:19.000000000 +0100
@@ -277,6 +277,7 @@
 	}
 
 	skb->protocol = eth_type_trans(skb, dev);
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
 	pr_debug("Receiving skb proto 0x%04x len %i type %i\n",
 		 ntohs(skb->protocol), skb->len, skb->pkt_type);
 
diff -Nur linux-3.0.34/drivers/rtc/Kconfig linux-3.0.34-xm/drivers/rtc/Kconfig
--- linux-3.0.34/drivers/rtc/Kconfig	2012-06-09 17:33:45.000000000 +0200
+++ linux-3.0.34-xm/drivers/rtc/Kconfig	2013-01-13 23:14:11.000000000 +0100
@@ -1060,4 +1060,13 @@
 	  This drive can also be built as a module. If so, the module
 	  will be called rtc-puv3.
 
+config RTC_DRV_VIRTIO
+	tristate "VIRTIO RTC"
+	depends on VIRTIO
+	help
+	  If you say yes here you will get support for the VIRTIO RTC.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called rtc-virtio.
+
 endif # RTC_CLASS
diff -Nur linux-3.0.34/drivers/rtc/Makefile linux-3.0.34-xm/drivers/rtc/Makefile
--- linux-3.0.34/drivers/rtc/Makefile	2012-06-09 17:33:45.000000000 +0200
+++ linux-3.0.34-xm/drivers/rtc/Makefile	2013-01-13 23:14:11.000000000 +0100
@@ -108,3 +108,4 @@
 obj-$(CONFIG_RTC_DRV_WM831X)	+= rtc-wm831x.o
 obj-$(CONFIG_RTC_DRV_WM8350)	+= rtc-wm8350.o
 obj-$(CONFIG_RTC_DRV_X1205)	+= rtc-x1205.o
+obj-$(CONFIG_RTC_DRV_VIRTIO)	+= rtc-virtio.o
diff -Nur linux-3.0.34/drivers/rtc/rtc-virtio.c linux-3.0.34-xm/drivers/rtc/rtc-virtio.c
--- linux-3.0.34/drivers/rtc/rtc-virtio.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-3.0.34-xm/drivers/rtc/rtc-virtio.c	2013-01-13 23:14:11.000000000 +0100
@@ -0,0 +1,127 @@
+/*
+ * RTC driver for virtio
+ *  Copyright (C) 2011 Salva Peiró <speiro@ai2.upv.es>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
+ */
+
+#include <linux/err.h>
+#include <linux/scatterlist.h>
+#include <linux/spinlock.h>
+#include <linux/virtio.h>
+#include <linux/virtio_rng.h>
+
+#include <linux/rtc.h>
+#include <linux/platform_device.h>
+
+static struct virtqueue *vq;
+static struct rtc_device *rtc;
+static u32 rtc_data=0;
+static DECLARE_COMPLETION(have_data);
+
+static void virtrtc_recv_done(struct virtqueue *vq)
+{
+	int len;
+    
+	if (!virtqueue_get_buf(vq, &len))
+		return;
+	complete(&have_data);
+}
+
+static void register_buffer(void)
+{
+	struct scatterlist sg;
+
+	sg_init_one(&sg, &rtc_data, sizeof(rtc_data));
+	/* There should always be room for one buffer. */
+	if (virtqueue_add_buf(vq, &sg, 0, 1, &rtc_data) < 0)
+		BUG();
+	virtqueue_kick(vq);
+}
+
+static int virtio_read_time(struct device *dev, struct rtc_time *tm)
+{
+	if (!rtc_data)
+		return rtc_data;
+
+	wait_for_completion_interruptible(&have_data);
+	rtc_time_to_tm(rtc_data, tm);
+	init_completion(&have_data);
+	register_buffer();
+	return rtc_valid_tm(tm);
+}
+static int virtio_set_time(struct device *dev, struct rtc_time *tm)
+{
+    return 0;
+}
+
+static const struct rtc_class_ops virtio_rtc_ops = {
+	.read_time	= virtio_read_time,
+	.set_time = virtio_set_time,
+};
+
+static int virtrtc_probe(struct virtio_device *vdev)
+{
+	/* We expect a single virtqueue. */
+	vq = virtio_find_single_vq(vdev, virtrtc_recv_done, "input");
+
+	if (IS_ERR(vq))
+		return PTR_ERR(vq);
+
+	rtc = rtc_device_register("virtio", &vdev->dev, &virtio_rtc_ops, THIS_MODULE);
+	if (IS_ERR(rtc)){
+		vdev->config->del_vqs(vdev);
+		return PTR_ERR(rtc);
+	}
+
+	register_buffer();
+	return 0;
+}
+
+static void virtrtc_remove(struct virtio_device *vdev)
+{
+	rtc_device_unregister(rtc);
+	vdev->config->reset(vdev);
+	vdev->config->del_vqs(vdev);
+}
+
+static struct virtio_device_id id_table[] = {
+	{ VIRTIO_ID_RTC, VIRTIO_DEV_ANY_ID },
+	{ 0 },
+};
+
+static struct virtio_driver virtio_rtc = {
+	.driver.name =	KBUILD_MODNAME,
+	.driver.owner =	THIS_MODULE,
+	.id_table =	id_table,
+	.probe =	virtrtc_probe,
+	.remove =	__devexit_p(virtrtc_remove),
+};
+
+static int __init init(void)
+{
+	return register_virtio_driver(&virtio_rtc);
+}
+
+static void __exit fini(void)
+{
+	unregister_virtio_driver(&virtio_rtc);
+}
+module_init(init);
+module_exit(fini);
+
+MODULE_DEVICE_TABLE(virtio, id_table);
+MODULE_DESCRIPTION("Virtio RTC driver");
+MODULE_LICENSE("GPL");
diff -Nur linux-3.0.34/drivers/video/Kconfig linux-3.0.34-xm/drivers/video/Kconfig
--- linux-3.0.34/drivers/video/Kconfig	2012-06-09 17:33:45.000000000 +0200
+++ linux-3.0.34-xm/drivers/video/Kconfig	2013-01-13 23:13:02.000000000 +0100
@@ -2249,6 +2249,19 @@
 	  This driver implements the front-end of the Xen virtual
 	  frame buffer driver.  It communicates with a back-end
 	  in another domain.
+	  
+config FB_VIRTIO
+	tristate "Virtio virtual frame buffer support"
+	depends on FB && VIRTIO
+	select FB_SYS_FILLRECT
+	select FB_SYS_COPYAREA
+	select FB_SYS_IMAGEBLIT
+	select FB_SYS_FOPS
+	select FB_DEFERRED_IO
+	help
+	  This driver implements a driver for a Virtio based
+	  frame buffer device.  It communicates to something that
+	  can talk Virtio too, most probably a hypervisor.
 
 config FB_METRONOME
 	tristate "E-Ink Metronome/8track controller support"
diff -Nur linux-3.0.34/drivers/video/Makefile linux-3.0.34-xm/drivers/video/Makefile
--- linux-3.0.34/drivers/video/Makefile	2012-06-09 17:33:45.000000000 +0200
+++ linux-3.0.34-xm/drivers/video/Makefile	2013-01-13 23:13:02.000000000 +0100
@@ -135,6 +135,7 @@
 obj-$(CONFIG_FB_OMAP)             += omap/
 obj-y                             += omap2/
 obj-$(CONFIG_XEN_FBDEV_FRONTEND)  += xen-fbfront.o
+obj-$(CONFIG_FB_VIRTIO)           += virtio_fb.o
 obj-$(CONFIG_FB_CARMINE)          += carminefb.o
 obj-$(CONFIG_FB_MB862XX)	  += mb862xx/
 obj-$(CONFIG_FB_MSM)              += msm/
diff -Nur linux-3.0.34/include/linux/virtio_ids.h linux-3.0.34-xm/include/linux/virtio_ids.h
--- linux-3.0.34/include/linux/virtio_ids.h	2012-06-09 17:33:45.000000000 +0200
+++ linux-3.0.34-xm/include/linux/virtio_ids.h	2013-01-13 23:12:09.000000000 +0100
@@ -34,6 +34,9 @@
 #define VIRTIO_ID_CONSOLE	3 /* virtio console */
 #define VIRTIO_ID_RNG		4 /* virtio ring */
 #define VIRTIO_ID_BALLOON	5 /* virtio balloon */
+#define VIRTIO_ID_RTC		6 /* virtio rtc */
+#define VIRTIO_ID_INPUT     7 /* virtio input device */
+#define VIRTIO_ID_FB        8 /* virtio framebuffer */
 #define VIRTIO_ID_9P		9 /* 9p virtio console */
 
 #endif /* _LINUX_VIRTIO_IDS_H */
diff -Nur linux-3.0.34/init/main.c linux-3.0.34-xm/init/main.c
--- linux-3.0.34/init/main.c	2012-06-09 17:33:45.000000000 +0200
+++ linux-3.0.34-xm/init/main.c	2013-01-13 23:15:37.000000000 +0100
@@ -740,7 +740,9 @@
 {
 	/* need to finish all async __init code before freeing the memory */
 	async_synchronize_full();
-	free_initmem();
+#ifndef CONFIG_XM_RESET
+ 	free_initmem();
+#endif
 	mark_rodata_ro();
 	system_state = SYSTEM_RUNNING;
 	numa_default_policy();
diff -Nur linux-3.0.34/kernel/sched.c linux-3.0.34-xm/kernel/sched.c
--- linux-3.0.34/kernel/sched.c	2012-06-09 17:33:45.000000000 +0200
+++ linux-3.0.34-xm/kernel/sched.c	2013-01-13 23:12:41.000000000 +0100
@@ -4225,6 +4225,10 @@
 	unsigned long *switch_count;
 	struct rq *rq;
 	int cpu;
+#ifdef CONFIG_XM_SPARE_MANAGER
+	extern void xm_start_idle(void);
+	extern void xm_stop_idle(void);
+#endif
 
 need_resched:
 	preempt_disable();
@@ -4274,6 +4278,14 @@
 	clear_tsk_need_resched(prev);
 	rq->skip_clock_update = 0;
 
+#ifdef CONFIG_XM_SPARE_MANAGER
+	if ((prev != rq->idle) && (next == rq->idle)) {
+	    xm_start_idle();
+	} else if ((prev == rq->idle) && (next != rq->idle)) {
+	    xm_stop_idle();
+	}
+#endif
+
 	if (likely(prev != next)) {
 		rq->nr_switches++;
 		rq->curr = next;
diff -Nur linux-3.0.34/mm/vmalloc.c linux-3.0.34-xm/mm/vmalloc.c
--- linux-3.0.34/mm/vmalloc.c	2012-06-09 17:33:45.000000000 +0200
+++ linux-3.0.34-xm/mm/vmalloc.c	2013-01-13 23:11:06.000000000 +0100
@@ -1432,6 +1432,10 @@
 			write_unlock(&vmlist_lock);
 		}
 
+#ifdef CONFIG_XM_PARTITION
+		vunmap_page_range(va->va_start, va->va_end);
+		flush_tlb_kernel_range(va->va_start, va->va_end);
+#endif
 		vmap_debug_free_range(va->va_start, va->va_end);
 		free_unmap_vmap_area(va);
 		vm->size -= PAGE_SIZE;
diff -Nur linux-3.0.34/scripts/package/builddeb linux-3.0.34-xm/scripts/package/builddeb
--- linux-3.0.34/scripts/package/builddeb	2012-06-09 17:33:45.000000000 +0200
+++ linux-3.0.34-xm/scripts/package/builddeb	2013-01-13 23:12:40.000000000 +0100
@@ -111,6 +111,7 @@
 else 
 	cp System.map "$tmpdir/boot/System.map-$version"
 	cp .config "$tmpdir/boot/config-$version"
+	cp vmlinux "$tmpdir/boot/vmlinux-$version"
 	# Not all arches include the boot path in KBUILD_IMAGE
 	if [ -e $KBUILD_IMAGE ]; then
 		cp $KBUILD_IMAGE "$tmpdir/boot/vmlinuz-$version"
