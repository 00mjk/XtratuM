/*
 * $FILE: xml2c.c
 *
 *
 * $VERSION$
 *
 * $AUTHOR$
 *
 * $LICENSE:
 * COPYRIGHT (c) Fent Innovative Software Solutions S.L.
 *     Read LICENSE.txt file for the license.terms.
 */

#include <libgen.h>
#include <string.h>
#include <stdio.h>
#include "xmcparser.h"
#include "xml2c.h"
#include "hm.h"
#include <xm_inc/xmef.h>

#define XMC_C_HEADER "/* File generated by xmcparser. Don't modify. */\n\n" \
                     "#include <xm_inc/xmconf.h>\n\n"

void PrintXMC(struct xmc *xmcTab, FILE *outFile) {
    xm_u32_t checksum=0;
    int e, i, j;
    fprintf(outFile, XMC_C_HEADER);
    fprintf(outFile, "extern char _xmcSize[];\n\n");
    
    /* Partition Table */
    fprintf(outFile, "const struct xmcPartition xmcPartitionTab[] = {\n");
    for (e=0; e<xmcTab->noPartitions; e++) {
	fprintf(outFile,
		ADDNTAB(1, "[%d] = {\n")
		ADDNTAB(2, ".id = %d,\n")
		ADDNTAB(2, ".nameOffset = %d,\n")
		ADDNTAB(2, ".flags = 0x%x,\n"),
		e, partitionTab[e].id, partitionTab[e].nameOffset, partitionTab[e].flags);
	fprintf(outFile, ADDNTAB(2, ".loadPhysAddr = 0x%x,\n"), partitionTab[e].loadPhysAddr);
	fprintf(outFile, ADDNTAB(2, ".headerOffset = 0x%x,\n"), partitionTab[e].headerOffset);
	fprintf(outFile, ADDNTAB(2, ".imageId = 0x%x,\n"), partitionTab[e].imageId);
	fprintf(outFile, ADDNTAB(2, ".consoleDev = { .id= 0x%x, .subId = 0x%x,},\n"), partitionTab[e].consoleDev.id, partitionTab[e].consoleDev.subId);
	fprintf(outFile,
		ADDNTAB(2, ".temporalRestrictions = {.period = %u, .duration = %u},\n")
		ADDNTAB(2, ".noPhysicalMemoryAreas = %d,\n")
		ADDNTAB(2, ".physicalMemoryAreasOffset = %d,\n"),
		partitionTab[e].temporalRestrictions.period, partitionTab[e].temporalRestrictions.duration, partitionTab[e].noPhysicalMemoryAreas, partitionTab[e].physicalMemoryAreasOffset);
	fprintf(outFile, ADDNTAB(2, ".hmTab = {\n"));
	
	for (i=0; i<XM_HM_MAX_EVENTS; i++) {
	    fprintf(outFile,
	    	ADDNTAB(3, "[%d] = {.action = %s, .log = %s, },\n"), i, hmActions[partitionTab[e].hmTab[i].action], hmLog[partitionTab[e].hmTab[i].log]);
	}
	
	fprintf(outFile,
		ADDNTAB(2, "},\n")
		ADDNTAB(2, ".noPorts = %d,\n")
		ADDNTAB(2, ".commPortsOffset = %d,\n"), partitionTab[e].noPorts,
		partitionTab[e].commPortsOffset);

	fprintf(outFile, ADDNTAB(2, ".ioPortsOffset = %d,\n"), partitionTab[e].ioPortsOffset);	
	fprintf(outFile, ADDNTAB(2, ".noIoPorts = %d,\n"), partitionTab[e].noIoPorts);
	fprintf(outFile, ADDNTAB(2, ".trace = {.dev = { .id= 0x%x, .subId = 0x%x, }, .bitmap = 0x%x,},\n"), partitionTab[e].trace.dev.id, partitionTab[e].trace.dev.subId, partitionTab[e].trace.bitmap);
	fprintf(outFile, ADDNTAB(1, "},\n"));
    }
    fprintf(outFile, "};\n\n");
    
    /* Regions Tab */
    fprintf(outFile, "const struct xmcMemoryRegion xmcMemRegTab[] = {\n");
    
    for (e=0; e<xmcTab->noRegions; e++) {
		fprintf(outFile, 
			ADDNTAB(1, "[%d] = {\n")
			ADDNTAB(2, ".startAddr = 0x%x, \n")
			ADDNTAB(2, ".size = %u, \n")
			ADDNTAB(2, ".flags = 0x%x, \n")
			ADDNTAB(1, "},\n"),
			e, memRegTab[e].startAddr, memRegTab[e].size, memRegTab[e].flags);
    }
    
    fprintf(outFile, "};\n\n");

    /* Areas Table */
    fprintf(outFile, "const struct xmcMemoryArea xmcPhysMemAreaTab[] = {\n");
    for (i=0; i<xmcTab->noPhysicalMemoryAreas; i++) {
	fprintf(outFile, ADDNTAB(1, "[%d] = {\n"), i);
	fprintf(outFile, ADDNTAB(2, ".startAddr = 0x%x, "),  physMemAreaTab[i].startAddr);
	fprintf(outFile, ".size = %u, ", physMemAreaTab[i].size);
	fprintf(outFile, ".flags = 0x%x, ", physMemAreaTab[i].flags);
	fprintf(outFile, ".memoryRegionOffset = 0x%x,\n", physMemAreaTab[i].memoryRegionOffset);
	fprintf(outFile, ADDNTAB(1, "},\n"));
    }
    fprintf(outFile, "};\n\n");

    /* Cyclic slots */
    fprintf(outFile, "const struct xmcSchedCyclicSlot xmcSchedCyclicSlotTab[] = {\n");
    for(j=0; j<xmcTab->noSchedCyclicSlots; j++) {
	fprintf(outFile,
		ADDNTAB(1, "[%d] = {\n")
		ADDNTAB(2, ".id = 0x%x,\n")
		ADDNTAB(2, ".partitionId = %d,\n")
		ADDNTAB(2, ".sExec = %d,\n")
		ADDNTAB(2, ".eExec = %d,\n")
		ADDNTAB(1, "},\n"),
		j, schedCyclicSlotTab[j].id, schedCyclicSlotTab[j].partitionId, schedCyclicSlotTab[j].sExec, schedCyclicSlotTab[j].eExec);
    }	
    fprintf(outFile, "};\n\n");
    
    /* Cyclic plans */
    fprintf(outFile, "const struct xmcSchedCyclicPlan xmcSchedCyclicPlanTab[] = {\n");
    for(j=0; j<xmcTab->noSchedCyclicPlans; j++) {
    fprintf(outFile,
        ADDNTAB(1, "[%d] = {\n")
        ADDNTAB(2, ".id = 0x%x,\n")
        ADDNTAB(2, ".majorFrame = %u,\n")
        ADDNTAB(2, ".noSlots = %d,\n")
        ADDNTAB(2, ".slotsOffset = %d,\n")
        ADDNTAB(1, "},\n"),
        j, schedCyclicPlanTab[j].id, schedCyclicPlanTab[j].majorFrame, schedCyclicPlanTab[j].noSlots, schedCyclicPlanTab[j].slotsOffset);
    }
    fprintf(outFile, "};\n\n");

    /* Comm Channel Tab */
    fprintf(outFile, "const struct xmcCommChannel xmcCommChannelTab[] = {\n");
    
    for (e=0; e<xmcTab->noCommChannels; e++) {
	fprintf(outFile,
		ADDNTAB(1, "[%d] = {\n")
		ADDNTAB(2, ".type = "),	e);
	
	switch(commChannelTab[e].type) {
	case XM_SAMPLING_CHANNEL:
	    fprintf(outFile,
		    "XM_SAMPLING_CHANNEL,\n"
		    ADDNTAB(2, "{.s.maxLength = %d, },\n"),
		    commChannelTab[e].s.maxLength);
	    break;
	case XM_QUEUING_CHANNEL:
	    fprintf(outFile,
		    "XM_QUEUING_CHANNEL,\n"
		    ADDNTAB(2, "{.q.maxLength = %d,\n")
		    ADDNTAB(2, ".q.maxNoMsgs = %d, },\n"),
		    commChannelTab[e].q.maxLength, commChannelTab[e].q.maxNoMsgs);
	    break;
	}
	
	fprintf(outFile,
		ADDNTAB(2, ".validPeriod = %u,\n")
		ADDNTAB(1, "},\n"),
		commChannelTab[e].validPeriod);
    }
    
    fprintf(outFile, "};\n\n");
    /* Comm-port table */
    fprintf(outFile, "const struct xmcCommPort xmcCommPorts[] = {\n");
    for (e=0; e<xmcTab->noCommPorts; e++) {
	fprintf(outFile,
	    	ADDNTAB(1, "[%d] = {\n")
	    	ADDNTAB(2, ".nameOffset = %d,\n")
		ADDNTAB(2, ".channelId = "),
		e , commPorts[e].nameOffset);
	
	if (commPorts[e].channelId==XM_NULL_CHANNEL) {
	    fprintf(outFile, "XM_NULL_CHANNEL, \n");
	} else {
	    fprintf(outFile,
		    "%d, \n", commPorts[e].channelId);
	}
	
	fprintf(outFile, ADDNTAB(2, ".direction = "));
	
	switch(commPorts[e].direction) {
	case XM_SOURCE_PORT:
	    fprintf(outFile, "XM_SOURCE_PORT, \n");
	    break;
	case XM_DESTINATION_PORT:
	    fprintf(outFile, "XM_DESTINATION_PORT, \n");
	    break;
	}
	
	fprintf(outFile, ADDNTAB(2, ".type = "));
	switch(commPorts[e].type) {
	case XM_SAMPLING_PORT:
	    fprintf(outFile, "XM_SAMPLING_PORT, \n");
	    break;
	case XM_QUEUING_PORT:
	    fprintf(outFile, "XM_QUEUING_PORT, \n");
	    break;
	}
	fprintf(outFile, ADDNTAB(1, "},\n"));
    }
    fprintf(outFile, "};\n\n");
    
    /* Io Ports */
    fprintf(outFile, "const struct xmcIoPort xmcIoPortTab[] = {\n");
    for (i=0; i<xmcTab->noIoPorts; i++) {
	fprintf(outFile, ADDNTAB(1, "[%d] = { .map = {\n"), i);
#if defined(CONFIG_IA32)
	{
	    int f;
	    for (f=0, j=1; j<2048; j++) {
		if (ioPortTab[i].map[f]!=ioPortTab[i].map[j]) {
		    if (f!=(j-1))
			fprintf(outFile, ADDNTAB(2, "[%d ... %d] = 0x%x,\n"), f, j-1, ioPortTab[i].map[f]);
		    else
			fprintf(outFile, ADDNTAB(2, "[%d] = 0x%x,\n"), f, ioPortTab[i].map[f]);
		    f=j;
		}
	    }
	    if (f!=2047)
		fprintf(outFile, ADDNTAB(2, "[%d ... 2047] = 0x%x,\n"), f, ioPortTab[i].map[f]);
	    else
		fprintf(outFile, ADDNTAB(2, "[2047] = 0x%x,\n"), ioPortTab[i].map[f]);	
	}
#elif defined(CONFIG_SPARCV8)
	fprintf(outFile, ADDNTAB(2, ".type = "));
	if (ioPortTab[i].type==XM_IOPORT_RANGE) {
	    fprintf(outFile, "XM_IOPORT_RANGE,\n");
	    fprintf(outFile, ADDNTAB(2, "{.ioPortRange.base = 0x%x,\n"), ioPortTab[i].ioPortRange.base);
	    fprintf(outFile, ADDNTAB(2, ".ioPortRange.noPorts = %d, },\n"), ioPortTab[i].ioPortRange.noPorts);
	} else {
	    fprintf(outFile, "XM_RESTRICTED_IOPORT,\n");
	    fprintf(outFile, ADDNTAB(2, ".restrictedIoPort = {\n"));
	    fprintf(outFile, ADDNTAB(3, ".address = 0x%x,\n"), ioPortTab[i].restrictedIoPort.address);
	    fprintf(outFile, ADDNTAB(3, ".mask = 0x%x,\n"), ioPortTab[i].restrictedIoPort.mask);
	    fprintf(outFile, ADDNTAB(2, "},\n"));
	}
#endif
	fprintf(outFile, ADDNTAB(1, "}, },\n"));
    }
    fprintf(outFile, "};\n\n");

    /* String Table */
    fprintf(outFile, "char xmcStringTab[] = {\n");
    for (i=0; i<xmcTab->stringTabLength; i++)
	fprintf(outFile, ADDNTAB(1, "0x%x, "), stringTab[i]);
    fprintf(outFile, "};\n\n");

    /* Device Tables */
    ExecDevTab2cHandlers(xmcTab, outFile);

    /* XMC Table */
    fprintf(outFile,
	    "const struct xmc xmc __attribute__ ((section(\".rodata.hdr\"))) = {\n"
	    ADDNTAB(1, ".signature = XMC_SIGNATURE,\n")
	    ADDNTAB(1, ".size = (xmSize_t)_xmcSize,\n")
	    ADDNTAB(1, ".version = XMC_SET_VERSION(%d, %d, %d),\n")
	    ADDNTAB(1, ".fileVersion = XMC_SET_VERSION(%d, %d, %d),\n")	    
	    ADDNTAB(1, ".checksum = 0x%x,\n")
	    ADDNTAB(1, ".nameOffset = %d,\n"),
	    XMC_VERSION, XMC_SUBVERSION, XMC_REVISION, XMC_GET_VERSION(xmcTab->fileVersion), XMC_GET_SUBVERSION(xmcTab->fileVersion), XMC_GET_REVISION(xmcTab->fileVersion), checksum, xmcTab->nameOffset);
    
    fprintf(outFile, ADDNTAB(1, ".hpv = {\n"));
    fprintf(outFile, ADDNTAB(2, ".noPhysicalMemoryAreas = %d,\n"), xmcTab->hpv.noPhysicalMemoryAreas);    
    fprintf(outFile, ADDNTAB(2, ".physicalMemoryAreasOffset = %d,\n"), xmcTab->hpv.physicalMemoryAreasOffset);
    fprintf(outFile, ADDNTAB(2, ".noCpus = %d,\n")
	    ADDNTAB(2, ".cpuTab = {\n"), xmcTab->hpv.noCpus);

    for (e=0; e<xmcTab->hpv.noCpus; e++) {
		fprintf(outFile,
			ADDNTAB(3, "[%d] = {\n")
			ADDNTAB(4, ".id = %d,\n")
			ADDNTAB(4, ".features = 0x%x,\n")
			ADDNTAB(4, ".freq = "), e, xmcTab->hpv.cpuTab[e].id, xmcTab->hpv.cpuTab[e].features);

		if (!xmcTab->hpv.cpuTab[e].freq)
		    fprintf(outFile, "XM_CPUFREQ_AUTO,\n");
		else
	 	   fprintf(outFile, "%u,\n",xmcTab->hpv.cpuTab[e].freq);

		fprintf(outFile, ADDNTAB(4, ".schedPolicy = "));
		switch(xmcTab->hpv.cpuTab[e].schedPolicy) {
		case XM_SCHED_CYCLIC:
			fprintf(outFile, 
				"XM_SCHED_CYCLIC, \n"
				ADDNTAB(4, ".schedParams = {\n")
				ADDNTAB(5, ".cyclic = {\n")
				ADDNTAB(6, ".schedCyclicPlansOffset = %d,\n")
				ADDNTAB(6, ".noSchedCyclicPlans = %d,\n"),
				xmcTab->hpv.cpuTab[e].schedParams.cyclic.schedCyclicPlansOffset,
				xmcTab->hpv.cpuTab[e].schedParams.cyclic.noSchedCyclicPlans);

			/*for(i=0; i<xmcTab->hpv.cpuTab[e].schedParams.cyclic.noPlans; i++) {
				fprintf(outFile,
					ADDNTAB(7, "[%d] = {\n")
					ADDNTAB(8, ".id = %d, \n")
					ADDNTAB(8, ".majorFrame = %u, \n")
					ADDNTAB(8, ".noSlots = %d,\n")
					ADDNTAB(8, ".slotsOffset = %d,\n"),
					i, xmcTab->hpv.cpuTab[e].schedParams.cyclic.planTab[i].id, xmcTab->hpv.cpuTab[e].schedParams.cyclic.planTab[i].majorFrame, xmcTab->hpv.cpuTab[e].schedParams.cyclic.planTab[i].noSlots, xmcTab->hpv.cpuTab[e].schedParams.cyclic.planTab[i].slotsOffset);
		fprintf(outFile, ADDNTAB(7, "},\n"));
	    }*/
	    fprintf(outFile,
	    	ADDNTAB(5, "},\n")
	    	ADDNTAB(4, "},\n"));
	    break;
	}

	fprintf(outFile, ADDNTAB(3, "},\n"));
    }
    
    fprintf(outFile,
	    ADDNTAB(2, "},\n"));

    fprintf(outFile,
	    ADDNTAB(2, ".hwIrqTab = {\n"));
    
    for (e=0; e<CONFIG_NO_HWIRQS; e++) {
		fprintf(outFile, ADDNTAB(3, "[%d] = {.owner = "), e);
		
		if (xmcTab->hpv.hwIrqTab[e].owner==XM_IRQ_NO_OWNER)
		    fprintf(outFile, "XM_IRQ_NO_OWNER, },\n");
		else
		    fprintf(outFile, "%d, },\n", xmcTab->hpv.hwIrqTab[e].owner);
    }
    fprintf(outFile, ADDNTAB(2, "},\n"));
    fprintf(outFile, ADDNTAB(2, ".hmTab = {\n"));
    for (i=0; i<XM_HM_MAX_EVENTS; i++) {
	fprintf(outFile, ADDNTAB(3, "[%d] = {.action = %s, .log = %s },\n"), i, hmActions[xmcTab->hpv.hmTab[i].action], hmLog[xmcTab->hpv.hmTab[i].log]);
    }
    fprintf(outFile, ADDNTAB(2, "},\n"));
    fprintf(outFile, ADDNTAB(2, ".trace = {.dev = { .id = 0x%x, .subId = 0x%x,}, .bitmap = 0x%x,},\n"), xmcTab->hpv.trace.dev.id, xmcTab->hpv.trace.dev.subId, xmcTab->hpv.trace.bitmap);
    fprintf(outFile, ADDNTAB(2, ".consoleDev = { .id= 0x%x, .subId = 0x%x,},\n"), xmcTab->hpv.consoleDev.id, xmcTab->hpv.consoleDev.subId);
    fprintf(outFile, ADDNTAB(2, ".hmDev = { .id= 0x%x, .subId = 0x%x,},\n"), xmcTab->hpv.hmDev.id, xmcTab->hpv.hmDev.subId);
    fprintf(outFile, ADDNTAB(2, ".loadPhysAddr = 0x%x,\n"), xmcTab->hpv.loadPhysAddr);
    fprintf(outFile, ADDNTAB(1, "},\n")); 

    fprintf(outFile, ADDNTAB(1, ".rsw = {\n"));
    fprintf(outFile, ADDNTAB(2, ".entryPoint = 0x%x,\n"), xmcTab->rsw.entryPoint);
    fprintf(outFile, ADDNTAB(2, ".noPhysicalMemoryAreas = %d,\n"), xmcTab->rsw.noPhysicalMemoryAreas);
    fprintf(outFile, ADDNTAB(2, ".physicalMemoryAreasOffset = %d\n"), xmcTab->rsw.physicalMemoryAreasOffset);
    fprintf(outFile, ADDNTAB(1, "},\n"));
    fprintf(outFile, ADDNTAB(1, ".partitionTabOffset = (xmAddress_t)xmcPartitionTab,\n"));
    fprintf(outFile,
	    ADDNTAB(1, ".noPartitions = %d,\n"), xmcTab->noPartitions);
    
    fprintf(outFile,
	    ADDNTAB(1, ".memoryRegionsOffset = (xmAddress_t)xmcMemRegTab,\n")
	    ADDNTAB(1, ".noRegions = %d,\n"), xmcTab->noRegions);
    fprintf(outFile,
	    ADDNTAB(1, ".physicalMemoryAreasOffset = (xmAddress_t)xmcPhysMemAreaTab,\n")
	    ADDNTAB(1, ".noPhysicalMemoryAreas = %d,\n"), xmcTab->noPhysicalMemoryAreas);
    fprintf(outFile, 
	    ADDNTAB(1, ".schedCyclicSlotsOffset = (xmAddress_t)xmcSchedCyclicSlotTab,\n")
	    ADDNTAB(1, ".noSchedCyclicSlots = %d,\n"), xmcTab->noSchedCyclicSlots);
    fprintf(outFile, 
        ADDNTAB(1, ".schedCyclicPlansOffset = (xmAddress_t)xmcSchedCyclicPlanTab,\n")
        ADDNTAB(1, ".noSchedCyclicPlans = %d,\n"), xmcTab->noSchedCyclicPlans);
    fprintf(outFile,
	    ADDNTAB(1, ".commChannelTabOffset = (xmAddress_t)xmcCommChannelTab,\n")
	    ADDNTAB(1, ".noCommChannels = %d,\n"), xmcTab->noCommChannels);
    fprintf(outFile, 
	    ADDNTAB(1, ".commPortsOffset = (xmAddress_t)xmcCommPorts,\n")
	    ADDNTAB(1, ".noCommPorts = %d,\n"), xmcTab->noCommPorts);
    fprintf(outFile, 
	    ADDNTAB(1, ".ioPortsOffset = (xmAddress_t)xmcIoPortTab,\n")
	    ADDNTAB(1, ".noIoPorts = %d,\n"), xmcTab->noIoPorts);
    fprintf(outFile, 
	    ADDNTAB(1, ".stringsOffset = (xmAddress_t)xmcStringTab,\n")
	    ADDNTAB(1, ".stringTabLength = %d,\n"), xmcTab->stringTabLength);
    fprintf(outFile,
	    ADDNTAB(1, ".deviceTab = {\n"));
    ExecDev2cHandlers(xmcTab, outFile);
    fprintf(outFile,
	    ADDNTAB(1, "},\n"));
    fprintf(outFile, "};\n");
}
